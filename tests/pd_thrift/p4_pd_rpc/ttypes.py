#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import res_pd_rpc.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class dc_counter_value_t:
  """
  Attributes:
   - packets
   - bytes
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'packets', None, None, ), # 1
    (2, TType.I64, 'bytes', None, None, ), # 2
  )

  def __init__(self, packets=None, bytes=None,):
    self.packets = packets
    self.bytes = bytes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.packets = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.bytes = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_counter_value_t')
    if self.packets is not None:
      oprot.writeFieldBegin('packets', TType.I64, 1)
      oprot.writeI64(self.packets)
      oprot.writeFieldEnd()
    if self.bytes is not None:
      oprot.writeFieldBegin('bytes', TType.I64, 2)
      oprot.writeI64(self.bytes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.packets is None:
      raise TProtocol.TProtocolException(message='Required field packets is unset!')
    if self.bytes is None:
      raise TProtocol.TProtocolException(message='Required field bytes is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.packets)
    value = (value * 31) ^ hash(self.bytes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_counter_flags_t:
  """
  Attributes:
   - read_hw_sync
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'read_hw_sync', None, None, ), # 1
  )

  def __init__(self, read_hw_sync=None,):
    self.read_hw_sync = read_hw_sync

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.read_hw_sync = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_counter_flags_t')
    if self.read_hw_sync is not None:
      oprot.writeFieldBegin('read_hw_sync', TType.BOOL, 1)
      oprot.writeBool(self.read_hw_sync)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.read_hw_sync is None:
      raise TProtocol.TProtocolException(message='Required field read_hw_sync is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.read_hw_sync)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_spanning_tree_match_spec_t:
  """
  Attributes:
   - ingress_metadata_ifindex
   - l2_metadata_stp_group
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'ingress_metadata_ifindex', None, None, ), # 1
    (2, TType.I16, 'l2_metadata_stp_group', None, None, ), # 2
  )

  def __init__(self, ingress_metadata_ifindex=None, l2_metadata_stp_group=None,):
    self.ingress_metadata_ifindex = ingress_metadata_ifindex
    self.l2_metadata_stp_group = l2_metadata_stp_group

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.ingress_metadata_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.l2_metadata_stp_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_spanning_tree_match_spec_t')
    if self.ingress_metadata_ifindex is not None:
      oprot.writeFieldBegin('ingress_metadata_ifindex', TType.I16, 1)
      oprot.writeI16(self.ingress_metadata_ifindex)
      oprot.writeFieldEnd()
    if self.l2_metadata_stp_group is not None:
      oprot.writeFieldBegin('l2_metadata_stp_group', TType.I16, 2)
      oprot.writeI16(self.l2_metadata_stp_group)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_ifindex is unset!')
    if self.l2_metadata_stp_group is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_stp_group is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_ifindex)
    value = (value * 31) ^ hash(self.l2_metadata_stp_group)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_int_bos_match_spec_t:
  """
  Attributes:
   - int_header_total_hop_cnt
   - int_header_total_hop_cnt_mask
   - int_header_instruction_mask_0003
   - int_header_instruction_mask_0003_mask
   - int_header_instruction_mask_0407
   - int_header_instruction_mask_0407_mask
   - int_header_instruction_mask_0811
   - int_header_instruction_mask_0811_mask
   - int_header_instruction_mask_1215
   - int_header_instruction_mask_1215_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'int_header_total_hop_cnt', None, None, ), # 1
    (2, TType.BYTE, 'int_header_total_hop_cnt_mask', None, None, ), # 2
    (3, TType.BYTE, 'int_header_instruction_mask_0003', None, None, ), # 3
    (4, TType.BYTE, 'int_header_instruction_mask_0003_mask', None, None, ), # 4
    (5, TType.BYTE, 'int_header_instruction_mask_0407', None, None, ), # 5
    (6, TType.BYTE, 'int_header_instruction_mask_0407_mask', None, None, ), # 6
    (7, TType.BYTE, 'int_header_instruction_mask_0811', None, None, ), # 7
    (8, TType.BYTE, 'int_header_instruction_mask_0811_mask', None, None, ), # 8
    (9, TType.BYTE, 'int_header_instruction_mask_1215', None, None, ), # 9
    (10, TType.BYTE, 'int_header_instruction_mask_1215_mask', None, None, ), # 10
  )

  def __init__(self, int_header_total_hop_cnt=None, int_header_total_hop_cnt_mask=None, int_header_instruction_mask_0003=None, int_header_instruction_mask_0003_mask=None, int_header_instruction_mask_0407=None, int_header_instruction_mask_0407_mask=None, int_header_instruction_mask_0811=None, int_header_instruction_mask_0811_mask=None, int_header_instruction_mask_1215=None, int_header_instruction_mask_1215_mask=None,):
    self.int_header_total_hop_cnt = int_header_total_hop_cnt
    self.int_header_total_hop_cnt_mask = int_header_total_hop_cnt_mask
    self.int_header_instruction_mask_0003 = int_header_instruction_mask_0003
    self.int_header_instruction_mask_0003_mask = int_header_instruction_mask_0003_mask
    self.int_header_instruction_mask_0407 = int_header_instruction_mask_0407
    self.int_header_instruction_mask_0407_mask = int_header_instruction_mask_0407_mask
    self.int_header_instruction_mask_0811 = int_header_instruction_mask_0811
    self.int_header_instruction_mask_0811_mask = int_header_instruction_mask_0811_mask
    self.int_header_instruction_mask_1215 = int_header_instruction_mask_1215
    self.int_header_instruction_mask_1215_mask = int_header_instruction_mask_1215_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.int_header_total_hop_cnt = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.int_header_total_hop_cnt_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_0003 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_0003_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_0407 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_0407_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_0811 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_0811_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_1215 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_1215_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_int_bos_match_spec_t')
    if self.int_header_total_hop_cnt is not None:
      oprot.writeFieldBegin('int_header_total_hop_cnt', TType.BYTE, 1)
      oprot.writeByte(self.int_header_total_hop_cnt)
      oprot.writeFieldEnd()
    if self.int_header_total_hop_cnt_mask is not None:
      oprot.writeFieldBegin('int_header_total_hop_cnt_mask', TType.BYTE, 2)
      oprot.writeByte(self.int_header_total_hop_cnt_mask)
      oprot.writeFieldEnd()
    if self.int_header_instruction_mask_0003 is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_0003', TType.BYTE, 3)
      oprot.writeByte(self.int_header_instruction_mask_0003)
      oprot.writeFieldEnd()
    if self.int_header_instruction_mask_0003_mask is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_0003_mask', TType.BYTE, 4)
      oprot.writeByte(self.int_header_instruction_mask_0003_mask)
      oprot.writeFieldEnd()
    if self.int_header_instruction_mask_0407 is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_0407', TType.BYTE, 5)
      oprot.writeByte(self.int_header_instruction_mask_0407)
      oprot.writeFieldEnd()
    if self.int_header_instruction_mask_0407_mask is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_0407_mask', TType.BYTE, 6)
      oprot.writeByte(self.int_header_instruction_mask_0407_mask)
      oprot.writeFieldEnd()
    if self.int_header_instruction_mask_0811 is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_0811', TType.BYTE, 7)
      oprot.writeByte(self.int_header_instruction_mask_0811)
      oprot.writeFieldEnd()
    if self.int_header_instruction_mask_0811_mask is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_0811_mask', TType.BYTE, 8)
      oprot.writeByte(self.int_header_instruction_mask_0811_mask)
      oprot.writeFieldEnd()
    if self.int_header_instruction_mask_1215 is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_1215', TType.BYTE, 9)
      oprot.writeByte(self.int_header_instruction_mask_1215)
      oprot.writeFieldEnd()
    if self.int_header_instruction_mask_1215_mask is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_1215_mask', TType.BYTE, 10)
      oprot.writeByte(self.int_header_instruction_mask_1215_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.int_header_total_hop_cnt is None:
      raise TProtocol.TProtocolException(message='Required field int_header_total_hop_cnt is unset!')
    if self.int_header_total_hop_cnt_mask is None:
      raise TProtocol.TProtocolException(message='Required field int_header_total_hop_cnt_mask is unset!')
    if self.int_header_instruction_mask_0003 is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_0003 is unset!')
    if self.int_header_instruction_mask_0003_mask is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_0003_mask is unset!')
    if self.int_header_instruction_mask_0407 is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_0407 is unset!')
    if self.int_header_instruction_mask_0407_mask is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_0407_mask is unset!')
    if self.int_header_instruction_mask_0811 is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_0811 is unset!')
    if self.int_header_instruction_mask_0811_mask is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_0811_mask is unset!')
    if self.int_header_instruction_mask_1215 is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_1215 is unset!')
    if self.int_header_instruction_mask_1215_mask is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_1215_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.int_header_total_hop_cnt)
    value = (value * 31) ^ hash(self.int_header_total_hop_cnt_mask)
    value = (value * 31) ^ hash(self.int_header_instruction_mask_0003)
    value = (value * 31) ^ hash(self.int_header_instruction_mask_0003_mask)
    value = (value * 31) ^ hash(self.int_header_instruction_mask_0407)
    value = (value * 31) ^ hash(self.int_header_instruction_mask_0407_mask)
    value = (value * 31) ^ hash(self.int_header_instruction_mask_0811)
    value = (value * 31) ^ hash(self.int_header_instruction_mask_0811_mask)
    value = (value * 31) ^ hash(self.int_header_instruction_mask_1215)
    value = (value * 31) ^ hash(self.int_header_instruction_mask_1215_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_tunnel_dst_rewrite_match_spec_t:
  """
  Attributes:
   - tunnel_metadata_tunnel_dst_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'tunnel_metadata_tunnel_dst_index', None, None, ), # 1
  )

  def __init__(self, tunnel_metadata_tunnel_dst_index=None,):
    self.tunnel_metadata_tunnel_dst_index = tunnel_metadata_tunnel_dst_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.tunnel_metadata_tunnel_dst_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_tunnel_dst_rewrite_match_spec_t')
    if self.tunnel_metadata_tunnel_dst_index is not None:
      oprot.writeFieldBegin('tunnel_metadata_tunnel_dst_index', TType.I16, 1)
      oprot.writeI16(self.tunnel_metadata_tunnel_dst_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tunnel_metadata_tunnel_dst_index is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_tunnel_dst_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tunnel_metadata_tunnel_dst_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_validate_outer_ethernet_match_spec_t:
  """
  Attributes:
   - l2_metadata_lkp_mac_sa
   - l2_metadata_lkp_mac_sa_mask
   - l2_metadata_lkp_mac_da
   - l2_metadata_lkp_mac_da_mask
   - vlan_tag__0__valid
   - vlan_tag__1__valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'l2_metadata_lkp_mac_sa', None, None, ), # 1
    (2, TType.STRING, 'l2_metadata_lkp_mac_sa_mask', None, None, ), # 2
    (3, TType.STRING, 'l2_metadata_lkp_mac_da', None, None, ), # 3
    (4, TType.STRING, 'l2_metadata_lkp_mac_da_mask', None, None, ), # 4
    (5, TType.BYTE, 'vlan_tag__0__valid', None, None, ), # 5
    (6, TType.BYTE, 'vlan_tag__1__valid', None, None, ), # 6
  )

  def __init__(self, l2_metadata_lkp_mac_sa=None, l2_metadata_lkp_mac_sa_mask=None, l2_metadata_lkp_mac_da=None, l2_metadata_lkp_mac_da_mask=None, vlan_tag__0__valid=None, vlan_tag__1__valid=None,):
    self.l2_metadata_lkp_mac_sa = l2_metadata_lkp_mac_sa
    self.l2_metadata_lkp_mac_sa_mask = l2_metadata_lkp_mac_sa_mask
    self.l2_metadata_lkp_mac_da = l2_metadata_lkp_mac_da
    self.l2_metadata_lkp_mac_da_mask = l2_metadata_lkp_mac_da_mask
    self.vlan_tag__0__valid = vlan_tag__0__valid
    self.vlan_tag__1__valid = vlan_tag__1__valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_sa_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_da = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_da_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.vlan_tag__0__valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.vlan_tag__1__valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_validate_outer_ethernet_match_spec_t')
    if self.l2_metadata_lkp_mac_sa is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_sa', TType.STRING, 1)
      oprot.writeString(self.l2_metadata_lkp_mac_sa)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_sa_mask is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_sa_mask', TType.STRING, 2)
      oprot.writeString(self.l2_metadata_lkp_mac_sa_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_da is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_da', TType.STRING, 3)
      oprot.writeString(self.l2_metadata_lkp_mac_da)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_da_mask is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_da_mask', TType.STRING, 4)
      oprot.writeString(self.l2_metadata_lkp_mac_da_mask)
      oprot.writeFieldEnd()
    if self.vlan_tag__0__valid is not None:
      oprot.writeFieldBegin('vlan_tag__0__valid', TType.BYTE, 5)
      oprot.writeByte(self.vlan_tag__0__valid)
      oprot.writeFieldEnd()
    if self.vlan_tag__1__valid is not None:
      oprot.writeFieldBegin('vlan_tag__1__valid', TType.BYTE, 6)
      oprot.writeByte(self.vlan_tag__1__valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l2_metadata_lkp_mac_sa is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_sa is unset!')
    if self.l2_metadata_lkp_mac_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_sa_mask is unset!')
    if self.l2_metadata_lkp_mac_da is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_da is unset!')
    if self.l2_metadata_lkp_mac_da_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_da_mask is unset!')
    if self.vlan_tag__0__valid is None:
      raise TProtocol.TProtocolException(message='Required field vlan_tag__0__valid is unset!')
    if self.vlan_tag__1__valid is None:
      raise TProtocol.TProtocolException(message='Required field vlan_tag__1__valid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_sa)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_sa_mask)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_da)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_da_mask)
    value = (value * 31) ^ hash(self.vlan_tag__0__valid)
    value = (value * 31) ^ hash(self.vlan_tag__1__valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_qos_match_spec_t:
  """
  Attributes:
   - acl_metadata_if_label
   - acl_metadata_if_label_mask
   - ipv4_metadata_lkp_ipv4_sa
   - ipv4_metadata_lkp_ipv4_sa_mask
   - ipv4_metadata_lkp_ipv4_da
   - ipv4_metadata_lkp_ipv4_da_mask
   - l3_metadata_lkp_ip_proto
   - l3_metadata_lkp_ip_proto_mask
   - l3_metadata_lkp_ip_tc
   - l3_metadata_lkp_ip_tc_mask
   - tunnel_metadata_mpls_exp
   - tunnel_metadata_mpls_exp_mask
   - qos_metadata_outer_dscp
   - qos_metadata_outer_dscp_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'acl_metadata_if_label', None, None, ), # 1
    (2, TType.I16, 'acl_metadata_if_label_mask', None, None, ), # 2
    (3, TType.I32, 'ipv4_metadata_lkp_ipv4_sa', None, None, ), # 3
    (4, TType.I32, 'ipv4_metadata_lkp_ipv4_sa_mask', None, None, ), # 4
    (5, TType.I32, 'ipv4_metadata_lkp_ipv4_da', None, None, ), # 5
    (6, TType.I32, 'ipv4_metadata_lkp_ipv4_da_mask', None, None, ), # 6
    (7, TType.BYTE, 'l3_metadata_lkp_ip_proto', None, None, ), # 7
    (8, TType.BYTE, 'l3_metadata_lkp_ip_proto_mask', None, None, ), # 8
    (9, TType.BYTE, 'l3_metadata_lkp_ip_tc', None, None, ), # 9
    (10, TType.BYTE, 'l3_metadata_lkp_ip_tc_mask', None, None, ), # 10
    (11, TType.BYTE, 'tunnel_metadata_mpls_exp', None, None, ), # 11
    (12, TType.BYTE, 'tunnel_metadata_mpls_exp_mask', None, None, ), # 12
    (13, TType.BYTE, 'qos_metadata_outer_dscp', None, None, ), # 13
    (14, TType.BYTE, 'qos_metadata_outer_dscp_mask', None, None, ), # 14
  )

  def __init__(self, acl_metadata_if_label=None, acl_metadata_if_label_mask=None, ipv4_metadata_lkp_ipv4_sa=None, ipv4_metadata_lkp_ipv4_sa_mask=None, ipv4_metadata_lkp_ipv4_da=None, ipv4_metadata_lkp_ipv4_da_mask=None, l3_metadata_lkp_ip_proto=None, l3_metadata_lkp_ip_proto_mask=None, l3_metadata_lkp_ip_tc=None, l3_metadata_lkp_ip_tc_mask=None, tunnel_metadata_mpls_exp=None, tunnel_metadata_mpls_exp_mask=None, qos_metadata_outer_dscp=None, qos_metadata_outer_dscp_mask=None,):
    self.acl_metadata_if_label = acl_metadata_if_label
    self.acl_metadata_if_label_mask = acl_metadata_if_label_mask
    self.ipv4_metadata_lkp_ipv4_sa = ipv4_metadata_lkp_ipv4_sa
    self.ipv4_metadata_lkp_ipv4_sa_mask = ipv4_metadata_lkp_ipv4_sa_mask
    self.ipv4_metadata_lkp_ipv4_da = ipv4_metadata_lkp_ipv4_da
    self.ipv4_metadata_lkp_ipv4_da_mask = ipv4_metadata_lkp_ipv4_da_mask
    self.l3_metadata_lkp_ip_proto = l3_metadata_lkp_ip_proto
    self.l3_metadata_lkp_ip_proto_mask = l3_metadata_lkp_ip_proto_mask
    self.l3_metadata_lkp_ip_tc = l3_metadata_lkp_ip_tc
    self.l3_metadata_lkp_ip_tc_mask = l3_metadata_lkp_ip_tc_mask
    self.tunnel_metadata_mpls_exp = tunnel_metadata_mpls_exp
    self.tunnel_metadata_mpls_exp_mask = tunnel_metadata_mpls_exp_mask
    self.qos_metadata_outer_dscp = qos_metadata_outer_dscp
    self.qos_metadata_outer_dscp_mask = qos_metadata_outer_dscp_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.acl_metadata_if_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.acl_metadata_if_label_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_tc = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_tc_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BYTE:
          self.tunnel_metadata_mpls_exp = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BYTE:
          self.tunnel_metadata_mpls_exp_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BYTE:
          self.qos_metadata_outer_dscp = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BYTE:
          self.qos_metadata_outer_dscp_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_qos_match_spec_t')
    if self.acl_metadata_if_label is not None:
      oprot.writeFieldBegin('acl_metadata_if_label', TType.I16, 1)
      oprot.writeI16(self.acl_metadata_if_label)
      oprot.writeFieldEnd()
    if self.acl_metadata_if_label_mask is not None:
      oprot.writeFieldBegin('acl_metadata_if_label_mask', TType.I16, 2)
      oprot.writeI16(self.acl_metadata_if_label_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa', TType.I32, 3)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa_mask', TType.I32, 4)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da', TType.I32, 5)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da_mask', TType.I32, 6)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto', TType.BYTE, 7)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto_mask', TType.BYTE, 8)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_tc is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_tc', TType.BYTE, 9)
      oprot.writeByte(self.l3_metadata_lkp_ip_tc)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_tc_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_tc_mask', TType.BYTE, 10)
      oprot.writeByte(self.l3_metadata_lkp_ip_tc_mask)
      oprot.writeFieldEnd()
    if self.tunnel_metadata_mpls_exp is not None:
      oprot.writeFieldBegin('tunnel_metadata_mpls_exp', TType.BYTE, 11)
      oprot.writeByte(self.tunnel_metadata_mpls_exp)
      oprot.writeFieldEnd()
    if self.tunnel_metadata_mpls_exp_mask is not None:
      oprot.writeFieldBegin('tunnel_metadata_mpls_exp_mask', TType.BYTE, 12)
      oprot.writeByte(self.tunnel_metadata_mpls_exp_mask)
      oprot.writeFieldEnd()
    if self.qos_metadata_outer_dscp is not None:
      oprot.writeFieldBegin('qos_metadata_outer_dscp', TType.BYTE, 13)
      oprot.writeByte(self.qos_metadata_outer_dscp)
      oprot.writeFieldEnd()
    if self.qos_metadata_outer_dscp_mask is not None:
      oprot.writeFieldBegin('qos_metadata_outer_dscp_mask', TType.BYTE, 14)
      oprot.writeByte(self.qos_metadata_outer_dscp_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.acl_metadata_if_label is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_if_label is unset!')
    if self.acl_metadata_if_label_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_if_label_mask is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa_mask is unset!')
    if self.ipv4_metadata_lkp_ipv4_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da is unset!')
    if self.ipv4_metadata_lkp_ipv4_da_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da_mask is unset!')
    if self.l3_metadata_lkp_ip_proto is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto is unset!')
    if self.l3_metadata_lkp_ip_proto_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto_mask is unset!')
    if self.l3_metadata_lkp_ip_tc is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_tc is unset!')
    if self.l3_metadata_lkp_ip_tc_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_tc_mask is unset!')
    if self.tunnel_metadata_mpls_exp is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_mpls_exp is unset!')
    if self.tunnel_metadata_mpls_exp_mask is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_mpls_exp_mask is unset!')
    if self.qos_metadata_outer_dscp is None:
      raise TProtocol.TProtocolException(message='Required field qos_metadata_outer_dscp is unset!')
    if self.qos_metadata_outer_dscp_mask is None:
      raise TProtocol.TProtocolException(message='Required field qos_metadata_outer_dscp_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.acl_metadata_if_label)
    value = (value * 31) ^ hash(self.acl_metadata_if_label_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_tc)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_tc_mask)
    value = (value * 31) ^ hash(self.tunnel_metadata_mpls_exp)
    value = (value * 31) ^ hash(self.tunnel_metadata_mpls_exp_mask)
    value = (value * 31) ^ hash(self.qos_metadata_outer_dscp)
    value = (value * 31) ^ hash(self.qos_metadata_outer_dscp_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv6_fib_lpm_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv6_metadata_lkp_ipv6_da
   - ipv6_metadata_lkp_ipv6_da_prefix_length
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.STRING, 'ipv6_metadata_lkp_ipv6_da', None, None, ), # 2
    (3, TType.I16, 'ipv6_metadata_lkp_ipv6_da_prefix_length', None, None, ), # 3
  )

  def __init__(self, l3_metadata_vrf=None, ipv6_metadata_lkp_ipv6_da=None, ipv6_metadata_lkp_ipv6_da_prefix_length=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv6_metadata_lkp_ipv6_da = ipv6_metadata_lkp_ipv6_da
    self.ipv6_metadata_lkp_ipv6_da_prefix_length = ipv6_metadata_lkp_ipv6_da_prefix_length

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_da = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.ipv6_metadata_lkp_ipv6_da_prefix_length = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv6_fib_lpm_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_da is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_da', TType.STRING, 2)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_da)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_da_prefix_length is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_da_prefix_length', TType.I16, 3)
      oprot.writeI16(self.ipv6_metadata_lkp_ipv6_da_prefix_length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv6_metadata_lkp_ipv6_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_da is unset!')
    if self.ipv6_metadata_lkp_ipv6_da_prefix_length is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_da_prefix_length is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_da)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_da_prefix_length)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_egress_acl_match_spec_t:
  """
  Attributes:
   - standard_metadata_egress_port
   - standard_metadata_egress_port_mask
   - intrinsic_metadata_deflection_flag
   - intrinsic_metadata_deflection_flag_mask
   - l3_metadata_l3_mtu_check
   - l3_metadata_l3_mtu_check_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'standard_metadata_egress_port', None, None, ), # 1
    (2, TType.I16, 'standard_metadata_egress_port_mask', None, None, ), # 2
    (3, TType.BYTE, 'intrinsic_metadata_deflection_flag', None, None, ), # 3
    (4, TType.BYTE, 'intrinsic_metadata_deflection_flag_mask', None, None, ), # 4
    (5, TType.I16, 'l3_metadata_l3_mtu_check', None, None, ), # 5
    (6, TType.I16, 'l3_metadata_l3_mtu_check_mask', None, None, ), # 6
  )

  def __init__(self, standard_metadata_egress_port=None, standard_metadata_egress_port_mask=None, intrinsic_metadata_deflection_flag=None, intrinsic_metadata_deflection_flag_mask=None, l3_metadata_l3_mtu_check=None, l3_metadata_l3_mtu_check_mask=None,):
    self.standard_metadata_egress_port = standard_metadata_egress_port
    self.standard_metadata_egress_port_mask = standard_metadata_egress_port_mask
    self.intrinsic_metadata_deflection_flag = intrinsic_metadata_deflection_flag
    self.intrinsic_metadata_deflection_flag_mask = intrinsic_metadata_deflection_flag_mask
    self.l3_metadata_l3_mtu_check = l3_metadata_l3_mtu_check
    self.l3_metadata_l3_mtu_check_mask = l3_metadata_l3_mtu_check_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.standard_metadata_egress_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.standard_metadata_egress_port_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.intrinsic_metadata_deflection_flag = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.intrinsic_metadata_deflection_flag_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.l3_metadata_l3_mtu_check = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I16:
          self.l3_metadata_l3_mtu_check_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_egress_acl_match_spec_t')
    if self.standard_metadata_egress_port is not None:
      oprot.writeFieldBegin('standard_metadata_egress_port', TType.I16, 1)
      oprot.writeI16(self.standard_metadata_egress_port)
      oprot.writeFieldEnd()
    if self.standard_metadata_egress_port_mask is not None:
      oprot.writeFieldBegin('standard_metadata_egress_port_mask', TType.I16, 2)
      oprot.writeI16(self.standard_metadata_egress_port_mask)
      oprot.writeFieldEnd()
    if self.intrinsic_metadata_deflection_flag is not None:
      oprot.writeFieldBegin('intrinsic_metadata_deflection_flag', TType.BYTE, 3)
      oprot.writeByte(self.intrinsic_metadata_deflection_flag)
      oprot.writeFieldEnd()
    if self.intrinsic_metadata_deflection_flag_mask is not None:
      oprot.writeFieldBegin('intrinsic_metadata_deflection_flag_mask', TType.BYTE, 4)
      oprot.writeByte(self.intrinsic_metadata_deflection_flag_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_l3_mtu_check is not None:
      oprot.writeFieldBegin('l3_metadata_l3_mtu_check', TType.I16, 5)
      oprot.writeI16(self.l3_metadata_l3_mtu_check)
      oprot.writeFieldEnd()
    if self.l3_metadata_l3_mtu_check_mask is not None:
      oprot.writeFieldBegin('l3_metadata_l3_mtu_check_mask', TType.I16, 6)
      oprot.writeI16(self.l3_metadata_l3_mtu_check_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.standard_metadata_egress_port is None:
      raise TProtocol.TProtocolException(message='Required field standard_metadata_egress_port is unset!')
    if self.standard_metadata_egress_port_mask is None:
      raise TProtocol.TProtocolException(message='Required field standard_metadata_egress_port_mask is unset!')
    if self.intrinsic_metadata_deflection_flag is None:
      raise TProtocol.TProtocolException(message='Required field intrinsic_metadata_deflection_flag is unset!')
    if self.intrinsic_metadata_deflection_flag_mask is None:
      raise TProtocol.TProtocolException(message='Required field intrinsic_metadata_deflection_flag_mask is unset!')
    if self.l3_metadata_l3_mtu_check is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_l3_mtu_check is unset!')
    if self.l3_metadata_l3_mtu_check_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_l3_mtu_check_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.standard_metadata_egress_port)
    value = (value * 31) ^ hash(self.standard_metadata_egress_port_mask)
    value = (value * 31) ^ hash(self.intrinsic_metadata_deflection_flag)
    value = (value * 31) ^ hash(self.intrinsic_metadata_deflection_flag_mask)
    value = (value * 31) ^ hash(self.l3_metadata_l3_mtu_check)
    value = (value * 31) ^ hash(self.l3_metadata_l3_mtu_check_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_match_spec_t:
  """
  Attributes:
   - l3_metadata_nexthop_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_nexthop_index', None, None, ), # 1
  )

  def __init__(self, l3_metadata_nexthop_index=None,):
    self.l3_metadata_nexthop_index = l3_metadata_nexthop_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_nexthop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_match_spec_t')
    if self.l3_metadata_nexthop_index is not None:
      oprot.writeFieldBegin('l3_metadata_nexthop_index', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_nexthop_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_nexthop_index is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_nexthop_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_nexthop_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv6_acl_match_spec_t:
  """
  Attributes:
   - acl_metadata_if_label
   - acl_metadata_if_label_mask
   - acl_metadata_bd_label
   - acl_metadata_bd_label_mask
   - ipv6_metadata_lkp_ipv6_sa
   - ipv6_metadata_lkp_ipv6_sa_mask
   - ipv6_metadata_lkp_ipv6_da
   - ipv6_metadata_lkp_ipv6_da_mask
   - l3_metadata_lkp_ip_proto
   - l3_metadata_lkp_ip_proto_mask
   - l3_metadata_lkp_l4_sport
   - l3_metadata_lkp_l4_sport_mask
   - l3_metadata_lkp_l4_dport
   - l3_metadata_lkp_l4_dport_mask
   - tcp_flags
   - tcp_flags_mask
   - l3_metadata_lkp_ip_ttl
   - l3_metadata_lkp_ip_ttl_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'acl_metadata_if_label', None, None, ), # 1
    (2, TType.I16, 'acl_metadata_if_label_mask', None, None, ), # 2
    (3, TType.I16, 'acl_metadata_bd_label', None, None, ), # 3
    (4, TType.I16, 'acl_metadata_bd_label_mask', None, None, ), # 4
    (5, TType.STRING, 'ipv6_metadata_lkp_ipv6_sa', None, None, ), # 5
    (6, TType.STRING, 'ipv6_metadata_lkp_ipv6_sa_mask', None, None, ), # 6
    (7, TType.STRING, 'ipv6_metadata_lkp_ipv6_da', None, None, ), # 7
    (8, TType.STRING, 'ipv6_metadata_lkp_ipv6_da_mask', None, None, ), # 8
    (9, TType.BYTE, 'l3_metadata_lkp_ip_proto', None, None, ), # 9
    (10, TType.BYTE, 'l3_metadata_lkp_ip_proto_mask', None, None, ), # 10
    (11, TType.I16, 'l3_metadata_lkp_l4_sport', None, None, ), # 11
    (12, TType.I16, 'l3_metadata_lkp_l4_sport_mask', None, None, ), # 12
    (13, TType.I16, 'l3_metadata_lkp_l4_dport', None, None, ), # 13
    (14, TType.I16, 'l3_metadata_lkp_l4_dport_mask', None, None, ), # 14
    (15, TType.BYTE, 'tcp_flags', None, None, ), # 15
    (16, TType.BYTE, 'tcp_flags_mask', None, None, ), # 16
    (17, TType.BYTE, 'l3_metadata_lkp_ip_ttl', None, None, ), # 17
    (18, TType.BYTE, 'l3_metadata_lkp_ip_ttl_mask', None, None, ), # 18
  )

  def __init__(self, acl_metadata_if_label=None, acl_metadata_if_label_mask=None, acl_metadata_bd_label=None, acl_metadata_bd_label_mask=None, ipv6_metadata_lkp_ipv6_sa=None, ipv6_metadata_lkp_ipv6_sa_mask=None, ipv6_metadata_lkp_ipv6_da=None, ipv6_metadata_lkp_ipv6_da_mask=None, l3_metadata_lkp_ip_proto=None, l3_metadata_lkp_ip_proto_mask=None, l3_metadata_lkp_l4_sport=None, l3_metadata_lkp_l4_sport_mask=None, l3_metadata_lkp_l4_dport=None, l3_metadata_lkp_l4_dport_mask=None, tcp_flags=None, tcp_flags_mask=None, l3_metadata_lkp_ip_ttl=None, l3_metadata_lkp_ip_ttl_mask=None,):
    self.acl_metadata_if_label = acl_metadata_if_label
    self.acl_metadata_if_label_mask = acl_metadata_if_label_mask
    self.acl_metadata_bd_label = acl_metadata_bd_label
    self.acl_metadata_bd_label_mask = acl_metadata_bd_label_mask
    self.ipv6_metadata_lkp_ipv6_sa = ipv6_metadata_lkp_ipv6_sa
    self.ipv6_metadata_lkp_ipv6_sa_mask = ipv6_metadata_lkp_ipv6_sa_mask
    self.ipv6_metadata_lkp_ipv6_da = ipv6_metadata_lkp_ipv6_da
    self.ipv6_metadata_lkp_ipv6_da_mask = ipv6_metadata_lkp_ipv6_da_mask
    self.l3_metadata_lkp_ip_proto = l3_metadata_lkp_ip_proto
    self.l3_metadata_lkp_ip_proto_mask = l3_metadata_lkp_ip_proto_mask
    self.l3_metadata_lkp_l4_sport = l3_metadata_lkp_l4_sport
    self.l3_metadata_lkp_l4_sport_mask = l3_metadata_lkp_l4_sport_mask
    self.l3_metadata_lkp_l4_dport = l3_metadata_lkp_l4_dport
    self.l3_metadata_lkp_l4_dport_mask = l3_metadata_lkp_l4_dport_mask
    self.tcp_flags = tcp_flags
    self.tcp_flags_mask = tcp_flags_mask
    self.l3_metadata_lkp_ip_ttl = l3_metadata_lkp_ip_ttl
    self.l3_metadata_lkp_ip_ttl_mask = l3_metadata_lkp_ip_ttl_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.acl_metadata_if_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.acl_metadata_if_label_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.acl_metadata_bd_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.acl_metadata_bd_label_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_sa_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_da = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_da_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_sport = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_sport_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_dport = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_dport_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BYTE:
          self.tcp_flags = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BYTE:
          self.tcp_flags_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv6_acl_match_spec_t')
    if self.acl_metadata_if_label is not None:
      oprot.writeFieldBegin('acl_metadata_if_label', TType.I16, 1)
      oprot.writeI16(self.acl_metadata_if_label)
      oprot.writeFieldEnd()
    if self.acl_metadata_if_label_mask is not None:
      oprot.writeFieldBegin('acl_metadata_if_label_mask', TType.I16, 2)
      oprot.writeI16(self.acl_metadata_if_label_mask)
      oprot.writeFieldEnd()
    if self.acl_metadata_bd_label is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label', TType.I16, 3)
      oprot.writeI16(self.acl_metadata_bd_label)
      oprot.writeFieldEnd()
    if self.acl_metadata_bd_label_mask is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label_mask', TType.I16, 4)
      oprot.writeI16(self.acl_metadata_bd_label_mask)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa', TType.STRING, 5)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_sa)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa_mask is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa_mask', TType.STRING, 6)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_sa_mask)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_da is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_da', TType.STRING, 7)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_da)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_da_mask is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_da_mask', TType.STRING, 8)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_da_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto', TType.BYTE, 9)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto_mask', TType.BYTE, 10)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_sport is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_sport', TType.I16, 11)
      oprot.writeI16(self.l3_metadata_lkp_l4_sport)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_sport_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_sport_mask', TType.I16, 12)
      oprot.writeI16(self.l3_metadata_lkp_l4_sport_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_dport is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_dport', TType.I16, 13)
      oprot.writeI16(self.l3_metadata_lkp_l4_dport)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_dport_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_dport_mask', TType.I16, 14)
      oprot.writeI16(self.l3_metadata_lkp_l4_dport_mask)
      oprot.writeFieldEnd()
    if self.tcp_flags is not None:
      oprot.writeFieldBegin('tcp_flags', TType.BYTE, 15)
      oprot.writeByte(self.tcp_flags)
      oprot.writeFieldEnd()
    if self.tcp_flags_mask is not None:
      oprot.writeFieldBegin('tcp_flags_mask', TType.BYTE, 16)
      oprot.writeByte(self.tcp_flags_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl', TType.BYTE, 17)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl_mask', TType.BYTE, 18)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.acl_metadata_if_label is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_if_label is unset!')
    if self.acl_metadata_if_label_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_if_label_mask is unset!')
    if self.acl_metadata_bd_label is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label is unset!')
    if self.acl_metadata_bd_label_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label_mask is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa_mask is unset!')
    if self.ipv6_metadata_lkp_ipv6_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_da is unset!')
    if self.ipv6_metadata_lkp_ipv6_da_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_da_mask is unset!')
    if self.l3_metadata_lkp_ip_proto is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto is unset!')
    if self.l3_metadata_lkp_ip_proto_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto_mask is unset!')
    if self.l3_metadata_lkp_l4_sport is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_sport is unset!')
    if self.l3_metadata_lkp_l4_sport_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_sport_mask is unset!')
    if self.l3_metadata_lkp_l4_dport is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_dport is unset!')
    if self.l3_metadata_lkp_l4_dport_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_dport_mask is unset!')
    if self.tcp_flags is None:
      raise TProtocol.TProtocolException(message='Required field tcp_flags is unset!')
    if self.tcp_flags_mask is None:
      raise TProtocol.TProtocolException(message='Required field tcp_flags_mask is unset!')
    if self.l3_metadata_lkp_ip_ttl is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl is unset!')
    if self.l3_metadata_lkp_ip_ttl_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.acl_metadata_if_label)
    value = (value * 31) ^ hash(self.acl_metadata_if_label_mask)
    value = (value * 31) ^ hash(self.acl_metadata_bd_label)
    value = (value * 31) ^ hash(self.acl_metadata_bd_label_mask)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa_mask)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_da)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_da_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_sport)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_sport_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_dport)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_dport_mask)
    value = (value * 31) ^ hash(self.tcp_flags)
    value = (value * 31) ^ hash(self.tcp_flags_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_fwd_result_match_spec_t:
  """
  Attributes:
   - l2_metadata_l2_redirect
   - l2_metadata_l2_redirect_mask
   - acl_metadata_acl_redirect
   - acl_metadata_acl_redirect_mask
   - acl_metadata_racl_redirect
   - acl_metadata_racl_redirect_mask
   - l3_metadata_rmac_hit
   - l3_metadata_rmac_hit_mask
   - l3_metadata_fib_hit
   - l3_metadata_fib_hit_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'l2_metadata_l2_redirect', None, None, ), # 1
    (2, TType.BYTE, 'l2_metadata_l2_redirect_mask', None, None, ), # 2
    (3, TType.BYTE, 'acl_metadata_acl_redirect', None, None, ), # 3
    (4, TType.BYTE, 'acl_metadata_acl_redirect_mask', None, None, ), # 4
    (5, TType.BYTE, 'acl_metadata_racl_redirect', None, None, ), # 5
    (6, TType.BYTE, 'acl_metadata_racl_redirect_mask', None, None, ), # 6
    (7, TType.BYTE, 'l3_metadata_rmac_hit', None, None, ), # 7
    (8, TType.BYTE, 'l3_metadata_rmac_hit_mask', None, None, ), # 8
    (9, TType.BYTE, 'l3_metadata_fib_hit', None, None, ), # 9
    (10, TType.BYTE, 'l3_metadata_fib_hit_mask', None, None, ), # 10
  )

  def __init__(self, l2_metadata_l2_redirect=None, l2_metadata_l2_redirect_mask=None, acl_metadata_acl_redirect=None, acl_metadata_acl_redirect_mask=None, acl_metadata_racl_redirect=None, acl_metadata_racl_redirect_mask=None, l3_metadata_rmac_hit=None, l3_metadata_rmac_hit_mask=None, l3_metadata_fib_hit=None, l3_metadata_fib_hit_mask=None,):
    self.l2_metadata_l2_redirect = l2_metadata_l2_redirect
    self.l2_metadata_l2_redirect_mask = l2_metadata_l2_redirect_mask
    self.acl_metadata_acl_redirect = acl_metadata_acl_redirect
    self.acl_metadata_acl_redirect_mask = acl_metadata_acl_redirect_mask
    self.acl_metadata_racl_redirect = acl_metadata_racl_redirect
    self.acl_metadata_racl_redirect_mask = acl_metadata_racl_redirect_mask
    self.l3_metadata_rmac_hit = l3_metadata_rmac_hit
    self.l3_metadata_rmac_hit_mask = l3_metadata_rmac_hit_mask
    self.l3_metadata_fib_hit = l3_metadata_fib_hit
    self.l3_metadata_fib_hit_mask = l3_metadata_fib_hit_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.l2_metadata_l2_redirect = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.l2_metadata_l2_redirect_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.acl_metadata_acl_redirect = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.acl_metadata_acl_redirect_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.acl_metadata_racl_redirect = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.acl_metadata_racl_redirect_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BYTE:
          self.l3_metadata_rmac_hit = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.l3_metadata_rmac_hit_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.l3_metadata_fib_hit = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BYTE:
          self.l3_metadata_fib_hit_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_fwd_result_match_spec_t')
    if self.l2_metadata_l2_redirect is not None:
      oprot.writeFieldBegin('l2_metadata_l2_redirect', TType.BYTE, 1)
      oprot.writeByte(self.l2_metadata_l2_redirect)
      oprot.writeFieldEnd()
    if self.l2_metadata_l2_redirect_mask is not None:
      oprot.writeFieldBegin('l2_metadata_l2_redirect_mask', TType.BYTE, 2)
      oprot.writeByte(self.l2_metadata_l2_redirect_mask)
      oprot.writeFieldEnd()
    if self.acl_metadata_acl_redirect is not None:
      oprot.writeFieldBegin('acl_metadata_acl_redirect', TType.BYTE, 3)
      oprot.writeByte(self.acl_metadata_acl_redirect)
      oprot.writeFieldEnd()
    if self.acl_metadata_acl_redirect_mask is not None:
      oprot.writeFieldBegin('acl_metadata_acl_redirect_mask', TType.BYTE, 4)
      oprot.writeByte(self.acl_metadata_acl_redirect_mask)
      oprot.writeFieldEnd()
    if self.acl_metadata_racl_redirect is not None:
      oprot.writeFieldBegin('acl_metadata_racl_redirect', TType.BYTE, 5)
      oprot.writeByte(self.acl_metadata_racl_redirect)
      oprot.writeFieldEnd()
    if self.acl_metadata_racl_redirect_mask is not None:
      oprot.writeFieldBegin('acl_metadata_racl_redirect_mask', TType.BYTE, 6)
      oprot.writeByte(self.acl_metadata_racl_redirect_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_rmac_hit is not None:
      oprot.writeFieldBegin('l3_metadata_rmac_hit', TType.BYTE, 7)
      oprot.writeByte(self.l3_metadata_rmac_hit)
      oprot.writeFieldEnd()
    if self.l3_metadata_rmac_hit_mask is not None:
      oprot.writeFieldBegin('l3_metadata_rmac_hit_mask', TType.BYTE, 8)
      oprot.writeByte(self.l3_metadata_rmac_hit_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_fib_hit is not None:
      oprot.writeFieldBegin('l3_metadata_fib_hit', TType.BYTE, 9)
      oprot.writeByte(self.l3_metadata_fib_hit)
      oprot.writeFieldEnd()
    if self.l3_metadata_fib_hit_mask is not None:
      oprot.writeFieldBegin('l3_metadata_fib_hit_mask', TType.BYTE, 10)
      oprot.writeByte(self.l3_metadata_fib_hit_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l2_metadata_l2_redirect is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_l2_redirect is unset!')
    if self.l2_metadata_l2_redirect_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_l2_redirect_mask is unset!')
    if self.acl_metadata_acl_redirect is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_acl_redirect is unset!')
    if self.acl_metadata_acl_redirect_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_acl_redirect_mask is unset!')
    if self.acl_metadata_racl_redirect is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_racl_redirect is unset!')
    if self.acl_metadata_racl_redirect_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_racl_redirect_mask is unset!')
    if self.l3_metadata_rmac_hit is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_rmac_hit is unset!')
    if self.l3_metadata_rmac_hit_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_rmac_hit_mask is unset!')
    if self.l3_metadata_fib_hit is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_fib_hit is unset!')
    if self.l3_metadata_fib_hit_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_fib_hit_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l2_metadata_l2_redirect)
    value = (value * 31) ^ hash(self.l2_metadata_l2_redirect_mask)
    value = (value * 31) ^ hash(self.acl_metadata_acl_redirect)
    value = (value * 31) ^ hash(self.acl_metadata_acl_redirect_mask)
    value = (value * 31) ^ hash(self.acl_metadata_racl_redirect)
    value = (value * 31) ^ hash(self.acl_metadata_racl_redirect_mask)
    value = (value * 31) ^ hash(self.l3_metadata_rmac_hit)
    value = (value * 31) ^ hash(self.l3_metadata_rmac_hit_mask)
    value = (value * 31) ^ hash(self.l3_metadata_fib_hit)
    value = (value * 31) ^ hash(self.l3_metadata_fib_hit_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_lag_group_match_spec_t:
  """
  Attributes:
   - ingress_metadata_egress_ifindex
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'ingress_metadata_egress_ifindex', None, None, ), # 1
  )

  def __init__(self, ingress_metadata_egress_ifindex=None,):
    self.ingress_metadata_egress_ifindex = ingress_metadata_egress_ifindex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.ingress_metadata_egress_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_lag_group_match_spec_t')
    if self.ingress_metadata_egress_ifindex is not None:
      oprot.writeFieldBegin('ingress_metadata_egress_ifindex', TType.I16, 1)
      oprot.writeI16(self.ingress_metadata_egress_ifindex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_egress_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_egress_ifindex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_egress_ifindex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_learn_notify_match_spec_t:
  """
  Attributes:
   - l2_metadata_l2_src_miss
   - l2_metadata_l2_src_miss_mask
   - l2_metadata_l2_src_move
   - l2_metadata_l2_src_move_mask
   - l2_metadata_stp_state
   - l2_metadata_stp_state_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'l2_metadata_l2_src_miss', None, None, ), # 1
    (2, TType.BYTE, 'l2_metadata_l2_src_miss_mask', None, None, ), # 2
    (3, TType.I16, 'l2_metadata_l2_src_move', None, None, ), # 3
    (4, TType.I16, 'l2_metadata_l2_src_move_mask', None, None, ), # 4
    (5, TType.BYTE, 'l2_metadata_stp_state', None, None, ), # 5
    (6, TType.BYTE, 'l2_metadata_stp_state_mask', None, None, ), # 6
  )

  def __init__(self, l2_metadata_l2_src_miss=None, l2_metadata_l2_src_miss_mask=None, l2_metadata_l2_src_move=None, l2_metadata_l2_src_move_mask=None, l2_metadata_stp_state=None, l2_metadata_stp_state_mask=None,):
    self.l2_metadata_l2_src_miss = l2_metadata_l2_src_miss
    self.l2_metadata_l2_src_miss_mask = l2_metadata_l2_src_miss_mask
    self.l2_metadata_l2_src_move = l2_metadata_l2_src_move
    self.l2_metadata_l2_src_move_mask = l2_metadata_l2_src_move_mask
    self.l2_metadata_stp_state = l2_metadata_stp_state
    self.l2_metadata_stp_state_mask = l2_metadata_stp_state_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.l2_metadata_l2_src_miss = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.l2_metadata_l2_src_miss_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.l2_metadata_l2_src_move = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.l2_metadata_l2_src_move_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.l2_metadata_stp_state = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.l2_metadata_stp_state_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_learn_notify_match_spec_t')
    if self.l2_metadata_l2_src_miss is not None:
      oprot.writeFieldBegin('l2_metadata_l2_src_miss', TType.BYTE, 1)
      oprot.writeByte(self.l2_metadata_l2_src_miss)
      oprot.writeFieldEnd()
    if self.l2_metadata_l2_src_miss_mask is not None:
      oprot.writeFieldBegin('l2_metadata_l2_src_miss_mask', TType.BYTE, 2)
      oprot.writeByte(self.l2_metadata_l2_src_miss_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_l2_src_move is not None:
      oprot.writeFieldBegin('l2_metadata_l2_src_move', TType.I16, 3)
      oprot.writeI16(self.l2_metadata_l2_src_move)
      oprot.writeFieldEnd()
    if self.l2_metadata_l2_src_move_mask is not None:
      oprot.writeFieldBegin('l2_metadata_l2_src_move_mask', TType.I16, 4)
      oprot.writeI16(self.l2_metadata_l2_src_move_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_stp_state is not None:
      oprot.writeFieldBegin('l2_metadata_stp_state', TType.BYTE, 5)
      oprot.writeByte(self.l2_metadata_stp_state)
      oprot.writeFieldEnd()
    if self.l2_metadata_stp_state_mask is not None:
      oprot.writeFieldBegin('l2_metadata_stp_state_mask', TType.BYTE, 6)
      oprot.writeByte(self.l2_metadata_stp_state_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l2_metadata_l2_src_miss is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_l2_src_miss is unset!')
    if self.l2_metadata_l2_src_miss_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_l2_src_miss_mask is unset!')
    if self.l2_metadata_l2_src_move is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_l2_src_move is unset!')
    if self.l2_metadata_l2_src_move_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_l2_src_move_mask is unset!')
    if self.l2_metadata_stp_state is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_stp_state is unset!')
    if self.l2_metadata_stp_state_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_stp_state_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l2_metadata_l2_src_miss)
    value = (value * 31) ^ hash(self.l2_metadata_l2_src_miss_mask)
    value = (value * 31) ^ hash(self.l2_metadata_l2_src_move)
    value = (value * 31) ^ hash(self.l2_metadata_l2_src_move_mask)
    value = (value * 31) ^ hash(self.l2_metadata_stp_state)
    value = (value * 31) ^ hash(self.l2_metadata_stp_state_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_mac_acl_match_spec_t:
  """
  Attributes:
   - acl_metadata_if_label
   - acl_metadata_if_label_mask
   - acl_metadata_bd_label
   - acl_metadata_bd_label_mask
   - l2_metadata_lkp_mac_sa
   - l2_metadata_lkp_mac_sa_mask
   - l2_metadata_lkp_mac_da
   - l2_metadata_lkp_mac_da_mask
   - l2_metadata_lkp_mac_type
   - l2_metadata_lkp_mac_type_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'acl_metadata_if_label', None, None, ), # 1
    (2, TType.I16, 'acl_metadata_if_label_mask', None, None, ), # 2
    (3, TType.I16, 'acl_metadata_bd_label', None, None, ), # 3
    (4, TType.I16, 'acl_metadata_bd_label_mask', None, None, ), # 4
    (5, TType.STRING, 'l2_metadata_lkp_mac_sa', None, None, ), # 5
    (6, TType.STRING, 'l2_metadata_lkp_mac_sa_mask', None, None, ), # 6
    (7, TType.STRING, 'l2_metadata_lkp_mac_da', None, None, ), # 7
    (8, TType.STRING, 'l2_metadata_lkp_mac_da_mask', None, None, ), # 8
    (9, TType.I16, 'l2_metadata_lkp_mac_type', None, None, ), # 9
    (10, TType.I16, 'l2_metadata_lkp_mac_type_mask', None, None, ), # 10
  )

  def __init__(self, acl_metadata_if_label=None, acl_metadata_if_label_mask=None, acl_metadata_bd_label=None, acl_metadata_bd_label_mask=None, l2_metadata_lkp_mac_sa=None, l2_metadata_lkp_mac_sa_mask=None, l2_metadata_lkp_mac_da=None, l2_metadata_lkp_mac_da_mask=None, l2_metadata_lkp_mac_type=None, l2_metadata_lkp_mac_type_mask=None,):
    self.acl_metadata_if_label = acl_metadata_if_label
    self.acl_metadata_if_label_mask = acl_metadata_if_label_mask
    self.acl_metadata_bd_label = acl_metadata_bd_label
    self.acl_metadata_bd_label_mask = acl_metadata_bd_label_mask
    self.l2_metadata_lkp_mac_sa = l2_metadata_lkp_mac_sa
    self.l2_metadata_lkp_mac_sa_mask = l2_metadata_lkp_mac_sa_mask
    self.l2_metadata_lkp_mac_da = l2_metadata_lkp_mac_da
    self.l2_metadata_lkp_mac_da_mask = l2_metadata_lkp_mac_da_mask
    self.l2_metadata_lkp_mac_type = l2_metadata_lkp_mac_type
    self.l2_metadata_lkp_mac_type_mask = l2_metadata_lkp_mac_type_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.acl_metadata_if_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.acl_metadata_if_label_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.acl_metadata_bd_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.acl_metadata_bd_label_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_sa_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_da = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_da_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I16:
          self.l2_metadata_lkp_mac_type = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I16:
          self.l2_metadata_lkp_mac_type_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_mac_acl_match_spec_t')
    if self.acl_metadata_if_label is not None:
      oprot.writeFieldBegin('acl_metadata_if_label', TType.I16, 1)
      oprot.writeI16(self.acl_metadata_if_label)
      oprot.writeFieldEnd()
    if self.acl_metadata_if_label_mask is not None:
      oprot.writeFieldBegin('acl_metadata_if_label_mask', TType.I16, 2)
      oprot.writeI16(self.acl_metadata_if_label_mask)
      oprot.writeFieldEnd()
    if self.acl_metadata_bd_label is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label', TType.I16, 3)
      oprot.writeI16(self.acl_metadata_bd_label)
      oprot.writeFieldEnd()
    if self.acl_metadata_bd_label_mask is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label_mask', TType.I16, 4)
      oprot.writeI16(self.acl_metadata_bd_label_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_sa is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_sa', TType.STRING, 5)
      oprot.writeString(self.l2_metadata_lkp_mac_sa)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_sa_mask is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_sa_mask', TType.STRING, 6)
      oprot.writeString(self.l2_metadata_lkp_mac_sa_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_da is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_da', TType.STRING, 7)
      oprot.writeString(self.l2_metadata_lkp_mac_da)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_da_mask is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_da_mask', TType.STRING, 8)
      oprot.writeString(self.l2_metadata_lkp_mac_da_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_type is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_type', TType.I16, 9)
      oprot.writeI16(self.l2_metadata_lkp_mac_type)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_type_mask is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_type_mask', TType.I16, 10)
      oprot.writeI16(self.l2_metadata_lkp_mac_type_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.acl_metadata_if_label is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_if_label is unset!')
    if self.acl_metadata_if_label_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_if_label_mask is unset!')
    if self.acl_metadata_bd_label is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label is unset!')
    if self.acl_metadata_bd_label_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label_mask is unset!')
    if self.l2_metadata_lkp_mac_sa is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_sa is unset!')
    if self.l2_metadata_lkp_mac_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_sa_mask is unset!')
    if self.l2_metadata_lkp_mac_da is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_da is unset!')
    if self.l2_metadata_lkp_mac_da_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_da_mask is unset!')
    if self.l2_metadata_lkp_mac_type is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_type is unset!')
    if self.l2_metadata_lkp_mac_type_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_type_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.acl_metadata_if_label)
    value = (value * 31) ^ hash(self.acl_metadata_if_label_mask)
    value = (value * 31) ^ hash(self.acl_metadata_bd_label)
    value = (value * 31) ^ hash(self.acl_metadata_bd_label_mask)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_sa)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_sa_mask)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_da)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_da_mask)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_type)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_type_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_smac_match_spec_t:
  """
  Attributes:
   - ingress_metadata_bd
   - l2_metadata_lkp_mac_sa
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'ingress_metadata_bd', None, None, ), # 1
    (2, TType.STRING, 'l2_metadata_lkp_mac_sa', None, None, ), # 2
  )

  def __init__(self, ingress_metadata_bd=None, l2_metadata_lkp_mac_sa=None,):
    self.ingress_metadata_bd = ingress_metadata_bd
    self.l2_metadata_lkp_mac_sa = l2_metadata_lkp_mac_sa

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.ingress_metadata_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_smac_match_spec_t')
    if self.ingress_metadata_bd is not None:
      oprot.writeFieldBegin('ingress_metadata_bd', TType.I16, 1)
      oprot.writeI16(self.ingress_metadata_bd)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_sa is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_sa', TType.STRING, 2)
      oprot.writeString(self.l2_metadata_lkp_mac_sa)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_bd is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_bd is unset!')
    if self.l2_metadata_lkp_mac_sa is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_sa is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_bd)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_sa)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_int_outer_encap_match_spec_t:
  """
  Attributes:
   - ipv4_valid
   - vxlan_gpe_valid
   - int_metadata_i2e_source
   - tunnel_metadata_egress_tunnel_type
   - tunnel_metadata_egress_tunnel_type_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'ipv4_valid', None, None, ), # 1
    (2, TType.BYTE, 'vxlan_gpe_valid', None, None, ), # 2
    (3, TType.BYTE, 'int_metadata_i2e_source', None, None, ), # 3
    (4, TType.BYTE, 'tunnel_metadata_egress_tunnel_type', None, None, ), # 4
    (5, TType.BYTE, 'tunnel_metadata_egress_tunnel_type_mask', None, None, ), # 5
  )

  def __init__(self, ipv4_valid=None, vxlan_gpe_valid=None, int_metadata_i2e_source=None, tunnel_metadata_egress_tunnel_type=None, tunnel_metadata_egress_tunnel_type_mask=None,):
    self.ipv4_valid = ipv4_valid
    self.vxlan_gpe_valid = vxlan_gpe_valid
    self.int_metadata_i2e_source = int_metadata_i2e_source
    self.tunnel_metadata_egress_tunnel_type = tunnel_metadata_egress_tunnel_type
    self.tunnel_metadata_egress_tunnel_type_mask = tunnel_metadata_egress_tunnel_type_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.ipv4_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.vxlan_gpe_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.int_metadata_i2e_source = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.tunnel_metadata_egress_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.tunnel_metadata_egress_tunnel_type_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_int_outer_encap_match_spec_t')
    if self.ipv4_valid is not None:
      oprot.writeFieldBegin('ipv4_valid', TType.BYTE, 1)
      oprot.writeByte(self.ipv4_valid)
      oprot.writeFieldEnd()
    if self.vxlan_gpe_valid is not None:
      oprot.writeFieldBegin('vxlan_gpe_valid', TType.BYTE, 2)
      oprot.writeByte(self.vxlan_gpe_valid)
      oprot.writeFieldEnd()
    if self.int_metadata_i2e_source is not None:
      oprot.writeFieldBegin('int_metadata_i2e_source', TType.BYTE, 3)
      oprot.writeByte(self.int_metadata_i2e_source)
      oprot.writeFieldEnd()
    if self.tunnel_metadata_egress_tunnel_type is not None:
      oprot.writeFieldBegin('tunnel_metadata_egress_tunnel_type', TType.BYTE, 4)
      oprot.writeByte(self.tunnel_metadata_egress_tunnel_type)
      oprot.writeFieldEnd()
    if self.tunnel_metadata_egress_tunnel_type_mask is not None:
      oprot.writeFieldBegin('tunnel_metadata_egress_tunnel_type_mask', TType.BYTE, 5)
      oprot.writeByte(self.tunnel_metadata_egress_tunnel_type_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ipv4_valid is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_valid is unset!')
    if self.vxlan_gpe_valid is None:
      raise TProtocol.TProtocolException(message='Required field vxlan_gpe_valid is unset!')
    if self.int_metadata_i2e_source is None:
      raise TProtocol.TProtocolException(message='Required field int_metadata_i2e_source is unset!')
    if self.tunnel_metadata_egress_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_egress_tunnel_type is unset!')
    if self.tunnel_metadata_egress_tunnel_type_mask is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_egress_tunnel_type_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ipv4_valid)
    value = (value * 31) ^ hash(self.vxlan_gpe_valid)
    value = (value * 31) ^ hash(self.int_metadata_i2e_source)
    value = (value * 31) ^ hash(self.tunnel_metadata_egress_tunnel_type)
    value = (value * 31) ^ hash(self.tunnel_metadata_egress_tunnel_type_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv6_src_vtep_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv6_metadata_lkp_ipv6_sa
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.STRING, 'ipv6_metadata_lkp_ipv6_sa', None, None, ), # 2
  )

  def __init__(self, l3_metadata_vrf=None, ipv6_metadata_lkp_ipv6_sa=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv6_metadata_lkp_ipv6_sa = ipv6_metadata_lkp_ipv6_sa

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv6_src_vtep_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa', TType.STRING, 2)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_sa)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_vlan_decap_match_spec_t:
  """
  Attributes:
   - vlan_tag__0__valid
   - vlan_tag__1__valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'vlan_tag__0__valid', None, None, ), # 1
    (2, TType.BYTE, 'vlan_tag__1__valid', None, None, ), # 2
  )

  def __init__(self, vlan_tag__0__valid=None, vlan_tag__1__valid=None,):
    self.vlan_tag__0__valid = vlan_tag__0__valid
    self.vlan_tag__1__valid = vlan_tag__1__valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.vlan_tag__0__valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.vlan_tag__1__valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_vlan_decap_match_spec_t')
    if self.vlan_tag__0__valid is not None:
      oprot.writeFieldBegin('vlan_tag__0__valid', TType.BYTE, 1)
      oprot.writeByte(self.vlan_tag__0__valid)
      oprot.writeFieldEnd()
    if self.vlan_tag__1__valid is not None:
      oprot.writeFieldBegin('vlan_tag__1__valid', TType.BYTE, 2)
      oprot.writeByte(self.vlan_tag__1__valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.vlan_tag__0__valid is None:
      raise TProtocol.TProtocolException(message='Required field vlan_tag__0__valid is unset!')
    if self.vlan_tag__1__valid is None:
      raise TProtocol.TProtocolException(message='Required field vlan_tag__1__valid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vlan_tag__0__valid)
    value = (value * 31) ^ hash(self.vlan_tag__1__valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rid_match_spec_t:
  """
  Attributes:
   - intrinsic_metadata_egress_rid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'intrinsic_metadata_egress_rid', None, None, ), # 1
  )

  def __init__(self, intrinsic_metadata_egress_rid=None,):
    self.intrinsic_metadata_egress_rid = intrinsic_metadata_egress_rid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.intrinsic_metadata_egress_rid = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rid_match_spec_t')
    if self.intrinsic_metadata_egress_rid is not None:
      oprot.writeFieldBegin('intrinsic_metadata_egress_rid', TType.I16, 1)
      oprot.writeI16(self.intrinsic_metadata_egress_rid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.intrinsic_metadata_egress_rid is None:
      raise TProtocol.TProtocolException(message='Required field intrinsic_metadata_egress_rid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.intrinsic_metadata_egress_rid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv4_fib_lpm_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv4_metadata_lkp_ipv4_da
   - ipv4_metadata_lkp_ipv4_da_prefix_length
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.I32, 'ipv4_metadata_lkp_ipv4_da', None, None, ), # 2
    (3, TType.I16, 'ipv4_metadata_lkp_ipv4_da_prefix_length', None, None, ), # 3
  )

  def __init__(self, l3_metadata_vrf=None, ipv4_metadata_lkp_ipv4_da=None, ipv4_metadata_lkp_ipv4_da_prefix_length=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv4_metadata_lkp_ipv4_da = ipv4_metadata_lkp_ipv4_da
    self.ipv4_metadata_lkp_ipv4_da_prefix_length = ipv4_metadata_lkp_ipv4_da_prefix_length

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.ipv4_metadata_lkp_ipv4_da_prefix_length = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv4_fib_lpm_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da', TType.I32, 2)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da_prefix_length is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da_prefix_length', TType.I16, 3)
      oprot.writeI16(self.ipv4_metadata_lkp_ipv4_da_prefix_length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv4_metadata_lkp_ipv4_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da is unset!')
    if self.ipv4_metadata_lkp_ipv4_da_prefix_length is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da_prefix_length is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da_prefix_length)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_egress_port_mapping_match_spec_t:
  """
  Attributes:
   - standard_metadata_egress_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'standard_metadata_egress_port', None, None, ), # 1
  )

  def __init__(self, standard_metadata_egress_port=None,):
    self.standard_metadata_egress_port = standard_metadata_egress_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.standard_metadata_egress_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_egress_port_mapping_match_spec_t')
    if self.standard_metadata_egress_port is not None:
      oprot.writeFieldBegin('standard_metadata_egress_port', TType.I16, 1)
      oprot.writeI16(self.standard_metadata_egress_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.standard_metadata_egress_port is None:
      raise TProtocol.TProtocolException(message='Required field standard_metadata_egress_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.standard_metadata_egress_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ecmp_group_match_spec_t:
  """
  Attributes:
   - l3_metadata_nexthop_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_nexthop_index', None, None, ), # 1
  )

  def __init__(self, l3_metadata_nexthop_index=None,):
    self.l3_metadata_nexthop_index = l3_metadata_nexthop_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_nexthop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ecmp_group_match_spec_t')
    if self.l3_metadata_nexthop_index is not None:
      oprot.writeFieldBegin('l3_metadata_nexthop_index', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_nexthop_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_nexthop_index is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_nexthop_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_nexthop_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_fabric_ingress_dst_lkp_match_spec_t:
  """
  Attributes:
   - fabric_header_dstDevice
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'fabric_header_dstDevice', None, None, ), # 1
  )

  def __init__(self, fabric_header_dstDevice=None,):
    self.fabric_header_dstDevice = fabric_header_dstDevice

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.fabric_header_dstDevice = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_fabric_ingress_dst_lkp_match_spec_t')
    if self.fabric_header_dstDevice is not None:
      oprot.writeFieldBegin('fabric_header_dstDevice', TType.BYTE, 1)
      oprot.writeByte(self.fabric_header_dstDevice)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fabric_header_dstDevice is None:
      raise TProtocol.TProtocolException(message='Required field fabric_header_dstDevice is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fabric_header_dstDevice)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_compute_other_hashes_match_spec_t:
  """
  Attributes:
   - hash_metadata_hash1
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'hash_metadata_hash1', None, None, ), # 1
  )

  def __init__(self, hash_metadata_hash1=None,):
    self.hash_metadata_hash1 = hash_metadata_hash1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.hash_metadata_hash1 = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_compute_other_hashes_match_spec_t')
    if self.hash_metadata_hash1 is not None:
      oprot.writeFieldBegin('hash_metadata_hash1', TType.I16, 1)
      oprot.writeI16(self.hash_metadata_hash1)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.hash_metadata_hash1 is None:
      raise TProtocol.TProtocolException(message='Required field hash_metadata_hash1 is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hash_metadata_hash1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_egress_bd_map_match_spec_t:
  """
  Attributes:
   - egress_metadata_bd
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'egress_metadata_bd', None, None, ), # 1
  )

  def __init__(self, egress_metadata_bd=None,):
    self.egress_metadata_bd = egress_metadata_bd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.egress_metadata_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_egress_bd_map_match_spec_t')
    if self.egress_metadata_bd is not None:
      oprot.writeFieldBegin('egress_metadata_bd', TType.I16, 1)
      oprot.writeI16(self.egress_metadata_bd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.egress_metadata_bd is None:
      raise TProtocol.TProtocolException(message='Required field egress_metadata_bd is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.egress_metadata_bd)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_tunnel_src_rewrite_match_spec_t:
  """
  Attributes:
   - tunnel_metadata_tunnel_src_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'tunnel_metadata_tunnel_src_index', None, None, ), # 1
  )

  def __init__(self, tunnel_metadata_tunnel_src_index=None,):
    self.tunnel_metadata_tunnel_src_index = tunnel_metadata_tunnel_src_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.tunnel_metadata_tunnel_src_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_tunnel_src_rewrite_match_spec_t')
    if self.tunnel_metadata_tunnel_src_index is not None:
      oprot.writeFieldBegin('tunnel_metadata_tunnel_src_index', TType.I16, 1)
      oprot.writeI16(self.tunnel_metadata_tunnel_src_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tunnel_metadata_tunnel_src_index is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_tunnel_src_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tunnel_metadata_tunnel_src_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv4_fib_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv4_metadata_lkp_ipv4_da
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.I32, 'ipv4_metadata_lkp_ipv4_da', None, None, ), # 2
  )

  def __init__(self, l3_metadata_vrf=None, ipv4_metadata_lkp_ipv4_da=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv4_metadata_lkp_ipv4_da = ipv4_metadata_lkp_ipv4_da

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv4_fib_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da', TType.I32, 2)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv4_metadata_lkp_ipv4_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ingress_port_mapping_match_spec_t:
  """
  Attributes:
   - standard_metadata_ingress_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'standard_metadata_ingress_port', None, None, ), # 1
  )

  def __init__(self, standard_metadata_ingress_port=None,):
    self.standard_metadata_ingress_port = standard_metadata_ingress_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.standard_metadata_ingress_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ingress_port_mapping_match_spec_t')
    if self.standard_metadata_ingress_port is not None:
      oprot.writeFieldBegin('standard_metadata_ingress_port', TType.I16, 1)
      oprot.writeI16(self.standard_metadata_ingress_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.standard_metadata_ingress_port is None:
      raise TProtocol.TProtocolException(message='Required field standard_metadata_ingress_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.standard_metadata_ingress_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_compute_non_ip_hashes_match_spec_t:
  """
  Attributes:
   - ingress_metadata_drop_flag
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'ingress_metadata_drop_flag', None, None, ), # 1
  )

  def __init__(self, ingress_metadata_drop_flag=None,):
    self.ingress_metadata_drop_flag = ingress_metadata_drop_flag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.ingress_metadata_drop_flag = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_compute_non_ip_hashes_match_spec_t')
    if self.ingress_metadata_drop_flag is not None:
      oprot.writeFieldBegin('ingress_metadata_drop_flag', TType.BYTE, 1)
      oprot.writeByte(self.ingress_metadata_drop_flag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_drop_flag is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_drop_flag is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_drop_flag)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv4_src_vtep_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv4_metadata_lkp_ipv4_sa
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.I32, 'ipv4_metadata_lkp_ipv4_sa', None, None, ), # 2
  )

  def __init__(self, l3_metadata_vrf=None, ipv4_metadata_lkp_ipv4_sa=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv4_metadata_lkp_ipv4_sa = ipv4_metadata_lkp_ipv4_sa

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv4_src_vtep_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa', TType.I32, 2)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv6_dest_vtep_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv6_metadata_lkp_ipv6_da
   - tunnel_metadata_ingress_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.STRING, 'ipv6_metadata_lkp_ipv6_da', None, None, ), # 2
    (3, TType.BYTE, 'tunnel_metadata_ingress_tunnel_type', None, None, ), # 3
  )

  def __init__(self, l3_metadata_vrf=None, ipv6_metadata_lkp_ipv6_da=None, tunnel_metadata_ingress_tunnel_type=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv6_metadata_lkp_ipv6_da = ipv6_metadata_lkp_ipv6_da
    self.tunnel_metadata_ingress_tunnel_type = tunnel_metadata_ingress_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_da = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.tunnel_metadata_ingress_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv6_dest_vtep_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_da is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_da', TType.STRING, 2)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_da)
      oprot.writeFieldEnd()
    if self.tunnel_metadata_ingress_tunnel_type is not None:
      oprot.writeFieldBegin('tunnel_metadata_ingress_tunnel_type', TType.BYTE, 3)
      oprot.writeByte(self.tunnel_metadata_ingress_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv6_metadata_lkp_ipv6_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_da is unset!')
    if self.tunnel_metadata_ingress_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_ingress_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_da)
    value = (value * 31) ^ hash(self.tunnel_metadata_ingress_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_egress_vlan_xlate_match_spec_t:
  """
  Attributes:
   - standard_metadata_egress_port
   - egress_metadata_bd
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'standard_metadata_egress_port', None, None, ), # 1
    (2, TType.I16, 'egress_metadata_bd', None, None, ), # 2
  )

  def __init__(self, standard_metadata_egress_port=None, egress_metadata_bd=None,):
    self.standard_metadata_egress_port = standard_metadata_egress_port
    self.egress_metadata_bd = egress_metadata_bd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.standard_metadata_egress_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.egress_metadata_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_egress_vlan_xlate_match_spec_t')
    if self.standard_metadata_egress_port is not None:
      oprot.writeFieldBegin('standard_metadata_egress_port', TType.I16, 1)
      oprot.writeI16(self.standard_metadata_egress_port)
      oprot.writeFieldEnd()
    if self.egress_metadata_bd is not None:
      oprot.writeFieldBegin('egress_metadata_bd', TType.I16, 2)
      oprot.writeI16(self.egress_metadata_bd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.standard_metadata_egress_port is None:
      raise TProtocol.TProtocolException(message='Required field standard_metadata_egress_port is unset!')
    if self.egress_metadata_bd is None:
      raise TProtocol.TProtocolException(message='Required field egress_metadata_bd is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.standard_metadata_egress_port)
    value = (value * 31) ^ hash(self.egress_metadata_bd)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_validate_mpls_packet_match_spec_t:
  """
  Attributes:
   - mpls_0__label
   - mpls_0__label_mask
   - mpls_0__bos
   - mpls_0__bos_mask
   - mpls_0__valid
   - mpls_1__label
   - mpls_1__label_mask
   - mpls_1__bos
   - mpls_1__bos_mask
   - mpls_1__valid
   - mpls_2__label
   - mpls_2__label_mask
   - mpls_2__bos
   - mpls_2__bos_mask
   - mpls_2__valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'mpls_0__label', None, None, ), # 1
    (2, TType.I32, 'mpls_0__label_mask', None, None, ), # 2
    (3, TType.BYTE, 'mpls_0__bos', None, None, ), # 3
    (4, TType.BYTE, 'mpls_0__bos_mask', None, None, ), # 4
    (5, TType.BYTE, 'mpls_0__valid', None, None, ), # 5
    (6, TType.I32, 'mpls_1__label', None, None, ), # 6
    (7, TType.I32, 'mpls_1__label_mask', None, None, ), # 7
    (8, TType.BYTE, 'mpls_1__bos', None, None, ), # 8
    (9, TType.BYTE, 'mpls_1__bos_mask', None, None, ), # 9
    (10, TType.BYTE, 'mpls_1__valid', None, None, ), # 10
    (11, TType.I32, 'mpls_2__label', None, None, ), # 11
    (12, TType.I32, 'mpls_2__label_mask', None, None, ), # 12
    (13, TType.BYTE, 'mpls_2__bos', None, None, ), # 13
    (14, TType.BYTE, 'mpls_2__bos_mask', None, None, ), # 14
    (15, TType.BYTE, 'mpls_2__valid', None, None, ), # 15
  )

  def __init__(self, mpls_0__label=None, mpls_0__label_mask=None, mpls_0__bos=None, mpls_0__bos_mask=None, mpls_0__valid=None, mpls_1__label=None, mpls_1__label_mask=None, mpls_1__bos=None, mpls_1__bos_mask=None, mpls_1__valid=None, mpls_2__label=None, mpls_2__label_mask=None, mpls_2__bos=None, mpls_2__bos_mask=None, mpls_2__valid=None,):
    self.mpls_0__label = mpls_0__label
    self.mpls_0__label_mask = mpls_0__label_mask
    self.mpls_0__bos = mpls_0__bos
    self.mpls_0__bos_mask = mpls_0__bos_mask
    self.mpls_0__valid = mpls_0__valid
    self.mpls_1__label = mpls_1__label
    self.mpls_1__label_mask = mpls_1__label_mask
    self.mpls_1__bos = mpls_1__bos
    self.mpls_1__bos_mask = mpls_1__bos_mask
    self.mpls_1__valid = mpls_1__valid
    self.mpls_2__label = mpls_2__label
    self.mpls_2__label_mask = mpls_2__label_mask
    self.mpls_2__bos = mpls_2__bos
    self.mpls_2__bos_mask = mpls_2__bos_mask
    self.mpls_2__valid = mpls_2__valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.mpls_0__label = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.mpls_0__label_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.mpls_0__bos = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.mpls_0__bos_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.mpls_0__valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.mpls_1__label = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.mpls_1__label_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.mpls_1__bos = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.mpls_1__bos_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BYTE:
          self.mpls_1__valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.mpls_2__label = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.mpls_2__label_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BYTE:
          self.mpls_2__bos = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BYTE:
          self.mpls_2__bos_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BYTE:
          self.mpls_2__valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_validate_mpls_packet_match_spec_t')
    if self.mpls_0__label is not None:
      oprot.writeFieldBegin('mpls_0__label', TType.I32, 1)
      oprot.writeI32(self.mpls_0__label)
      oprot.writeFieldEnd()
    if self.mpls_0__label_mask is not None:
      oprot.writeFieldBegin('mpls_0__label_mask', TType.I32, 2)
      oprot.writeI32(self.mpls_0__label_mask)
      oprot.writeFieldEnd()
    if self.mpls_0__bos is not None:
      oprot.writeFieldBegin('mpls_0__bos', TType.BYTE, 3)
      oprot.writeByte(self.mpls_0__bos)
      oprot.writeFieldEnd()
    if self.mpls_0__bos_mask is not None:
      oprot.writeFieldBegin('mpls_0__bos_mask', TType.BYTE, 4)
      oprot.writeByte(self.mpls_0__bos_mask)
      oprot.writeFieldEnd()
    if self.mpls_0__valid is not None:
      oprot.writeFieldBegin('mpls_0__valid', TType.BYTE, 5)
      oprot.writeByte(self.mpls_0__valid)
      oprot.writeFieldEnd()
    if self.mpls_1__label is not None:
      oprot.writeFieldBegin('mpls_1__label', TType.I32, 6)
      oprot.writeI32(self.mpls_1__label)
      oprot.writeFieldEnd()
    if self.mpls_1__label_mask is not None:
      oprot.writeFieldBegin('mpls_1__label_mask', TType.I32, 7)
      oprot.writeI32(self.mpls_1__label_mask)
      oprot.writeFieldEnd()
    if self.mpls_1__bos is not None:
      oprot.writeFieldBegin('mpls_1__bos', TType.BYTE, 8)
      oprot.writeByte(self.mpls_1__bos)
      oprot.writeFieldEnd()
    if self.mpls_1__bos_mask is not None:
      oprot.writeFieldBegin('mpls_1__bos_mask', TType.BYTE, 9)
      oprot.writeByte(self.mpls_1__bos_mask)
      oprot.writeFieldEnd()
    if self.mpls_1__valid is not None:
      oprot.writeFieldBegin('mpls_1__valid', TType.BYTE, 10)
      oprot.writeByte(self.mpls_1__valid)
      oprot.writeFieldEnd()
    if self.mpls_2__label is not None:
      oprot.writeFieldBegin('mpls_2__label', TType.I32, 11)
      oprot.writeI32(self.mpls_2__label)
      oprot.writeFieldEnd()
    if self.mpls_2__label_mask is not None:
      oprot.writeFieldBegin('mpls_2__label_mask', TType.I32, 12)
      oprot.writeI32(self.mpls_2__label_mask)
      oprot.writeFieldEnd()
    if self.mpls_2__bos is not None:
      oprot.writeFieldBegin('mpls_2__bos', TType.BYTE, 13)
      oprot.writeByte(self.mpls_2__bos)
      oprot.writeFieldEnd()
    if self.mpls_2__bos_mask is not None:
      oprot.writeFieldBegin('mpls_2__bos_mask', TType.BYTE, 14)
      oprot.writeByte(self.mpls_2__bos_mask)
      oprot.writeFieldEnd()
    if self.mpls_2__valid is not None:
      oprot.writeFieldBegin('mpls_2__valid', TType.BYTE, 15)
      oprot.writeByte(self.mpls_2__valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.mpls_0__label is None:
      raise TProtocol.TProtocolException(message='Required field mpls_0__label is unset!')
    if self.mpls_0__label_mask is None:
      raise TProtocol.TProtocolException(message='Required field mpls_0__label_mask is unset!')
    if self.mpls_0__bos is None:
      raise TProtocol.TProtocolException(message='Required field mpls_0__bos is unset!')
    if self.mpls_0__bos_mask is None:
      raise TProtocol.TProtocolException(message='Required field mpls_0__bos_mask is unset!')
    if self.mpls_0__valid is None:
      raise TProtocol.TProtocolException(message='Required field mpls_0__valid is unset!')
    if self.mpls_1__label is None:
      raise TProtocol.TProtocolException(message='Required field mpls_1__label is unset!')
    if self.mpls_1__label_mask is None:
      raise TProtocol.TProtocolException(message='Required field mpls_1__label_mask is unset!')
    if self.mpls_1__bos is None:
      raise TProtocol.TProtocolException(message='Required field mpls_1__bos is unset!')
    if self.mpls_1__bos_mask is None:
      raise TProtocol.TProtocolException(message='Required field mpls_1__bos_mask is unset!')
    if self.mpls_1__valid is None:
      raise TProtocol.TProtocolException(message='Required field mpls_1__valid is unset!')
    if self.mpls_2__label is None:
      raise TProtocol.TProtocolException(message='Required field mpls_2__label is unset!')
    if self.mpls_2__label_mask is None:
      raise TProtocol.TProtocolException(message='Required field mpls_2__label_mask is unset!')
    if self.mpls_2__bos is None:
      raise TProtocol.TProtocolException(message='Required field mpls_2__bos is unset!')
    if self.mpls_2__bos_mask is None:
      raise TProtocol.TProtocolException(message='Required field mpls_2__bos_mask is unset!')
    if self.mpls_2__valid is None:
      raise TProtocol.TProtocolException(message='Required field mpls_2__valid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mpls_0__label)
    value = (value * 31) ^ hash(self.mpls_0__label_mask)
    value = (value * 31) ^ hash(self.mpls_0__bos)
    value = (value * 31) ^ hash(self.mpls_0__bos_mask)
    value = (value * 31) ^ hash(self.mpls_0__valid)
    value = (value * 31) ^ hash(self.mpls_1__label)
    value = (value * 31) ^ hash(self.mpls_1__label_mask)
    value = (value * 31) ^ hash(self.mpls_1__bos)
    value = (value * 31) ^ hash(self.mpls_1__bos_mask)
    value = (value * 31) ^ hash(self.mpls_1__valid)
    value = (value * 31) ^ hash(self.mpls_2__label)
    value = (value * 31) ^ hash(self.mpls_2__label_mask)
    value = (value * 31) ^ hash(self.mpls_2__bos)
    value = (value * 31) ^ hash(self.mpls_2__bos_mask)
    value = (value * 31) ^ hash(self.mpls_2__valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv6_fib_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv6_metadata_lkp_ipv6_da
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.STRING, 'ipv6_metadata_lkp_ipv6_da', None, None, ), # 2
  )

  def __init__(self, l3_metadata_vrf=None, ipv6_metadata_lkp_ipv6_da=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv6_metadata_lkp_ipv6_da = ipv6_metadata_lkp_ipv6_da

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_da = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv6_fib_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_da is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_da', TType.STRING, 2)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_da)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv6_metadata_lkp_ipv6_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_da is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_da)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_validate_outer_ipv6_packet_match_spec_t:
  """
  Attributes:
   - ipv6_version
   - ipv6_version_mask
   - l3_metadata_lkp_ip_ttl
   - l3_metadata_lkp_ip_ttl_mask
   - ipv6_metadata_lkp_ipv6_sa
   - ipv6_metadata_lkp_ipv6_sa_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'ipv6_version', None, None, ), # 1
    (2, TType.BYTE, 'ipv6_version_mask', None, None, ), # 2
    (3, TType.BYTE, 'l3_metadata_lkp_ip_ttl', None, None, ), # 3
    (4, TType.BYTE, 'l3_metadata_lkp_ip_ttl_mask', None, None, ), # 4
    (5, TType.STRING, 'ipv6_metadata_lkp_ipv6_sa', None, None, ), # 5
    (6, TType.STRING, 'ipv6_metadata_lkp_ipv6_sa_mask', None, None, ), # 6
  )

  def __init__(self, ipv6_version=None, ipv6_version_mask=None, l3_metadata_lkp_ip_ttl=None, l3_metadata_lkp_ip_ttl_mask=None, ipv6_metadata_lkp_ipv6_sa=None, ipv6_metadata_lkp_ipv6_sa_mask=None,):
    self.ipv6_version = ipv6_version
    self.ipv6_version_mask = ipv6_version_mask
    self.l3_metadata_lkp_ip_ttl = l3_metadata_lkp_ip_ttl
    self.l3_metadata_lkp_ip_ttl_mask = l3_metadata_lkp_ip_ttl_mask
    self.ipv6_metadata_lkp_ipv6_sa = ipv6_metadata_lkp_ipv6_sa
    self.ipv6_metadata_lkp_ipv6_sa_mask = ipv6_metadata_lkp_ipv6_sa_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.ipv6_version = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.ipv6_version_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_sa_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_validate_outer_ipv6_packet_match_spec_t')
    if self.ipv6_version is not None:
      oprot.writeFieldBegin('ipv6_version', TType.BYTE, 1)
      oprot.writeByte(self.ipv6_version)
      oprot.writeFieldEnd()
    if self.ipv6_version_mask is not None:
      oprot.writeFieldBegin('ipv6_version_mask', TType.BYTE, 2)
      oprot.writeByte(self.ipv6_version_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl', TType.BYTE, 3)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl_mask', TType.BYTE, 4)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl_mask)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa', TType.STRING, 5)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_sa)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa_mask is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa_mask', TType.STRING, 6)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_sa_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ipv6_version is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_version is unset!')
    if self.ipv6_version_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_version_mask is unset!')
    if self.l3_metadata_lkp_ip_ttl is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl is unset!')
    if self.l3_metadata_lkp_ip_ttl_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl_mask is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ipv6_version)
    value = (value * 31) ^ hash(self.ipv6_version_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl_mask)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_tunnel_encap_process_outer_match_spec_t:
  """
  Attributes:
   - tunnel_metadata_egress_tunnel_type
   - tunnel_metadata_egress_header_count
   - multicast_metadata_replica
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'tunnel_metadata_egress_tunnel_type', None, None, ), # 1
    (2, TType.BYTE, 'tunnel_metadata_egress_header_count', None, None, ), # 2
    (3, TType.BYTE, 'multicast_metadata_replica', None, None, ), # 3
  )

  def __init__(self, tunnel_metadata_egress_tunnel_type=None, tunnel_metadata_egress_header_count=None, multicast_metadata_replica=None,):
    self.tunnel_metadata_egress_tunnel_type = tunnel_metadata_egress_tunnel_type
    self.tunnel_metadata_egress_header_count = tunnel_metadata_egress_header_count
    self.multicast_metadata_replica = multicast_metadata_replica

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.tunnel_metadata_egress_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.tunnel_metadata_egress_header_count = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.multicast_metadata_replica = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_tunnel_encap_process_outer_match_spec_t')
    if self.tunnel_metadata_egress_tunnel_type is not None:
      oprot.writeFieldBegin('tunnel_metadata_egress_tunnel_type', TType.BYTE, 1)
      oprot.writeByte(self.tunnel_metadata_egress_tunnel_type)
      oprot.writeFieldEnd()
    if self.tunnel_metadata_egress_header_count is not None:
      oprot.writeFieldBegin('tunnel_metadata_egress_header_count', TType.BYTE, 2)
      oprot.writeByte(self.tunnel_metadata_egress_header_count)
      oprot.writeFieldEnd()
    if self.multicast_metadata_replica is not None:
      oprot.writeFieldBegin('multicast_metadata_replica', TType.BYTE, 3)
      oprot.writeByte(self.multicast_metadata_replica)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tunnel_metadata_egress_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_egress_tunnel_type is unset!')
    if self.tunnel_metadata_egress_header_count is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_egress_header_count is unset!')
    if self.multicast_metadata_replica is None:
      raise TProtocol.TProtocolException(message='Required field multicast_metadata_replica is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tunnel_metadata_egress_tunnel_type)
    value = (value * 31) ^ hash(self.tunnel_metadata_egress_header_count)
    value = (value * 31) ^ hash(self.multicast_metadata_replica)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_storm_control_match_spec_t:
  """
  Attributes:
   - ingress_metadata_ifindex
   - l2_metadata_lkp_pkt_type
   - l2_metadata_lkp_pkt_type_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'ingress_metadata_ifindex', None, None, ), # 1
    (2, TType.BYTE, 'l2_metadata_lkp_pkt_type', None, None, ), # 2
    (3, TType.BYTE, 'l2_metadata_lkp_pkt_type_mask', None, None, ), # 3
  )

  def __init__(self, ingress_metadata_ifindex=None, l2_metadata_lkp_pkt_type=None, l2_metadata_lkp_pkt_type_mask=None,):
    self.ingress_metadata_ifindex = ingress_metadata_ifindex
    self.l2_metadata_lkp_pkt_type = l2_metadata_lkp_pkt_type
    self.l2_metadata_lkp_pkt_type_mask = l2_metadata_lkp_pkt_type_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.ingress_metadata_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.l2_metadata_lkp_pkt_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.l2_metadata_lkp_pkt_type_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_storm_control_match_spec_t')
    if self.ingress_metadata_ifindex is not None:
      oprot.writeFieldBegin('ingress_metadata_ifindex', TType.I16, 1)
      oprot.writeI16(self.ingress_metadata_ifindex)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_pkt_type is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_pkt_type', TType.BYTE, 2)
      oprot.writeByte(self.l2_metadata_lkp_pkt_type)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_pkt_type_mask is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_pkt_type_mask', TType.BYTE, 3)
      oprot.writeByte(self.l2_metadata_lkp_pkt_type_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_ifindex is unset!')
    if self.l2_metadata_lkp_pkt_type is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_pkt_type is unset!')
    if self.l2_metadata_lkp_pkt_type_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_pkt_type_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_ifindex)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_pkt_type)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_pkt_type_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_tunnel_decap_process_inner_match_spec_t:
  """
  Attributes:
   - inner_tcp_valid
   - inner_udp_valid
   - inner_icmp_valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'inner_tcp_valid', None, None, ), # 1
    (2, TType.BYTE, 'inner_udp_valid', None, None, ), # 2
    (3, TType.BYTE, 'inner_icmp_valid', None, None, ), # 3
  )

  def __init__(self, inner_tcp_valid=None, inner_udp_valid=None, inner_icmp_valid=None,):
    self.inner_tcp_valid = inner_tcp_valid
    self.inner_udp_valid = inner_udp_valid
    self.inner_icmp_valid = inner_icmp_valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.inner_tcp_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inner_udp_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.inner_icmp_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_tunnel_decap_process_inner_match_spec_t')
    if self.inner_tcp_valid is not None:
      oprot.writeFieldBegin('inner_tcp_valid', TType.BYTE, 1)
      oprot.writeByte(self.inner_tcp_valid)
      oprot.writeFieldEnd()
    if self.inner_udp_valid is not None:
      oprot.writeFieldBegin('inner_udp_valid', TType.BYTE, 2)
      oprot.writeByte(self.inner_udp_valid)
      oprot.writeFieldEnd()
    if self.inner_icmp_valid is not None:
      oprot.writeFieldBegin('inner_icmp_valid', TType.BYTE, 3)
      oprot.writeByte(self.inner_icmp_valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.inner_tcp_valid is None:
      raise TProtocol.TProtocolException(message='Required field inner_tcp_valid is unset!')
    if self.inner_udp_valid is None:
      raise TProtocol.TProtocolException(message='Required field inner_udp_valid is unset!')
    if self.inner_icmp_valid is None:
      raise TProtocol.TProtocolException(message='Required field inner_icmp_valid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inner_tcp_valid)
    value = (value * 31) ^ hash(self.inner_udp_valid)
    value = (value * 31) ^ hash(self.inner_icmp_valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv6_urpf_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv6_metadata_lkp_ipv6_sa
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.STRING, 'ipv6_metadata_lkp_ipv6_sa', None, None, ), # 2
  )

  def __init__(self, l3_metadata_vrf=None, ipv6_metadata_lkp_ipv6_sa=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv6_metadata_lkp_ipv6_sa = ipv6_metadata_lkp_ipv6_sa

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv6_urpf_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa', TType.STRING, 2)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_sa)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_dmac_match_spec_t:
  """
  Attributes:
   - ingress_metadata_bd
   - l2_metadata_lkp_mac_da
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'ingress_metadata_bd', None, None, ), # 1
    (2, TType.STRING, 'l2_metadata_lkp_mac_da', None, None, ), # 2
  )

  def __init__(self, ingress_metadata_bd=None, l2_metadata_lkp_mac_da=None,):
    self.ingress_metadata_bd = ingress_metadata_bd
    self.l2_metadata_lkp_mac_da = l2_metadata_lkp_mac_da

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.ingress_metadata_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_da = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_dmac_match_spec_t')
    if self.ingress_metadata_bd is not None:
      oprot.writeFieldBegin('ingress_metadata_bd', TType.I16, 1)
      oprot.writeI16(self.ingress_metadata_bd)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_da is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_da', TType.STRING, 2)
      oprot.writeString(self.l2_metadata_lkp_mac_da)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_bd is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_bd is unset!')
    if self.l2_metadata_lkp_mac_da is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_da is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_bd)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_da)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_urpf_bd_match_spec_t:
  """
  Attributes:
   - l3_metadata_urpf_bd_group
   - ingress_metadata_bd
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_urpf_bd_group', None, None, ), # 1
    (2, TType.I16, 'ingress_metadata_bd', None, None, ), # 2
  )

  def __init__(self, l3_metadata_urpf_bd_group=None, ingress_metadata_bd=None,):
    self.l3_metadata_urpf_bd_group = l3_metadata_urpf_bd_group
    self.ingress_metadata_bd = ingress_metadata_bd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_urpf_bd_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.ingress_metadata_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_urpf_bd_match_spec_t')
    if self.l3_metadata_urpf_bd_group is not None:
      oprot.writeFieldBegin('l3_metadata_urpf_bd_group', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_urpf_bd_group)
      oprot.writeFieldEnd()
    if self.ingress_metadata_bd is not None:
      oprot.writeFieldBegin('ingress_metadata_bd', TType.I16, 2)
      oprot.writeI16(self.ingress_metadata_bd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_urpf_bd_group is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_urpf_bd_group is unset!')
    if self.ingress_metadata_bd is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_bd is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_urpf_bd_group)
    value = (value * 31) ^ hash(self.ingress_metadata_bd)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv6_racl_match_spec_t:
  """
  Attributes:
   - acl_metadata_bd_label
   - acl_metadata_bd_label_mask
   - ipv6_metadata_lkp_ipv6_sa
   - ipv6_metadata_lkp_ipv6_sa_mask
   - ipv6_metadata_lkp_ipv6_da
   - ipv6_metadata_lkp_ipv6_da_mask
   - l3_metadata_lkp_ip_proto
   - l3_metadata_lkp_ip_proto_mask
   - l3_metadata_lkp_l4_sport
   - l3_metadata_lkp_l4_sport_mask
   - l3_metadata_lkp_l4_dport
   - l3_metadata_lkp_l4_dport_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'acl_metadata_bd_label', None, None, ), # 1
    (2, TType.I16, 'acl_metadata_bd_label_mask', None, None, ), # 2
    (3, TType.STRING, 'ipv6_metadata_lkp_ipv6_sa', None, None, ), # 3
    (4, TType.STRING, 'ipv6_metadata_lkp_ipv6_sa_mask', None, None, ), # 4
    (5, TType.STRING, 'ipv6_metadata_lkp_ipv6_da', None, None, ), # 5
    (6, TType.STRING, 'ipv6_metadata_lkp_ipv6_da_mask', None, None, ), # 6
    (7, TType.BYTE, 'l3_metadata_lkp_ip_proto', None, None, ), # 7
    (8, TType.BYTE, 'l3_metadata_lkp_ip_proto_mask', None, None, ), # 8
    (9, TType.I16, 'l3_metadata_lkp_l4_sport', None, None, ), # 9
    (10, TType.I16, 'l3_metadata_lkp_l4_sport_mask', None, None, ), # 10
    (11, TType.I16, 'l3_metadata_lkp_l4_dport', None, None, ), # 11
    (12, TType.I16, 'l3_metadata_lkp_l4_dport_mask', None, None, ), # 12
  )

  def __init__(self, acl_metadata_bd_label=None, acl_metadata_bd_label_mask=None, ipv6_metadata_lkp_ipv6_sa=None, ipv6_metadata_lkp_ipv6_sa_mask=None, ipv6_metadata_lkp_ipv6_da=None, ipv6_metadata_lkp_ipv6_da_mask=None, l3_metadata_lkp_ip_proto=None, l3_metadata_lkp_ip_proto_mask=None, l3_metadata_lkp_l4_sport=None, l3_metadata_lkp_l4_sport_mask=None, l3_metadata_lkp_l4_dport=None, l3_metadata_lkp_l4_dport_mask=None,):
    self.acl_metadata_bd_label = acl_metadata_bd_label
    self.acl_metadata_bd_label_mask = acl_metadata_bd_label_mask
    self.ipv6_metadata_lkp_ipv6_sa = ipv6_metadata_lkp_ipv6_sa
    self.ipv6_metadata_lkp_ipv6_sa_mask = ipv6_metadata_lkp_ipv6_sa_mask
    self.ipv6_metadata_lkp_ipv6_da = ipv6_metadata_lkp_ipv6_da
    self.ipv6_metadata_lkp_ipv6_da_mask = ipv6_metadata_lkp_ipv6_da_mask
    self.l3_metadata_lkp_ip_proto = l3_metadata_lkp_ip_proto
    self.l3_metadata_lkp_ip_proto_mask = l3_metadata_lkp_ip_proto_mask
    self.l3_metadata_lkp_l4_sport = l3_metadata_lkp_l4_sport
    self.l3_metadata_lkp_l4_sport_mask = l3_metadata_lkp_l4_sport_mask
    self.l3_metadata_lkp_l4_dport = l3_metadata_lkp_l4_dport
    self.l3_metadata_lkp_l4_dport_mask = l3_metadata_lkp_l4_dport_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.acl_metadata_bd_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.acl_metadata_bd_label_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_sa_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_da = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_da_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_sport = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_sport_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_dport = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_dport_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv6_racl_match_spec_t')
    if self.acl_metadata_bd_label is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label', TType.I16, 1)
      oprot.writeI16(self.acl_metadata_bd_label)
      oprot.writeFieldEnd()
    if self.acl_metadata_bd_label_mask is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label_mask', TType.I16, 2)
      oprot.writeI16(self.acl_metadata_bd_label_mask)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa', TType.STRING, 3)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_sa)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa_mask is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa_mask', TType.STRING, 4)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_sa_mask)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_da is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_da', TType.STRING, 5)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_da)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_da_mask is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_da_mask', TType.STRING, 6)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_da_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto', TType.BYTE, 7)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto_mask', TType.BYTE, 8)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_sport is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_sport', TType.I16, 9)
      oprot.writeI16(self.l3_metadata_lkp_l4_sport)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_sport_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_sport_mask', TType.I16, 10)
      oprot.writeI16(self.l3_metadata_lkp_l4_sport_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_dport is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_dport', TType.I16, 11)
      oprot.writeI16(self.l3_metadata_lkp_l4_dport)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_dport_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_dport_mask', TType.I16, 12)
      oprot.writeI16(self.l3_metadata_lkp_l4_dport_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.acl_metadata_bd_label is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label is unset!')
    if self.acl_metadata_bd_label_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label_mask is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa_mask is unset!')
    if self.ipv6_metadata_lkp_ipv6_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_da is unset!')
    if self.ipv6_metadata_lkp_ipv6_da_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_da_mask is unset!')
    if self.l3_metadata_lkp_ip_proto is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto is unset!')
    if self.l3_metadata_lkp_ip_proto_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto_mask is unset!')
    if self.l3_metadata_lkp_l4_sport is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_sport is unset!')
    if self.l3_metadata_lkp_l4_sport_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_sport_mask is unset!')
    if self.l3_metadata_lkp_l4_dport is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_dport is unset!')
    if self.l3_metadata_lkp_l4_dport_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_dport_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.acl_metadata_bd_label)
    value = (value * 31) ^ hash(self.acl_metadata_bd_label_mask)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa_mask)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_da)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_da_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_sport)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_sport_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_dport)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_dport_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_int_inst_0003_match_spec_t:
  """
  Attributes:
   - int_header_instruction_mask_0003
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'int_header_instruction_mask_0003', None, None, ), # 1
  )

  def __init__(self, int_header_instruction_mask_0003=None,):
    self.int_header_instruction_mask_0003 = int_header_instruction_mask_0003

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_0003 = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_int_inst_0003_match_spec_t')
    if self.int_header_instruction_mask_0003 is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_0003', TType.BYTE, 1)
      oprot.writeByte(self.int_header_instruction_mask_0003)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.int_header_instruction_mask_0003 is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_0003 is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.int_header_instruction_mask_0003)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_compute_ipv4_hashes_match_spec_t:
  """
  Attributes:
   - ingress_metadata_drop_flag
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'ingress_metadata_drop_flag', None, None, ), # 1
  )

  def __init__(self, ingress_metadata_drop_flag=None,):
    self.ingress_metadata_drop_flag = ingress_metadata_drop_flag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.ingress_metadata_drop_flag = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_compute_ipv4_hashes_match_spec_t')
    if self.ingress_metadata_drop_flag is not None:
      oprot.writeFieldBegin('ingress_metadata_drop_flag', TType.BYTE, 1)
      oprot.writeByte(self.ingress_metadata_drop_flag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_drop_flag is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_drop_flag is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_drop_flag)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_nexthop_match_spec_t:
  """
  Attributes:
   - l3_metadata_nexthop_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_nexthop_index', None, None, ), # 1
  )

  def __init__(self, l3_metadata_nexthop_index=None,):
    self.l3_metadata_nexthop_index = l3_metadata_nexthop_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_nexthop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_nexthop_match_spec_t')
    if self.l3_metadata_nexthop_index is not None:
      oprot.writeFieldBegin('l3_metadata_nexthop_index', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_nexthop_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_nexthop_index is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_nexthop_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_nexthop_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_validate_outer_ipv4_packet_match_spec_t:
  """
  Attributes:
   - ipv4_version
   - ipv4_version_mask
   - l3_metadata_lkp_ip_ttl
   - l3_metadata_lkp_ip_ttl_mask
   - ipv4_metadata_lkp_ipv4_sa
   - ipv4_metadata_lkp_ipv4_sa_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'ipv4_version', None, None, ), # 1
    (2, TType.BYTE, 'ipv4_version_mask', None, None, ), # 2
    (3, TType.BYTE, 'l3_metadata_lkp_ip_ttl', None, None, ), # 3
    (4, TType.BYTE, 'l3_metadata_lkp_ip_ttl_mask', None, None, ), # 4
    (5, TType.I32, 'ipv4_metadata_lkp_ipv4_sa', None, None, ), # 5
    (6, TType.I32, 'ipv4_metadata_lkp_ipv4_sa_mask', None, None, ), # 6
  )

  def __init__(self, ipv4_version=None, ipv4_version_mask=None, l3_metadata_lkp_ip_ttl=None, l3_metadata_lkp_ip_ttl_mask=None, ipv4_metadata_lkp_ipv4_sa=None, ipv4_metadata_lkp_ipv4_sa_mask=None,):
    self.ipv4_version = ipv4_version
    self.ipv4_version_mask = ipv4_version_mask
    self.l3_metadata_lkp_ip_ttl = l3_metadata_lkp_ip_ttl
    self.l3_metadata_lkp_ip_ttl_mask = l3_metadata_lkp_ip_ttl_mask
    self.ipv4_metadata_lkp_ipv4_sa = ipv4_metadata_lkp_ipv4_sa
    self.ipv4_metadata_lkp_ipv4_sa_mask = ipv4_metadata_lkp_ipv4_sa_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.ipv4_version = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.ipv4_version_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_validate_outer_ipv4_packet_match_spec_t')
    if self.ipv4_version is not None:
      oprot.writeFieldBegin('ipv4_version', TType.BYTE, 1)
      oprot.writeByte(self.ipv4_version)
      oprot.writeFieldEnd()
    if self.ipv4_version_mask is not None:
      oprot.writeFieldBegin('ipv4_version_mask', TType.BYTE, 2)
      oprot.writeByte(self.ipv4_version_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl', TType.BYTE, 3)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl_mask', TType.BYTE, 4)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa', TType.I32, 5)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa_mask', TType.I32, 6)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ipv4_version is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_version is unset!')
    if self.ipv4_version_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_version_mask is unset!')
    if self.l3_metadata_lkp_ip_ttl is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl is unset!')
    if self.l3_metadata_lkp_ip_ttl_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl_mask is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ipv4_version)
    value = (value * 31) ^ hash(self.ipv4_version_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_tunnel_rewrite_match_spec_t:
  """
  Attributes:
   - tunnel_metadata_tunnel_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'tunnel_metadata_tunnel_index', None, None, ), # 1
  )

  def __init__(self, tunnel_metadata_tunnel_index=None,):
    self.tunnel_metadata_tunnel_index = tunnel_metadata_tunnel_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.tunnel_metadata_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_tunnel_rewrite_match_spec_t')
    if self.tunnel_metadata_tunnel_index is not None:
      oprot.writeFieldBegin('tunnel_metadata_tunnel_index', TType.I16, 1)
      oprot.writeI16(self.tunnel_metadata_tunnel_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tunnel_metadata_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_tunnel_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tunnel_metadata_tunnel_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_tunneled_packet_over_fabric_match_spec_t:
  """
  Attributes:
   - tunnel_metadata_ingress_tunnel_type
   - inner_ipv4_valid
   - inner_ipv6_valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'tunnel_metadata_ingress_tunnel_type', None, None, ), # 1
    (2, TType.BYTE, 'inner_ipv4_valid', None, None, ), # 2
    (3, TType.BYTE, 'inner_ipv6_valid', None, None, ), # 3
  )

  def __init__(self, tunnel_metadata_ingress_tunnel_type=None, inner_ipv4_valid=None, inner_ipv6_valid=None,):
    self.tunnel_metadata_ingress_tunnel_type = tunnel_metadata_ingress_tunnel_type
    self.inner_ipv4_valid = inner_ipv4_valid
    self.inner_ipv6_valid = inner_ipv6_valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.tunnel_metadata_ingress_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inner_ipv4_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.inner_ipv6_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_tunneled_packet_over_fabric_match_spec_t')
    if self.tunnel_metadata_ingress_tunnel_type is not None:
      oprot.writeFieldBegin('tunnel_metadata_ingress_tunnel_type', TType.BYTE, 1)
      oprot.writeByte(self.tunnel_metadata_ingress_tunnel_type)
      oprot.writeFieldEnd()
    if self.inner_ipv4_valid is not None:
      oprot.writeFieldBegin('inner_ipv4_valid', TType.BYTE, 2)
      oprot.writeByte(self.inner_ipv4_valid)
      oprot.writeFieldEnd()
    if self.inner_ipv6_valid is not None:
      oprot.writeFieldBegin('inner_ipv6_valid', TType.BYTE, 3)
      oprot.writeByte(self.inner_ipv6_valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tunnel_metadata_ingress_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_ingress_tunnel_type is unset!')
    if self.inner_ipv4_valid is None:
      raise TProtocol.TProtocolException(message='Required field inner_ipv4_valid is unset!')
    if self.inner_ipv6_valid is None:
      raise TProtocol.TProtocolException(message='Required field inner_ipv6_valid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tunnel_metadata_ingress_tunnel_type)
    value = (value * 31) ^ hash(self.inner_ipv4_valid)
    value = (value * 31) ^ hash(self.inner_ipv6_valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_egress_lag_match_spec_t:
  """
  Attributes:
   - standard_metadata_egress_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'standard_metadata_egress_port', None, None, ), # 1
  )

  def __init__(self, standard_metadata_egress_port=None,):
    self.standard_metadata_egress_port = standard_metadata_egress_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.standard_metadata_egress_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_egress_lag_match_spec_t')
    if self.standard_metadata_egress_port is not None:
      oprot.writeFieldBegin('standard_metadata_egress_port', TType.I16, 1)
      oprot.writeI16(self.standard_metadata_egress_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.standard_metadata_egress_port is None:
      raise TProtocol.TProtocolException(message='Required field standard_metadata_egress_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.standard_metadata_egress_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv6_urpf_lpm_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv6_metadata_lkp_ipv6_sa
   - ipv6_metadata_lkp_ipv6_sa_prefix_length
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.STRING, 'ipv6_metadata_lkp_ipv6_sa', None, None, ), # 2
    (3, TType.I16, 'ipv6_metadata_lkp_ipv6_sa_prefix_length', None, None, ), # 3
  )

  def __init__(self, l3_metadata_vrf=None, ipv6_metadata_lkp_ipv6_sa=None, ipv6_metadata_lkp_ipv6_sa_prefix_length=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv6_metadata_lkp_ipv6_sa = ipv6_metadata_lkp_ipv6_sa
    self.ipv6_metadata_lkp_ipv6_sa_prefix_length = ipv6_metadata_lkp_ipv6_sa_prefix_length

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.ipv6_metadata_lkp_ipv6_sa_prefix_length = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv6_urpf_lpm_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa', TType.STRING, 2)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_sa)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa_prefix_length is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa_prefix_length', TType.I16, 3)
      oprot.writeI16(self.ipv6_metadata_lkp_ipv6_sa_prefix_length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa_prefix_length is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa_prefix_length is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa_prefix_length)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_validate_packet_match_spec_t:
  """
  Attributes:
   - l2_metadata_lkp_mac_sa
   - l2_metadata_lkp_mac_sa_mask
   - l2_metadata_lkp_mac_da
   - l2_metadata_lkp_mac_da_mask
   - l3_metadata_lkp_ip_type
   - l3_metadata_lkp_ip_type_mask
   - l3_metadata_lkp_ip_ttl
   - l3_metadata_lkp_ip_ttl_mask
   - l3_metadata_lkp_ip_version
   - l3_metadata_lkp_ip_version_mask
   - ipv4_metadata_lkp_ipv4_sa
   - ipv4_metadata_lkp_ipv4_sa_mask
   - ipv6_metadata_lkp_ipv6_sa
   - ipv6_metadata_lkp_ipv6_sa_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'l2_metadata_lkp_mac_sa', None, None, ), # 1
    (2, TType.STRING, 'l2_metadata_lkp_mac_sa_mask', None, None, ), # 2
    (3, TType.STRING, 'l2_metadata_lkp_mac_da', None, None, ), # 3
    (4, TType.STRING, 'l2_metadata_lkp_mac_da_mask', None, None, ), # 4
    (5, TType.BYTE, 'l3_metadata_lkp_ip_type', None, None, ), # 5
    (6, TType.BYTE, 'l3_metadata_lkp_ip_type_mask', None, None, ), # 6
    (7, TType.BYTE, 'l3_metadata_lkp_ip_ttl', None, None, ), # 7
    (8, TType.BYTE, 'l3_metadata_lkp_ip_ttl_mask', None, None, ), # 8
    (9, TType.BYTE, 'l3_metadata_lkp_ip_version', None, None, ), # 9
    (10, TType.BYTE, 'l3_metadata_lkp_ip_version_mask', None, None, ), # 10
    (11, TType.I32, 'ipv4_metadata_lkp_ipv4_sa', None, None, ), # 11
    (12, TType.I32, 'ipv4_metadata_lkp_ipv4_sa_mask', None, None, ), # 12
    (13, TType.STRING, 'ipv6_metadata_lkp_ipv6_sa', None, None, ), # 13
    (14, TType.STRING, 'ipv6_metadata_lkp_ipv6_sa_mask', None, None, ), # 14
  )

  def __init__(self, l2_metadata_lkp_mac_sa=None, l2_metadata_lkp_mac_sa_mask=None, l2_metadata_lkp_mac_da=None, l2_metadata_lkp_mac_da_mask=None, l3_metadata_lkp_ip_type=None, l3_metadata_lkp_ip_type_mask=None, l3_metadata_lkp_ip_ttl=None, l3_metadata_lkp_ip_ttl_mask=None, l3_metadata_lkp_ip_version=None, l3_metadata_lkp_ip_version_mask=None, ipv4_metadata_lkp_ipv4_sa=None, ipv4_metadata_lkp_ipv4_sa_mask=None, ipv6_metadata_lkp_ipv6_sa=None, ipv6_metadata_lkp_ipv6_sa_mask=None,):
    self.l2_metadata_lkp_mac_sa = l2_metadata_lkp_mac_sa
    self.l2_metadata_lkp_mac_sa_mask = l2_metadata_lkp_mac_sa_mask
    self.l2_metadata_lkp_mac_da = l2_metadata_lkp_mac_da
    self.l2_metadata_lkp_mac_da_mask = l2_metadata_lkp_mac_da_mask
    self.l3_metadata_lkp_ip_type = l3_metadata_lkp_ip_type
    self.l3_metadata_lkp_ip_type_mask = l3_metadata_lkp_ip_type_mask
    self.l3_metadata_lkp_ip_ttl = l3_metadata_lkp_ip_ttl
    self.l3_metadata_lkp_ip_ttl_mask = l3_metadata_lkp_ip_ttl_mask
    self.l3_metadata_lkp_ip_version = l3_metadata_lkp_ip_version
    self.l3_metadata_lkp_ip_version_mask = l3_metadata_lkp_ip_version_mask
    self.ipv4_metadata_lkp_ipv4_sa = ipv4_metadata_lkp_ipv4_sa
    self.ipv4_metadata_lkp_ipv4_sa_mask = ipv4_metadata_lkp_ipv4_sa_mask
    self.ipv6_metadata_lkp_ipv6_sa = ipv6_metadata_lkp_ipv6_sa
    self.ipv6_metadata_lkp_ipv6_sa_mask = ipv6_metadata_lkp_ipv6_sa_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_sa_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_da = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_da_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_type_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_version = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_version_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.ipv6_metadata_lkp_ipv6_sa_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_validate_packet_match_spec_t')
    if self.l2_metadata_lkp_mac_sa is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_sa', TType.STRING, 1)
      oprot.writeString(self.l2_metadata_lkp_mac_sa)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_sa_mask is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_sa_mask', TType.STRING, 2)
      oprot.writeString(self.l2_metadata_lkp_mac_sa_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_da is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_da', TType.STRING, 3)
      oprot.writeString(self.l2_metadata_lkp_mac_da)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_da_mask is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_da_mask', TType.STRING, 4)
      oprot.writeString(self.l2_metadata_lkp_mac_da_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_type is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_type', TType.BYTE, 5)
      oprot.writeByte(self.l3_metadata_lkp_ip_type)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_type_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_type_mask', TType.BYTE, 6)
      oprot.writeByte(self.l3_metadata_lkp_ip_type_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl', TType.BYTE, 7)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl_mask', TType.BYTE, 8)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_version is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_version', TType.BYTE, 9)
      oprot.writeByte(self.l3_metadata_lkp_ip_version)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_version_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_version_mask', TType.BYTE, 10)
      oprot.writeByte(self.l3_metadata_lkp_ip_version_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa', TType.I32, 11)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa_mask', TType.I32, 12)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa_mask)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa', TType.STRING, 13)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_sa)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_lkp_ipv6_sa_mask is not None:
      oprot.writeFieldBegin('ipv6_metadata_lkp_ipv6_sa_mask', TType.STRING, 14)
      oprot.writeString(self.ipv6_metadata_lkp_ipv6_sa_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l2_metadata_lkp_mac_sa is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_sa is unset!')
    if self.l2_metadata_lkp_mac_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_sa_mask is unset!')
    if self.l2_metadata_lkp_mac_da is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_da is unset!')
    if self.l2_metadata_lkp_mac_da_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_da_mask is unset!')
    if self.l3_metadata_lkp_ip_type is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_type is unset!')
    if self.l3_metadata_lkp_ip_type_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_type_mask is unset!')
    if self.l3_metadata_lkp_ip_ttl is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl is unset!')
    if self.l3_metadata_lkp_ip_ttl_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl_mask is unset!')
    if self.l3_metadata_lkp_ip_version is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_version is unset!')
    if self.l3_metadata_lkp_ip_version_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_version_mask is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa_mask is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa is unset!')
    if self.ipv6_metadata_lkp_ipv6_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_lkp_ipv6_sa_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_sa)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_sa_mask)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_da)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_da_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_type)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_type_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_version)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_version_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa_mask)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa)
    value = (value * 31) ^ hash(self.ipv6_metadata_lkp_ipv6_sa_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_int_inst_0407_match_spec_t:
  """
  Attributes:
   - int_header_instruction_mask_0407
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'int_header_instruction_mask_0407', None, None, ), # 1
  )

  def __init__(self, int_header_instruction_mask_0407=None,):
    self.int_header_instruction_mask_0407 = int_header_instruction_mask_0407

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_0407 = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_int_inst_0407_match_spec_t')
    if self.int_header_instruction_mask_0407 is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_0407', TType.BYTE, 1)
      oprot.writeByte(self.int_header_instruction_mask_0407)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.int_header_instruction_mask_0407 is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_0407 is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.int_header_instruction_mask_0407)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_port_vlan_mapping_match_spec_t:
  """
  Attributes:
   - ingress_metadata_ifindex
   - vlan_tag__0__valid
   - vlan_tag__0__vid
   - vlan_tag__1__valid
   - vlan_tag__1__vid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'ingress_metadata_ifindex', None, None, ), # 1
    (2, TType.BYTE, 'vlan_tag__0__valid', None, None, ), # 2
    (3, TType.I16, 'vlan_tag__0__vid', None, None, ), # 3
    (4, TType.BYTE, 'vlan_tag__1__valid', None, None, ), # 4
    (5, TType.I16, 'vlan_tag__1__vid', None, None, ), # 5
  )

  def __init__(self, ingress_metadata_ifindex=None, vlan_tag__0__valid=None, vlan_tag__0__vid=None, vlan_tag__1__valid=None, vlan_tag__1__vid=None,):
    self.ingress_metadata_ifindex = ingress_metadata_ifindex
    self.vlan_tag__0__valid = vlan_tag__0__valid
    self.vlan_tag__0__vid = vlan_tag__0__vid
    self.vlan_tag__1__valid = vlan_tag__1__valid
    self.vlan_tag__1__vid = vlan_tag__1__vid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.ingress_metadata_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.vlan_tag__0__valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.vlan_tag__0__vid = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.vlan_tag__1__valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.vlan_tag__1__vid = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_port_vlan_mapping_match_spec_t')
    if self.ingress_metadata_ifindex is not None:
      oprot.writeFieldBegin('ingress_metadata_ifindex', TType.I16, 1)
      oprot.writeI16(self.ingress_metadata_ifindex)
      oprot.writeFieldEnd()
    if self.vlan_tag__0__valid is not None:
      oprot.writeFieldBegin('vlan_tag__0__valid', TType.BYTE, 2)
      oprot.writeByte(self.vlan_tag__0__valid)
      oprot.writeFieldEnd()
    if self.vlan_tag__0__vid is not None:
      oprot.writeFieldBegin('vlan_tag__0__vid', TType.I16, 3)
      oprot.writeI16(self.vlan_tag__0__vid)
      oprot.writeFieldEnd()
    if self.vlan_tag__1__valid is not None:
      oprot.writeFieldBegin('vlan_tag__1__valid', TType.BYTE, 4)
      oprot.writeByte(self.vlan_tag__1__valid)
      oprot.writeFieldEnd()
    if self.vlan_tag__1__vid is not None:
      oprot.writeFieldBegin('vlan_tag__1__vid', TType.I16, 5)
      oprot.writeI16(self.vlan_tag__1__vid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_ifindex is unset!')
    if self.vlan_tag__0__valid is None:
      raise TProtocol.TProtocolException(message='Required field vlan_tag__0__valid is unset!')
    if self.vlan_tag__0__vid is None:
      raise TProtocol.TProtocolException(message='Required field vlan_tag__0__vid is unset!')
    if self.vlan_tag__1__valid is None:
      raise TProtocol.TProtocolException(message='Required field vlan_tag__1__valid is unset!')
    if self.vlan_tag__1__vid is None:
      raise TProtocol.TProtocolException(message='Required field vlan_tag__1__vid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_ifindex)
    value = (value * 31) ^ hash(self.vlan_tag__0__valid)
    value = (value * 31) ^ hash(self.vlan_tag__0__vid)
    value = (value * 31) ^ hash(self.vlan_tag__1__valid)
    value = (value * 31) ^ hash(self.vlan_tag__1__vid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rmac_match_spec_t:
  """
  Attributes:
   - l3_metadata_rmac_group
   - l2_metadata_lkp_mac_da
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_rmac_group', None, None, ), # 1
    (2, TType.STRING, 'l2_metadata_lkp_mac_da', None, None, ), # 2
  )

  def __init__(self, l3_metadata_rmac_group=None, l2_metadata_lkp_mac_da=None,):
    self.l3_metadata_rmac_group = l3_metadata_rmac_group
    self.l2_metadata_lkp_mac_da = l2_metadata_lkp_mac_da

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_rmac_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_da = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rmac_match_spec_t')
    if self.l3_metadata_rmac_group is not None:
      oprot.writeFieldBegin('l3_metadata_rmac_group', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_rmac_group)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_da is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_da', TType.STRING, 2)
      oprot.writeString(self.l2_metadata_lkp_mac_da)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_rmac_group is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_rmac_group is unset!')
    if self.l2_metadata_lkp_mac_da is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_da is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_rmac_group)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_da)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_tunnel_encap_process_inner_match_spec_t:
  """
  Attributes:
   - ipv4_valid
   - ipv6_valid
   - tcp_valid
   - udp_valid
   - icmp_valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'ipv4_valid', None, None, ), # 1
    (2, TType.BYTE, 'ipv6_valid', None, None, ), # 2
    (3, TType.BYTE, 'tcp_valid', None, None, ), # 3
    (4, TType.BYTE, 'udp_valid', None, None, ), # 4
    (5, TType.BYTE, 'icmp_valid', None, None, ), # 5
  )

  def __init__(self, ipv4_valid=None, ipv6_valid=None, tcp_valid=None, udp_valid=None, icmp_valid=None,):
    self.ipv4_valid = ipv4_valid
    self.ipv6_valid = ipv6_valid
    self.tcp_valid = tcp_valid
    self.udp_valid = udp_valid
    self.icmp_valid = icmp_valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.ipv4_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.ipv6_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.tcp_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.udp_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.icmp_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_tunnel_encap_process_inner_match_spec_t')
    if self.ipv4_valid is not None:
      oprot.writeFieldBegin('ipv4_valid', TType.BYTE, 1)
      oprot.writeByte(self.ipv4_valid)
      oprot.writeFieldEnd()
    if self.ipv6_valid is not None:
      oprot.writeFieldBegin('ipv6_valid', TType.BYTE, 2)
      oprot.writeByte(self.ipv6_valid)
      oprot.writeFieldEnd()
    if self.tcp_valid is not None:
      oprot.writeFieldBegin('tcp_valid', TType.BYTE, 3)
      oprot.writeByte(self.tcp_valid)
      oprot.writeFieldEnd()
    if self.udp_valid is not None:
      oprot.writeFieldBegin('udp_valid', TType.BYTE, 4)
      oprot.writeByte(self.udp_valid)
      oprot.writeFieldEnd()
    if self.icmp_valid is not None:
      oprot.writeFieldBegin('icmp_valid', TType.BYTE, 5)
      oprot.writeByte(self.icmp_valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ipv4_valid is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_valid is unset!')
    if self.ipv6_valid is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_valid is unset!')
    if self.tcp_valid is None:
      raise TProtocol.TProtocolException(message='Required field tcp_valid is unset!')
    if self.udp_valid is None:
      raise TProtocol.TProtocolException(message='Required field udp_valid is unset!')
    if self.icmp_valid is None:
      raise TProtocol.TProtocolException(message='Required field icmp_valid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ipv4_valid)
    value = (value * 31) ^ hash(self.ipv6_valid)
    value = (value * 31) ^ hash(self.tcp_valid)
    value = (value * 31) ^ hash(self.udp_valid)
    value = (value * 31) ^ hash(self.icmp_valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_replica_type_match_spec_t:
  """
  Attributes:
   - multicast_metadata_replica
   - egress_metadata_same_bd_check
   - egress_metadata_same_bd_check_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'multicast_metadata_replica', None, None, ), # 1
    (2, TType.I16, 'egress_metadata_same_bd_check', None, None, ), # 2
    (3, TType.I16, 'egress_metadata_same_bd_check_mask', None, None, ), # 3
  )

  def __init__(self, multicast_metadata_replica=None, egress_metadata_same_bd_check=None, egress_metadata_same_bd_check_mask=None,):
    self.multicast_metadata_replica = multicast_metadata_replica
    self.egress_metadata_same_bd_check = egress_metadata_same_bd_check
    self.egress_metadata_same_bd_check_mask = egress_metadata_same_bd_check_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.multicast_metadata_replica = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.egress_metadata_same_bd_check = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.egress_metadata_same_bd_check_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_replica_type_match_spec_t')
    if self.multicast_metadata_replica is not None:
      oprot.writeFieldBegin('multicast_metadata_replica', TType.BYTE, 1)
      oprot.writeByte(self.multicast_metadata_replica)
      oprot.writeFieldEnd()
    if self.egress_metadata_same_bd_check is not None:
      oprot.writeFieldBegin('egress_metadata_same_bd_check', TType.I16, 2)
      oprot.writeI16(self.egress_metadata_same_bd_check)
      oprot.writeFieldEnd()
    if self.egress_metadata_same_bd_check_mask is not None:
      oprot.writeFieldBegin('egress_metadata_same_bd_check_mask', TType.I16, 3)
      oprot.writeI16(self.egress_metadata_same_bd_check_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.multicast_metadata_replica is None:
      raise TProtocol.TProtocolException(message='Required field multicast_metadata_replica is unset!')
    if self.egress_metadata_same_bd_check is None:
      raise TProtocol.TProtocolException(message='Required field egress_metadata_same_bd_check is unset!')
    if self.egress_metadata_same_bd_check_mask is None:
      raise TProtocol.TProtocolException(message='Required field egress_metadata_same_bd_check_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.multicast_metadata_replica)
    value = (value * 31) ^ hash(self.egress_metadata_same_bd_check)
    value = (value * 31) ^ hash(self.egress_metadata_same_bd_check_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_mac_rewrite_match_spec_t:
  """
  Attributes:
   - egress_metadata_smac_idx
   - ipv4_valid
   - ipv6_valid
   - mpls_0__valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'egress_metadata_smac_idx', None, None, ), # 1
    (2, TType.BYTE, 'ipv4_valid', None, None, ), # 2
    (3, TType.BYTE, 'ipv6_valid', None, None, ), # 3
    (4, TType.BYTE, 'mpls_0__valid', None, None, ), # 4
  )

  def __init__(self, egress_metadata_smac_idx=None, ipv4_valid=None, ipv6_valid=None, mpls_0__valid=None,):
    self.egress_metadata_smac_idx = egress_metadata_smac_idx
    self.ipv4_valid = ipv4_valid
    self.ipv6_valid = ipv6_valid
    self.mpls_0__valid = mpls_0__valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.egress_metadata_smac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.ipv4_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.ipv6_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.mpls_0__valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_mac_rewrite_match_spec_t')
    if self.egress_metadata_smac_idx is not None:
      oprot.writeFieldBegin('egress_metadata_smac_idx', TType.I16, 1)
      oprot.writeI16(self.egress_metadata_smac_idx)
      oprot.writeFieldEnd()
    if self.ipv4_valid is not None:
      oprot.writeFieldBegin('ipv4_valid', TType.BYTE, 2)
      oprot.writeByte(self.ipv4_valid)
      oprot.writeFieldEnd()
    if self.ipv6_valid is not None:
      oprot.writeFieldBegin('ipv6_valid', TType.BYTE, 3)
      oprot.writeByte(self.ipv6_valid)
      oprot.writeFieldEnd()
    if self.mpls_0__valid is not None:
      oprot.writeFieldBegin('mpls_0__valid', TType.BYTE, 4)
      oprot.writeByte(self.mpls_0__valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.egress_metadata_smac_idx is None:
      raise TProtocol.TProtocolException(message='Required field egress_metadata_smac_idx is unset!')
    if self.ipv4_valid is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_valid is unset!')
    if self.ipv6_valid is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_valid is unset!')
    if self.mpls_0__valid is None:
      raise TProtocol.TProtocolException(message='Required field mpls_0__valid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.egress_metadata_smac_idx)
    value = (value * 31) ^ hash(self.ipv4_valid)
    value = (value * 31) ^ hash(self.ipv6_valid)
    value = (value * 31) ^ hash(self.mpls_0__valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_mirror_match_spec_t:
  """
  Attributes:
   - i2e_metadata_mirror_session_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'i2e_metadata_mirror_session_id', None, None, ), # 1
  )

  def __init__(self, i2e_metadata_mirror_session_id=None,):
    self.i2e_metadata_mirror_session_id = i2e_metadata_mirror_session_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.i2e_metadata_mirror_session_id = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_mirror_match_spec_t')
    if self.i2e_metadata_mirror_session_id is not None:
      oprot.writeFieldBegin('i2e_metadata_mirror_session_id', TType.I16, 1)
      oprot.writeI16(self.i2e_metadata_mirror_session_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.i2e_metadata_mirror_session_id is None:
      raise TProtocol.TProtocolException(message='Required field i2e_metadata_mirror_session_id is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.i2e_metadata_mirror_session_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_tunnel_decap_process_outer_match_spec_t:
  """
  Attributes:
   - tunnel_metadata_ingress_tunnel_type
   - inner_ipv4_valid
   - inner_ipv6_valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'tunnel_metadata_ingress_tunnel_type', None, None, ), # 1
    (2, TType.BYTE, 'inner_ipv4_valid', None, None, ), # 2
    (3, TType.BYTE, 'inner_ipv6_valid', None, None, ), # 3
  )

  def __init__(self, tunnel_metadata_ingress_tunnel_type=None, inner_ipv4_valid=None, inner_ipv6_valid=None,):
    self.tunnel_metadata_ingress_tunnel_type = tunnel_metadata_ingress_tunnel_type
    self.inner_ipv4_valid = inner_ipv4_valid
    self.inner_ipv6_valid = inner_ipv6_valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.tunnel_metadata_ingress_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inner_ipv4_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.inner_ipv6_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_tunnel_decap_process_outer_match_spec_t')
    if self.tunnel_metadata_ingress_tunnel_type is not None:
      oprot.writeFieldBegin('tunnel_metadata_ingress_tunnel_type', TType.BYTE, 1)
      oprot.writeByte(self.tunnel_metadata_ingress_tunnel_type)
      oprot.writeFieldEnd()
    if self.inner_ipv4_valid is not None:
      oprot.writeFieldBegin('inner_ipv4_valid', TType.BYTE, 2)
      oprot.writeByte(self.inner_ipv4_valid)
      oprot.writeFieldEnd()
    if self.inner_ipv6_valid is not None:
      oprot.writeFieldBegin('inner_ipv6_valid', TType.BYTE, 3)
      oprot.writeByte(self.inner_ipv6_valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tunnel_metadata_ingress_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_ingress_tunnel_type is unset!')
    if self.inner_ipv4_valid is None:
      raise TProtocol.TProtocolException(message='Required field inner_ipv4_valid is unset!')
    if self.inner_ipv6_valid is None:
      raise TProtocol.TProtocolException(message='Required field inner_ipv6_valid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tunnel_metadata_ingress_tunnel_type)
    value = (value * 31) ^ hash(self.inner_ipv4_valid)
    value = (value * 31) ^ hash(self.inner_ipv6_valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_system_acl_match_spec_t:
  """
  Attributes:
   - acl_metadata_if_label
   - acl_metadata_if_label_mask
   - acl_metadata_bd_label
   - acl_metadata_bd_label_mask
   - ipv4_metadata_lkp_ipv4_sa
   - ipv4_metadata_lkp_ipv4_sa_mask
   - ipv4_metadata_lkp_ipv4_da
   - ipv4_metadata_lkp_ipv4_da_mask
   - l3_metadata_lkp_ip_proto
   - l3_metadata_lkp_ip_proto_mask
   - l2_metadata_lkp_mac_sa
   - l2_metadata_lkp_mac_sa_mask
   - l2_metadata_lkp_mac_da
   - l2_metadata_lkp_mac_da_mask
   - l2_metadata_lkp_mac_type
   - l2_metadata_lkp_mac_type_mask
   - ingress_metadata_ifindex
   - ingress_metadata_ifindex_mask
   - l2_metadata_port_vlan_mapping_miss
   - l2_metadata_port_vlan_mapping_miss_mask
   - security_metadata_ipsg_check_fail
   - security_metadata_ipsg_check_fail_mask
   - acl_metadata_acl_deny
   - acl_metadata_acl_deny_mask
   - acl_metadata_racl_deny
   - acl_metadata_racl_deny_mask
   - l3_metadata_urpf_check_fail
   - l3_metadata_urpf_check_fail_mask
   - ingress_metadata_drop_flag
   - ingress_metadata_drop_flag_mask
   - l3_metadata_rmac_hit
   - l3_metadata_rmac_hit_mask
   - l3_metadata_routed
   - l3_metadata_routed_mask
   - ipv6_metadata_ipv6_src_is_link_local
   - ipv6_metadata_ipv6_src_is_link_local_mask
   - l2_metadata_same_if_check
   - l2_metadata_same_if_check_mask
   - tunnel_metadata_tunnel_if_check
   - tunnel_metadata_tunnel_if_check_mask
   - l3_metadata_same_bd_check
   - l3_metadata_same_bd_check_mask
   - l3_metadata_lkp_ip_ttl
   - l3_metadata_lkp_ip_ttl_mask
   - l2_metadata_stp_state
   - l2_metadata_stp_state_mask
   - ingress_metadata_control_frame
   - ingress_metadata_control_frame_mask
   - ipv4_metadata_ipv4_unicast_enabled
   - ipv4_metadata_ipv4_unicast_enabled_mask
   - ingress_metadata_egress_ifindex
   - ingress_metadata_egress_ifindex_mask
   - ingress_metadata_enable_dod
   - ingress_metadata_enable_dod_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'acl_metadata_if_label', None, None, ), # 1
    (2, TType.I16, 'acl_metadata_if_label_mask', None, None, ), # 2
    (3, TType.I16, 'acl_metadata_bd_label', None, None, ), # 3
    (4, TType.I16, 'acl_metadata_bd_label_mask', None, None, ), # 4
    (5, TType.I32, 'ipv4_metadata_lkp_ipv4_sa', None, None, ), # 5
    (6, TType.I32, 'ipv4_metadata_lkp_ipv4_sa_mask', None, None, ), # 6
    (7, TType.I32, 'ipv4_metadata_lkp_ipv4_da', None, None, ), # 7
    (8, TType.I32, 'ipv4_metadata_lkp_ipv4_da_mask', None, None, ), # 8
    (9, TType.BYTE, 'l3_metadata_lkp_ip_proto', None, None, ), # 9
    (10, TType.BYTE, 'l3_metadata_lkp_ip_proto_mask', None, None, ), # 10
    (11, TType.STRING, 'l2_metadata_lkp_mac_sa', None, None, ), # 11
    (12, TType.STRING, 'l2_metadata_lkp_mac_sa_mask', None, None, ), # 12
    (13, TType.STRING, 'l2_metadata_lkp_mac_da', None, None, ), # 13
    (14, TType.STRING, 'l2_metadata_lkp_mac_da_mask', None, None, ), # 14
    (15, TType.I16, 'l2_metadata_lkp_mac_type', None, None, ), # 15
    (16, TType.I16, 'l2_metadata_lkp_mac_type_mask', None, None, ), # 16
    (17, TType.I16, 'ingress_metadata_ifindex', None, None, ), # 17
    (18, TType.I16, 'ingress_metadata_ifindex_mask', None, None, ), # 18
    (19, TType.BYTE, 'l2_metadata_port_vlan_mapping_miss', None, None, ), # 19
    (20, TType.BYTE, 'l2_metadata_port_vlan_mapping_miss_mask', None, None, ), # 20
    (21, TType.BYTE, 'security_metadata_ipsg_check_fail', None, None, ), # 21
    (22, TType.BYTE, 'security_metadata_ipsg_check_fail_mask', None, None, ), # 22
    (23, TType.BYTE, 'acl_metadata_acl_deny', None, None, ), # 23
    (24, TType.BYTE, 'acl_metadata_acl_deny_mask', None, None, ), # 24
    (25, TType.BYTE, 'acl_metadata_racl_deny', None, None, ), # 25
    (26, TType.BYTE, 'acl_metadata_racl_deny_mask', None, None, ), # 26
    (27, TType.BYTE, 'l3_metadata_urpf_check_fail', None, None, ), # 27
    (28, TType.BYTE, 'l3_metadata_urpf_check_fail_mask', None, None, ), # 28
    (29, TType.BYTE, 'ingress_metadata_drop_flag', None, None, ), # 29
    (30, TType.BYTE, 'ingress_metadata_drop_flag_mask', None, None, ), # 30
    (31, TType.BYTE, 'l3_metadata_rmac_hit', None, None, ), # 31
    (32, TType.BYTE, 'l3_metadata_rmac_hit_mask', None, None, ), # 32
    (33, TType.BYTE, 'l3_metadata_routed', None, None, ), # 33
    (34, TType.BYTE, 'l3_metadata_routed_mask', None, None, ), # 34
    (35, TType.BYTE, 'ipv6_metadata_ipv6_src_is_link_local', None, None, ), # 35
    (36, TType.BYTE, 'ipv6_metadata_ipv6_src_is_link_local_mask', None, None, ), # 36
    (37, TType.I16, 'l2_metadata_same_if_check', None, None, ), # 37
    (38, TType.I16, 'l2_metadata_same_if_check_mask', None, None, ), # 38
    (39, TType.BYTE, 'tunnel_metadata_tunnel_if_check', None, None, ), # 39
    (40, TType.BYTE, 'tunnel_metadata_tunnel_if_check_mask', None, None, ), # 40
    (41, TType.I16, 'l3_metadata_same_bd_check', None, None, ), # 41
    (42, TType.I16, 'l3_metadata_same_bd_check_mask', None, None, ), # 42
    (43, TType.BYTE, 'l3_metadata_lkp_ip_ttl', None, None, ), # 43
    (44, TType.BYTE, 'l3_metadata_lkp_ip_ttl_mask', None, None, ), # 44
    (45, TType.BYTE, 'l2_metadata_stp_state', None, None, ), # 45
    (46, TType.BYTE, 'l2_metadata_stp_state_mask', None, None, ), # 46
    (47, TType.BYTE, 'ingress_metadata_control_frame', None, None, ), # 47
    (48, TType.BYTE, 'ingress_metadata_control_frame_mask', None, None, ), # 48
    (49, TType.BYTE, 'ipv4_metadata_ipv4_unicast_enabled', None, None, ), # 49
    (50, TType.BYTE, 'ipv4_metadata_ipv4_unicast_enabled_mask', None, None, ), # 50
    (51, TType.I16, 'ingress_metadata_egress_ifindex', None, None, ), # 51
    (52, TType.I16, 'ingress_metadata_egress_ifindex_mask', None, None, ), # 52
    (53, TType.BYTE, 'ingress_metadata_enable_dod', None, None, ), # 53
    (54, TType.BYTE, 'ingress_metadata_enable_dod_mask', None, None, ), # 54
  )

  def __init__(self, acl_metadata_if_label=None, acl_metadata_if_label_mask=None, acl_metadata_bd_label=None, acl_metadata_bd_label_mask=None, ipv4_metadata_lkp_ipv4_sa=None, ipv4_metadata_lkp_ipv4_sa_mask=None, ipv4_metadata_lkp_ipv4_da=None, ipv4_metadata_lkp_ipv4_da_mask=None, l3_metadata_lkp_ip_proto=None, l3_metadata_lkp_ip_proto_mask=None, l2_metadata_lkp_mac_sa=None, l2_metadata_lkp_mac_sa_mask=None, l2_metadata_lkp_mac_da=None, l2_metadata_lkp_mac_da_mask=None, l2_metadata_lkp_mac_type=None, l2_metadata_lkp_mac_type_mask=None, ingress_metadata_ifindex=None, ingress_metadata_ifindex_mask=None, l2_metadata_port_vlan_mapping_miss=None, l2_metadata_port_vlan_mapping_miss_mask=None, security_metadata_ipsg_check_fail=None, security_metadata_ipsg_check_fail_mask=None, acl_metadata_acl_deny=None, acl_metadata_acl_deny_mask=None, acl_metadata_racl_deny=None, acl_metadata_racl_deny_mask=None, l3_metadata_urpf_check_fail=None, l3_metadata_urpf_check_fail_mask=None, ingress_metadata_drop_flag=None, ingress_metadata_drop_flag_mask=None, l3_metadata_rmac_hit=None, l3_metadata_rmac_hit_mask=None, l3_metadata_routed=None, l3_metadata_routed_mask=None, ipv6_metadata_ipv6_src_is_link_local=None, ipv6_metadata_ipv6_src_is_link_local_mask=None, l2_metadata_same_if_check=None, l2_metadata_same_if_check_mask=None, tunnel_metadata_tunnel_if_check=None, tunnel_metadata_tunnel_if_check_mask=None, l3_metadata_same_bd_check=None, l3_metadata_same_bd_check_mask=None, l3_metadata_lkp_ip_ttl=None, l3_metadata_lkp_ip_ttl_mask=None, l2_metadata_stp_state=None, l2_metadata_stp_state_mask=None, ingress_metadata_control_frame=None, ingress_metadata_control_frame_mask=None, ipv4_metadata_ipv4_unicast_enabled=None, ipv4_metadata_ipv4_unicast_enabled_mask=None, ingress_metadata_egress_ifindex=None, ingress_metadata_egress_ifindex_mask=None, ingress_metadata_enable_dod=None, ingress_metadata_enable_dod_mask=None,):
    self.acl_metadata_if_label = acl_metadata_if_label
    self.acl_metadata_if_label_mask = acl_metadata_if_label_mask
    self.acl_metadata_bd_label = acl_metadata_bd_label
    self.acl_metadata_bd_label_mask = acl_metadata_bd_label_mask
    self.ipv4_metadata_lkp_ipv4_sa = ipv4_metadata_lkp_ipv4_sa
    self.ipv4_metadata_lkp_ipv4_sa_mask = ipv4_metadata_lkp_ipv4_sa_mask
    self.ipv4_metadata_lkp_ipv4_da = ipv4_metadata_lkp_ipv4_da
    self.ipv4_metadata_lkp_ipv4_da_mask = ipv4_metadata_lkp_ipv4_da_mask
    self.l3_metadata_lkp_ip_proto = l3_metadata_lkp_ip_proto
    self.l3_metadata_lkp_ip_proto_mask = l3_metadata_lkp_ip_proto_mask
    self.l2_metadata_lkp_mac_sa = l2_metadata_lkp_mac_sa
    self.l2_metadata_lkp_mac_sa_mask = l2_metadata_lkp_mac_sa_mask
    self.l2_metadata_lkp_mac_da = l2_metadata_lkp_mac_da
    self.l2_metadata_lkp_mac_da_mask = l2_metadata_lkp_mac_da_mask
    self.l2_metadata_lkp_mac_type = l2_metadata_lkp_mac_type
    self.l2_metadata_lkp_mac_type_mask = l2_metadata_lkp_mac_type_mask
    self.ingress_metadata_ifindex = ingress_metadata_ifindex
    self.ingress_metadata_ifindex_mask = ingress_metadata_ifindex_mask
    self.l2_metadata_port_vlan_mapping_miss = l2_metadata_port_vlan_mapping_miss
    self.l2_metadata_port_vlan_mapping_miss_mask = l2_metadata_port_vlan_mapping_miss_mask
    self.security_metadata_ipsg_check_fail = security_metadata_ipsg_check_fail
    self.security_metadata_ipsg_check_fail_mask = security_metadata_ipsg_check_fail_mask
    self.acl_metadata_acl_deny = acl_metadata_acl_deny
    self.acl_metadata_acl_deny_mask = acl_metadata_acl_deny_mask
    self.acl_metadata_racl_deny = acl_metadata_racl_deny
    self.acl_metadata_racl_deny_mask = acl_metadata_racl_deny_mask
    self.l3_metadata_urpf_check_fail = l3_metadata_urpf_check_fail
    self.l3_metadata_urpf_check_fail_mask = l3_metadata_urpf_check_fail_mask
    self.ingress_metadata_drop_flag = ingress_metadata_drop_flag
    self.ingress_metadata_drop_flag_mask = ingress_metadata_drop_flag_mask
    self.l3_metadata_rmac_hit = l3_metadata_rmac_hit
    self.l3_metadata_rmac_hit_mask = l3_metadata_rmac_hit_mask
    self.l3_metadata_routed = l3_metadata_routed
    self.l3_metadata_routed_mask = l3_metadata_routed_mask
    self.ipv6_metadata_ipv6_src_is_link_local = ipv6_metadata_ipv6_src_is_link_local
    self.ipv6_metadata_ipv6_src_is_link_local_mask = ipv6_metadata_ipv6_src_is_link_local_mask
    self.l2_metadata_same_if_check = l2_metadata_same_if_check
    self.l2_metadata_same_if_check_mask = l2_metadata_same_if_check_mask
    self.tunnel_metadata_tunnel_if_check = tunnel_metadata_tunnel_if_check
    self.tunnel_metadata_tunnel_if_check_mask = tunnel_metadata_tunnel_if_check_mask
    self.l3_metadata_same_bd_check = l3_metadata_same_bd_check
    self.l3_metadata_same_bd_check_mask = l3_metadata_same_bd_check_mask
    self.l3_metadata_lkp_ip_ttl = l3_metadata_lkp_ip_ttl
    self.l3_metadata_lkp_ip_ttl_mask = l3_metadata_lkp_ip_ttl_mask
    self.l2_metadata_stp_state = l2_metadata_stp_state
    self.l2_metadata_stp_state_mask = l2_metadata_stp_state_mask
    self.ingress_metadata_control_frame = ingress_metadata_control_frame
    self.ingress_metadata_control_frame_mask = ingress_metadata_control_frame_mask
    self.ipv4_metadata_ipv4_unicast_enabled = ipv4_metadata_ipv4_unicast_enabled
    self.ipv4_metadata_ipv4_unicast_enabled_mask = ipv4_metadata_ipv4_unicast_enabled_mask
    self.ingress_metadata_egress_ifindex = ingress_metadata_egress_ifindex
    self.ingress_metadata_egress_ifindex_mask = ingress_metadata_egress_ifindex_mask
    self.ingress_metadata_enable_dod = ingress_metadata_enable_dod
    self.ingress_metadata_enable_dod_mask = ingress_metadata_enable_dod_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.acl_metadata_if_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.acl_metadata_if_label_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.acl_metadata_bd_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.acl_metadata_bd_label_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_sa_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_da = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_da_mask = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I16:
          self.l2_metadata_lkp_mac_type = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I16:
          self.l2_metadata_lkp_mac_type_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I16:
          self.ingress_metadata_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I16:
          self.ingress_metadata_ifindex_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.BYTE:
          self.l2_metadata_port_vlan_mapping_miss = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.BYTE:
          self.l2_metadata_port_vlan_mapping_miss_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.BYTE:
          self.security_metadata_ipsg_check_fail = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.BYTE:
          self.security_metadata_ipsg_check_fail_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.BYTE:
          self.acl_metadata_acl_deny = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.BYTE:
          self.acl_metadata_acl_deny_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.BYTE:
          self.acl_metadata_racl_deny = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.BYTE:
          self.acl_metadata_racl_deny_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.BYTE:
          self.l3_metadata_urpf_check_fail = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 28:
        if ftype == TType.BYTE:
          self.l3_metadata_urpf_check_fail_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 29:
        if ftype == TType.BYTE:
          self.ingress_metadata_drop_flag = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.BYTE:
          self.ingress_metadata_drop_flag_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 31:
        if ftype == TType.BYTE:
          self.l3_metadata_rmac_hit = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 32:
        if ftype == TType.BYTE:
          self.l3_metadata_rmac_hit_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 33:
        if ftype == TType.BYTE:
          self.l3_metadata_routed = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 34:
        if ftype == TType.BYTE:
          self.l3_metadata_routed_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 35:
        if ftype == TType.BYTE:
          self.ipv6_metadata_ipv6_src_is_link_local = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 36:
        if ftype == TType.BYTE:
          self.ipv6_metadata_ipv6_src_is_link_local_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 37:
        if ftype == TType.I16:
          self.l2_metadata_same_if_check = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 38:
        if ftype == TType.I16:
          self.l2_metadata_same_if_check_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 39:
        if ftype == TType.BYTE:
          self.tunnel_metadata_tunnel_if_check = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 40:
        if ftype == TType.BYTE:
          self.tunnel_metadata_tunnel_if_check_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 41:
        if ftype == TType.I16:
          self.l3_metadata_same_bd_check = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 42:
        if ftype == TType.I16:
          self.l3_metadata_same_bd_check_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 43:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 44:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 45:
        if ftype == TType.BYTE:
          self.l2_metadata_stp_state = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 46:
        if ftype == TType.BYTE:
          self.l2_metadata_stp_state_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 47:
        if ftype == TType.BYTE:
          self.ingress_metadata_control_frame = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 48:
        if ftype == TType.BYTE:
          self.ingress_metadata_control_frame_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 49:
        if ftype == TType.BYTE:
          self.ipv4_metadata_ipv4_unicast_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 50:
        if ftype == TType.BYTE:
          self.ipv4_metadata_ipv4_unicast_enabled_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 51:
        if ftype == TType.I16:
          self.ingress_metadata_egress_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 52:
        if ftype == TType.I16:
          self.ingress_metadata_egress_ifindex_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 53:
        if ftype == TType.BYTE:
          self.ingress_metadata_enable_dod = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 54:
        if ftype == TType.BYTE:
          self.ingress_metadata_enable_dod_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_system_acl_match_spec_t')
    if self.acl_metadata_if_label is not None:
      oprot.writeFieldBegin('acl_metadata_if_label', TType.I16, 1)
      oprot.writeI16(self.acl_metadata_if_label)
      oprot.writeFieldEnd()
    if self.acl_metadata_if_label_mask is not None:
      oprot.writeFieldBegin('acl_metadata_if_label_mask', TType.I16, 2)
      oprot.writeI16(self.acl_metadata_if_label_mask)
      oprot.writeFieldEnd()
    if self.acl_metadata_bd_label is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label', TType.I16, 3)
      oprot.writeI16(self.acl_metadata_bd_label)
      oprot.writeFieldEnd()
    if self.acl_metadata_bd_label_mask is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label_mask', TType.I16, 4)
      oprot.writeI16(self.acl_metadata_bd_label_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa', TType.I32, 5)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa_mask', TType.I32, 6)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da', TType.I32, 7)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da_mask', TType.I32, 8)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto', TType.BYTE, 9)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto_mask', TType.BYTE, 10)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_sa is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_sa', TType.STRING, 11)
      oprot.writeString(self.l2_metadata_lkp_mac_sa)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_sa_mask is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_sa_mask', TType.STRING, 12)
      oprot.writeString(self.l2_metadata_lkp_mac_sa_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_da is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_da', TType.STRING, 13)
      oprot.writeString(self.l2_metadata_lkp_mac_da)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_da_mask is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_da_mask', TType.STRING, 14)
      oprot.writeString(self.l2_metadata_lkp_mac_da_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_type is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_type', TType.I16, 15)
      oprot.writeI16(self.l2_metadata_lkp_mac_type)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_type_mask is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_type_mask', TType.I16, 16)
      oprot.writeI16(self.l2_metadata_lkp_mac_type_mask)
      oprot.writeFieldEnd()
    if self.ingress_metadata_ifindex is not None:
      oprot.writeFieldBegin('ingress_metadata_ifindex', TType.I16, 17)
      oprot.writeI16(self.ingress_metadata_ifindex)
      oprot.writeFieldEnd()
    if self.ingress_metadata_ifindex_mask is not None:
      oprot.writeFieldBegin('ingress_metadata_ifindex_mask', TType.I16, 18)
      oprot.writeI16(self.ingress_metadata_ifindex_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_port_vlan_mapping_miss is not None:
      oprot.writeFieldBegin('l2_metadata_port_vlan_mapping_miss', TType.BYTE, 19)
      oprot.writeByte(self.l2_metadata_port_vlan_mapping_miss)
      oprot.writeFieldEnd()
    if self.l2_metadata_port_vlan_mapping_miss_mask is not None:
      oprot.writeFieldBegin('l2_metadata_port_vlan_mapping_miss_mask', TType.BYTE, 20)
      oprot.writeByte(self.l2_metadata_port_vlan_mapping_miss_mask)
      oprot.writeFieldEnd()
    if self.security_metadata_ipsg_check_fail is not None:
      oprot.writeFieldBegin('security_metadata_ipsg_check_fail', TType.BYTE, 21)
      oprot.writeByte(self.security_metadata_ipsg_check_fail)
      oprot.writeFieldEnd()
    if self.security_metadata_ipsg_check_fail_mask is not None:
      oprot.writeFieldBegin('security_metadata_ipsg_check_fail_mask', TType.BYTE, 22)
      oprot.writeByte(self.security_metadata_ipsg_check_fail_mask)
      oprot.writeFieldEnd()
    if self.acl_metadata_acl_deny is not None:
      oprot.writeFieldBegin('acl_metadata_acl_deny', TType.BYTE, 23)
      oprot.writeByte(self.acl_metadata_acl_deny)
      oprot.writeFieldEnd()
    if self.acl_metadata_acl_deny_mask is not None:
      oprot.writeFieldBegin('acl_metadata_acl_deny_mask', TType.BYTE, 24)
      oprot.writeByte(self.acl_metadata_acl_deny_mask)
      oprot.writeFieldEnd()
    if self.acl_metadata_racl_deny is not None:
      oprot.writeFieldBegin('acl_metadata_racl_deny', TType.BYTE, 25)
      oprot.writeByte(self.acl_metadata_racl_deny)
      oprot.writeFieldEnd()
    if self.acl_metadata_racl_deny_mask is not None:
      oprot.writeFieldBegin('acl_metadata_racl_deny_mask', TType.BYTE, 26)
      oprot.writeByte(self.acl_metadata_racl_deny_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_urpf_check_fail is not None:
      oprot.writeFieldBegin('l3_metadata_urpf_check_fail', TType.BYTE, 27)
      oprot.writeByte(self.l3_metadata_urpf_check_fail)
      oprot.writeFieldEnd()
    if self.l3_metadata_urpf_check_fail_mask is not None:
      oprot.writeFieldBegin('l3_metadata_urpf_check_fail_mask', TType.BYTE, 28)
      oprot.writeByte(self.l3_metadata_urpf_check_fail_mask)
      oprot.writeFieldEnd()
    if self.ingress_metadata_drop_flag is not None:
      oprot.writeFieldBegin('ingress_metadata_drop_flag', TType.BYTE, 29)
      oprot.writeByte(self.ingress_metadata_drop_flag)
      oprot.writeFieldEnd()
    if self.ingress_metadata_drop_flag_mask is not None:
      oprot.writeFieldBegin('ingress_metadata_drop_flag_mask', TType.BYTE, 30)
      oprot.writeByte(self.ingress_metadata_drop_flag_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_rmac_hit is not None:
      oprot.writeFieldBegin('l3_metadata_rmac_hit', TType.BYTE, 31)
      oprot.writeByte(self.l3_metadata_rmac_hit)
      oprot.writeFieldEnd()
    if self.l3_metadata_rmac_hit_mask is not None:
      oprot.writeFieldBegin('l3_metadata_rmac_hit_mask', TType.BYTE, 32)
      oprot.writeByte(self.l3_metadata_rmac_hit_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_routed is not None:
      oprot.writeFieldBegin('l3_metadata_routed', TType.BYTE, 33)
      oprot.writeByte(self.l3_metadata_routed)
      oprot.writeFieldEnd()
    if self.l3_metadata_routed_mask is not None:
      oprot.writeFieldBegin('l3_metadata_routed_mask', TType.BYTE, 34)
      oprot.writeByte(self.l3_metadata_routed_mask)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_ipv6_src_is_link_local is not None:
      oprot.writeFieldBegin('ipv6_metadata_ipv6_src_is_link_local', TType.BYTE, 35)
      oprot.writeByte(self.ipv6_metadata_ipv6_src_is_link_local)
      oprot.writeFieldEnd()
    if self.ipv6_metadata_ipv6_src_is_link_local_mask is not None:
      oprot.writeFieldBegin('ipv6_metadata_ipv6_src_is_link_local_mask', TType.BYTE, 36)
      oprot.writeByte(self.ipv6_metadata_ipv6_src_is_link_local_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_same_if_check is not None:
      oprot.writeFieldBegin('l2_metadata_same_if_check', TType.I16, 37)
      oprot.writeI16(self.l2_metadata_same_if_check)
      oprot.writeFieldEnd()
    if self.l2_metadata_same_if_check_mask is not None:
      oprot.writeFieldBegin('l2_metadata_same_if_check_mask', TType.I16, 38)
      oprot.writeI16(self.l2_metadata_same_if_check_mask)
      oprot.writeFieldEnd()
    if self.tunnel_metadata_tunnel_if_check is not None:
      oprot.writeFieldBegin('tunnel_metadata_tunnel_if_check', TType.BYTE, 39)
      oprot.writeByte(self.tunnel_metadata_tunnel_if_check)
      oprot.writeFieldEnd()
    if self.tunnel_metadata_tunnel_if_check_mask is not None:
      oprot.writeFieldBegin('tunnel_metadata_tunnel_if_check_mask', TType.BYTE, 40)
      oprot.writeByte(self.tunnel_metadata_tunnel_if_check_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_same_bd_check is not None:
      oprot.writeFieldBegin('l3_metadata_same_bd_check', TType.I16, 41)
      oprot.writeI16(self.l3_metadata_same_bd_check)
      oprot.writeFieldEnd()
    if self.l3_metadata_same_bd_check_mask is not None:
      oprot.writeFieldBegin('l3_metadata_same_bd_check_mask', TType.I16, 42)
      oprot.writeI16(self.l3_metadata_same_bd_check_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl', TType.BYTE, 43)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl_mask', TType.BYTE, 44)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl_mask)
      oprot.writeFieldEnd()
    if self.l2_metadata_stp_state is not None:
      oprot.writeFieldBegin('l2_metadata_stp_state', TType.BYTE, 45)
      oprot.writeByte(self.l2_metadata_stp_state)
      oprot.writeFieldEnd()
    if self.l2_metadata_stp_state_mask is not None:
      oprot.writeFieldBegin('l2_metadata_stp_state_mask', TType.BYTE, 46)
      oprot.writeByte(self.l2_metadata_stp_state_mask)
      oprot.writeFieldEnd()
    if self.ingress_metadata_control_frame is not None:
      oprot.writeFieldBegin('ingress_metadata_control_frame', TType.BYTE, 47)
      oprot.writeByte(self.ingress_metadata_control_frame)
      oprot.writeFieldEnd()
    if self.ingress_metadata_control_frame_mask is not None:
      oprot.writeFieldBegin('ingress_metadata_control_frame_mask', TType.BYTE, 48)
      oprot.writeByte(self.ingress_metadata_control_frame_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_ipv4_unicast_enabled is not None:
      oprot.writeFieldBegin('ipv4_metadata_ipv4_unicast_enabled', TType.BYTE, 49)
      oprot.writeByte(self.ipv4_metadata_ipv4_unicast_enabled)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_ipv4_unicast_enabled_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_ipv4_unicast_enabled_mask', TType.BYTE, 50)
      oprot.writeByte(self.ipv4_metadata_ipv4_unicast_enabled_mask)
      oprot.writeFieldEnd()
    if self.ingress_metadata_egress_ifindex is not None:
      oprot.writeFieldBegin('ingress_metadata_egress_ifindex', TType.I16, 51)
      oprot.writeI16(self.ingress_metadata_egress_ifindex)
      oprot.writeFieldEnd()
    if self.ingress_metadata_egress_ifindex_mask is not None:
      oprot.writeFieldBegin('ingress_metadata_egress_ifindex_mask', TType.I16, 52)
      oprot.writeI16(self.ingress_metadata_egress_ifindex_mask)
      oprot.writeFieldEnd()
    if self.ingress_metadata_enable_dod is not None:
      oprot.writeFieldBegin('ingress_metadata_enable_dod', TType.BYTE, 53)
      oprot.writeByte(self.ingress_metadata_enable_dod)
      oprot.writeFieldEnd()
    if self.ingress_metadata_enable_dod_mask is not None:
      oprot.writeFieldBegin('ingress_metadata_enable_dod_mask', TType.BYTE, 54)
      oprot.writeByte(self.ingress_metadata_enable_dod_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.acl_metadata_if_label is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_if_label is unset!')
    if self.acl_metadata_if_label_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_if_label_mask is unset!')
    if self.acl_metadata_bd_label is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label is unset!')
    if self.acl_metadata_bd_label_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label_mask is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa_mask is unset!')
    if self.ipv4_metadata_lkp_ipv4_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da is unset!')
    if self.ipv4_metadata_lkp_ipv4_da_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da_mask is unset!')
    if self.l3_metadata_lkp_ip_proto is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto is unset!')
    if self.l3_metadata_lkp_ip_proto_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto_mask is unset!')
    if self.l2_metadata_lkp_mac_sa is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_sa is unset!')
    if self.l2_metadata_lkp_mac_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_sa_mask is unset!')
    if self.l2_metadata_lkp_mac_da is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_da is unset!')
    if self.l2_metadata_lkp_mac_da_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_da_mask is unset!')
    if self.l2_metadata_lkp_mac_type is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_type is unset!')
    if self.l2_metadata_lkp_mac_type_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_type_mask is unset!')
    if self.ingress_metadata_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_ifindex is unset!')
    if self.ingress_metadata_ifindex_mask is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_ifindex_mask is unset!')
    if self.l2_metadata_port_vlan_mapping_miss is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_port_vlan_mapping_miss is unset!')
    if self.l2_metadata_port_vlan_mapping_miss_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_port_vlan_mapping_miss_mask is unset!')
    if self.security_metadata_ipsg_check_fail is None:
      raise TProtocol.TProtocolException(message='Required field security_metadata_ipsg_check_fail is unset!')
    if self.security_metadata_ipsg_check_fail_mask is None:
      raise TProtocol.TProtocolException(message='Required field security_metadata_ipsg_check_fail_mask is unset!')
    if self.acl_metadata_acl_deny is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_acl_deny is unset!')
    if self.acl_metadata_acl_deny_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_acl_deny_mask is unset!')
    if self.acl_metadata_racl_deny is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_racl_deny is unset!')
    if self.acl_metadata_racl_deny_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_racl_deny_mask is unset!')
    if self.l3_metadata_urpf_check_fail is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_urpf_check_fail is unset!')
    if self.l3_metadata_urpf_check_fail_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_urpf_check_fail_mask is unset!')
    if self.ingress_metadata_drop_flag is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_drop_flag is unset!')
    if self.ingress_metadata_drop_flag_mask is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_drop_flag_mask is unset!')
    if self.l3_metadata_rmac_hit is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_rmac_hit is unset!')
    if self.l3_metadata_rmac_hit_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_rmac_hit_mask is unset!')
    if self.l3_metadata_routed is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_routed is unset!')
    if self.l3_metadata_routed_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_routed_mask is unset!')
    if self.ipv6_metadata_ipv6_src_is_link_local is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_ipv6_src_is_link_local is unset!')
    if self.ipv6_metadata_ipv6_src_is_link_local_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv6_metadata_ipv6_src_is_link_local_mask is unset!')
    if self.l2_metadata_same_if_check is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_same_if_check is unset!')
    if self.l2_metadata_same_if_check_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_same_if_check_mask is unset!')
    if self.tunnel_metadata_tunnel_if_check is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_tunnel_if_check is unset!')
    if self.tunnel_metadata_tunnel_if_check_mask is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_tunnel_if_check_mask is unset!')
    if self.l3_metadata_same_bd_check is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_same_bd_check is unset!')
    if self.l3_metadata_same_bd_check_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_same_bd_check_mask is unset!')
    if self.l3_metadata_lkp_ip_ttl is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl is unset!')
    if self.l3_metadata_lkp_ip_ttl_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl_mask is unset!')
    if self.l2_metadata_stp_state is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_stp_state is unset!')
    if self.l2_metadata_stp_state_mask is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_stp_state_mask is unset!')
    if self.ingress_metadata_control_frame is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_control_frame is unset!')
    if self.ingress_metadata_control_frame_mask is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_control_frame_mask is unset!')
    if self.ipv4_metadata_ipv4_unicast_enabled is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_ipv4_unicast_enabled is unset!')
    if self.ipv4_metadata_ipv4_unicast_enabled_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_ipv4_unicast_enabled_mask is unset!')
    if self.ingress_metadata_egress_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_egress_ifindex is unset!')
    if self.ingress_metadata_egress_ifindex_mask is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_egress_ifindex_mask is unset!')
    if self.ingress_metadata_enable_dod is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_enable_dod is unset!')
    if self.ingress_metadata_enable_dod_mask is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_enable_dod_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.acl_metadata_if_label)
    value = (value * 31) ^ hash(self.acl_metadata_if_label_mask)
    value = (value * 31) ^ hash(self.acl_metadata_bd_label)
    value = (value * 31) ^ hash(self.acl_metadata_bd_label_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto_mask)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_sa)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_sa_mask)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_da)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_da_mask)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_type)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_type_mask)
    value = (value * 31) ^ hash(self.ingress_metadata_ifindex)
    value = (value * 31) ^ hash(self.ingress_metadata_ifindex_mask)
    value = (value * 31) ^ hash(self.l2_metadata_port_vlan_mapping_miss)
    value = (value * 31) ^ hash(self.l2_metadata_port_vlan_mapping_miss_mask)
    value = (value * 31) ^ hash(self.security_metadata_ipsg_check_fail)
    value = (value * 31) ^ hash(self.security_metadata_ipsg_check_fail_mask)
    value = (value * 31) ^ hash(self.acl_metadata_acl_deny)
    value = (value * 31) ^ hash(self.acl_metadata_acl_deny_mask)
    value = (value * 31) ^ hash(self.acl_metadata_racl_deny)
    value = (value * 31) ^ hash(self.acl_metadata_racl_deny_mask)
    value = (value * 31) ^ hash(self.l3_metadata_urpf_check_fail)
    value = (value * 31) ^ hash(self.l3_metadata_urpf_check_fail_mask)
    value = (value * 31) ^ hash(self.ingress_metadata_drop_flag)
    value = (value * 31) ^ hash(self.ingress_metadata_drop_flag_mask)
    value = (value * 31) ^ hash(self.l3_metadata_rmac_hit)
    value = (value * 31) ^ hash(self.l3_metadata_rmac_hit_mask)
    value = (value * 31) ^ hash(self.l3_metadata_routed)
    value = (value * 31) ^ hash(self.l3_metadata_routed_mask)
    value = (value * 31) ^ hash(self.ipv6_metadata_ipv6_src_is_link_local)
    value = (value * 31) ^ hash(self.ipv6_metadata_ipv6_src_is_link_local_mask)
    value = (value * 31) ^ hash(self.l2_metadata_same_if_check)
    value = (value * 31) ^ hash(self.l2_metadata_same_if_check_mask)
    value = (value * 31) ^ hash(self.tunnel_metadata_tunnel_if_check)
    value = (value * 31) ^ hash(self.tunnel_metadata_tunnel_if_check_mask)
    value = (value * 31) ^ hash(self.l3_metadata_same_bd_check)
    value = (value * 31) ^ hash(self.l3_metadata_same_bd_check_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl_mask)
    value = (value * 31) ^ hash(self.l2_metadata_stp_state)
    value = (value * 31) ^ hash(self.l2_metadata_stp_state_mask)
    value = (value * 31) ^ hash(self.ingress_metadata_control_frame)
    value = (value * 31) ^ hash(self.ingress_metadata_control_frame_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_ipv4_unicast_enabled)
    value = (value * 31) ^ hash(self.ipv4_metadata_ipv4_unicast_enabled_mask)
    value = (value * 31) ^ hash(self.ingress_metadata_egress_ifindex)
    value = (value * 31) ^ hash(self.ingress_metadata_egress_ifindex_mask)
    value = (value * 31) ^ hash(self.ingress_metadata_enable_dod)
    value = (value * 31) ^ hash(self.ingress_metadata_enable_dod_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_tunnel_dmac_rewrite_match_spec_t:
  """
  Attributes:
   - tunnel_metadata_tunnel_dmac_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'tunnel_metadata_tunnel_dmac_index', None, None, ), # 1
  )

  def __init__(self, tunnel_metadata_tunnel_dmac_index=None,):
    self.tunnel_metadata_tunnel_dmac_index = tunnel_metadata_tunnel_dmac_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.tunnel_metadata_tunnel_dmac_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_tunnel_dmac_rewrite_match_spec_t')
    if self.tunnel_metadata_tunnel_dmac_index is not None:
      oprot.writeFieldBegin('tunnel_metadata_tunnel_dmac_index', TType.I16, 1)
      oprot.writeI16(self.tunnel_metadata_tunnel_dmac_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tunnel_metadata_tunnel_dmac_index is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_tunnel_dmac_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tunnel_metadata_tunnel_dmac_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_compute_ipv6_hashes_match_spec_t:
  """
  Attributes:
   - ingress_metadata_drop_flag
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'ingress_metadata_drop_flag', None, None, ), # 1
  )

  def __init__(self, ingress_metadata_drop_flag=None,):
    self.ingress_metadata_drop_flag = ingress_metadata_drop_flag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.ingress_metadata_drop_flag = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_compute_ipv6_hashes_match_spec_t')
    if self.ingress_metadata_drop_flag is not None:
      oprot.writeFieldBegin('ingress_metadata_drop_flag', TType.BYTE, 1)
      oprot.writeByte(self.ingress_metadata_drop_flag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_drop_flag is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_drop_flag is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_drop_flag)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_bd_flood_match_spec_t:
  """
  Attributes:
   - ingress_metadata_bd
   - l2_metadata_lkp_pkt_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'ingress_metadata_bd', None, None, ), # 1
    (2, TType.BYTE, 'l2_metadata_lkp_pkt_type', None, None, ), # 2
  )

  def __init__(self, ingress_metadata_bd=None, l2_metadata_lkp_pkt_type=None,):
    self.ingress_metadata_bd = ingress_metadata_bd
    self.l2_metadata_lkp_pkt_type = l2_metadata_lkp_pkt_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.ingress_metadata_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.l2_metadata_lkp_pkt_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_bd_flood_match_spec_t')
    if self.ingress_metadata_bd is not None:
      oprot.writeFieldBegin('ingress_metadata_bd', TType.I16, 1)
      oprot.writeI16(self.ingress_metadata_bd)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_pkt_type is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_pkt_type', TType.BYTE, 2)
      oprot.writeByte(self.l2_metadata_lkp_pkt_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_bd is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_bd is unset!')
    if self.l2_metadata_lkp_pkt_type is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_pkt_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_bd)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_pkt_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_egress_vni_match_spec_t:
  """
  Attributes:
   - egress_metadata_bd
   - tunnel_metadata_egress_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'egress_metadata_bd', None, None, ), # 1
    (2, TType.BYTE, 'tunnel_metadata_egress_tunnel_type', None, None, ), # 2
  )

  def __init__(self, egress_metadata_bd=None, tunnel_metadata_egress_tunnel_type=None,):
    self.egress_metadata_bd = egress_metadata_bd
    self.tunnel_metadata_egress_tunnel_type = tunnel_metadata_egress_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.egress_metadata_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.tunnel_metadata_egress_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_egress_vni_match_spec_t')
    if self.egress_metadata_bd is not None:
      oprot.writeFieldBegin('egress_metadata_bd', TType.I16, 1)
      oprot.writeI16(self.egress_metadata_bd)
      oprot.writeFieldEnd()
    if self.tunnel_metadata_egress_tunnel_type is not None:
      oprot.writeFieldBegin('tunnel_metadata_egress_tunnel_type', TType.BYTE, 2)
      oprot.writeByte(self.tunnel_metadata_egress_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.egress_metadata_bd is None:
      raise TProtocol.TProtocolException(message='Required field egress_metadata_bd is unset!')
    if self.tunnel_metadata_egress_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_egress_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.egress_metadata_bd)
    value = (value * 31) ^ hash(self.tunnel_metadata_egress_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_tunnel_match_spec_t:
  """
  Attributes:
   - tunnel_metadata_tunnel_vni
   - tunnel_metadata_ingress_tunnel_type
   - inner_ipv4_valid
   - inner_ipv6_valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tunnel_metadata_tunnel_vni', None, None, ), # 1
    (2, TType.BYTE, 'tunnel_metadata_ingress_tunnel_type', None, None, ), # 2
    (3, TType.BYTE, 'inner_ipv4_valid', None, None, ), # 3
    (4, TType.BYTE, 'inner_ipv6_valid', None, None, ), # 4
  )

  def __init__(self, tunnel_metadata_tunnel_vni=None, tunnel_metadata_ingress_tunnel_type=None, inner_ipv4_valid=None, inner_ipv6_valid=None,):
    self.tunnel_metadata_tunnel_vni = tunnel_metadata_tunnel_vni
    self.tunnel_metadata_ingress_tunnel_type = tunnel_metadata_ingress_tunnel_type
    self.inner_ipv4_valid = inner_ipv4_valid
    self.inner_ipv6_valid = inner_ipv6_valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tunnel_metadata_tunnel_vni = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.tunnel_metadata_ingress_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.inner_ipv4_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.inner_ipv6_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_tunnel_match_spec_t')
    if self.tunnel_metadata_tunnel_vni is not None:
      oprot.writeFieldBegin('tunnel_metadata_tunnel_vni', TType.I32, 1)
      oprot.writeI32(self.tunnel_metadata_tunnel_vni)
      oprot.writeFieldEnd()
    if self.tunnel_metadata_ingress_tunnel_type is not None:
      oprot.writeFieldBegin('tunnel_metadata_ingress_tunnel_type', TType.BYTE, 2)
      oprot.writeByte(self.tunnel_metadata_ingress_tunnel_type)
      oprot.writeFieldEnd()
    if self.inner_ipv4_valid is not None:
      oprot.writeFieldBegin('inner_ipv4_valid', TType.BYTE, 3)
      oprot.writeByte(self.inner_ipv4_valid)
      oprot.writeFieldEnd()
    if self.inner_ipv6_valid is not None:
      oprot.writeFieldBegin('inner_ipv6_valid', TType.BYTE, 4)
      oprot.writeByte(self.inner_ipv6_valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tunnel_metadata_tunnel_vni is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_tunnel_vni is unset!')
    if self.tunnel_metadata_ingress_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_ingress_tunnel_type is unset!')
    if self.inner_ipv4_valid is None:
      raise TProtocol.TProtocolException(message='Required field inner_ipv4_valid is unset!')
    if self.inner_ipv6_valid is None:
      raise TProtocol.TProtocolException(message='Required field inner_ipv6_valid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tunnel_metadata_tunnel_vni)
    value = (value * 31) ^ hash(self.tunnel_metadata_ingress_tunnel_type)
    value = (value * 31) ^ hash(self.inner_ipv4_valid)
    value = (value * 31) ^ hash(self.inner_ipv6_valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_acl_stats_match_spec_t:
  """
  Attributes:
   - acl_metadata_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'acl_metadata_acl_stats_index', None, None, ), # 1
  )

  def __init__(self, acl_metadata_acl_stats_index=None,):
    self.acl_metadata_acl_stats_index = acl_metadata_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.acl_metadata_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_acl_stats_match_spec_t')
    if self.acl_metadata_acl_stats_index is not None:
      oprot.writeFieldBegin('acl_metadata_acl_stats_index', TType.I32, 1)
      oprot.writeI32(self.acl_metadata_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.acl_metadata_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.acl_metadata_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv4_urpf_lpm_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv4_metadata_lkp_ipv4_sa
   - ipv4_metadata_lkp_ipv4_sa_prefix_length
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.I32, 'ipv4_metadata_lkp_ipv4_sa', None, None, ), # 2
    (3, TType.I16, 'ipv4_metadata_lkp_ipv4_sa_prefix_length', None, None, ), # 3
  )

  def __init__(self, l3_metadata_vrf=None, ipv4_metadata_lkp_ipv4_sa=None, ipv4_metadata_lkp_ipv4_sa_prefix_length=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv4_metadata_lkp_ipv4_sa = ipv4_metadata_lkp_ipv4_sa
    self.ipv4_metadata_lkp_ipv4_sa_prefix_length = ipv4_metadata_lkp_ipv4_sa_prefix_length

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.ipv4_metadata_lkp_ipv4_sa_prefix_length = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv4_urpf_lpm_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa', TType.I32, 2)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa_prefix_length is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa_prefix_length', TType.I16, 3)
      oprot.writeI16(self.ipv4_metadata_lkp_ipv4_sa_prefix_length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa_prefix_length is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa_prefix_length is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa_prefix_length)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_int_inst_1215_match_spec_t:
  """
  Attributes:
   - int_header_instruction_mask_1215
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'int_header_instruction_mask_1215', None, None, ), # 1
  )

  def __init__(self, int_header_instruction_mask_1215=None,):
    self.int_header_instruction_mask_1215 = int_header_instruction_mask_1215

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_1215 = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_int_inst_1215_match_spec_t')
    if self.int_header_instruction_mask_1215 is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_1215', TType.BYTE, 1)
      oprot.writeByte(self.int_header_instruction_mask_1215)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.int_header_instruction_mask_1215 is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_1215 is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.int_header_instruction_mask_1215)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_mpls_match_spec_t:
  """
  Attributes:
   - tunnel_metadata_mpls_label
   - inner_ipv4_valid
   - inner_ipv6_valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tunnel_metadata_mpls_label', None, None, ), # 1
    (2, TType.BYTE, 'inner_ipv4_valid', None, None, ), # 2
    (3, TType.BYTE, 'inner_ipv6_valid', None, None, ), # 3
  )

  def __init__(self, tunnel_metadata_mpls_label=None, inner_ipv4_valid=None, inner_ipv6_valid=None,):
    self.tunnel_metadata_mpls_label = tunnel_metadata_mpls_label
    self.inner_ipv4_valid = inner_ipv4_valid
    self.inner_ipv6_valid = inner_ipv6_valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tunnel_metadata_mpls_label = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inner_ipv4_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.inner_ipv6_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_mpls_match_spec_t')
    if self.tunnel_metadata_mpls_label is not None:
      oprot.writeFieldBegin('tunnel_metadata_mpls_label', TType.I32, 1)
      oprot.writeI32(self.tunnel_metadata_mpls_label)
      oprot.writeFieldEnd()
    if self.inner_ipv4_valid is not None:
      oprot.writeFieldBegin('inner_ipv4_valid', TType.BYTE, 2)
      oprot.writeByte(self.inner_ipv4_valid)
      oprot.writeFieldEnd()
    if self.inner_ipv6_valid is not None:
      oprot.writeFieldBegin('inner_ipv6_valid', TType.BYTE, 3)
      oprot.writeByte(self.inner_ipv6_valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tunnel_metadata_mpls_label is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_mpls_label is unset!')
    if self.inner_ipv4_valid is None:
      raise TProtocol.TProtocolException(message='Required field inner_ipv4_valid is unset!')
    if self.inner_ipv6_valid is None:
      raise TProtocol.TProtocolException(message='Required field inner_ipv6_valid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tunnel_metadata_mpls_label)
    value = (value * 31) ^ hash(self.inner_ipv4_valid)
    value = (value * 31) ^ hash(self.inner_ipv6_valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv4_dest_vtep_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv4_metadata_lkp_ipv4_da
   - tunnel_metadata_ingress_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.I32, 'ipv4_metadata_lkp_ipv4_da', None, None, ), # 2
    (3, TType.BYTE, 'tunnel_metadata_ingress_tunnel_type', None, None, ), # 3
  )

  def __init__(self, l3_metadata_vrf=None, ipv4_metadata_lkp_ipv4_da=None, tunnel_metadata_ingress_tunnel_type=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv4_metadata_lkp_ipv4_da = ipv4_metadata_lkp_ipv4_da
    self.tunnel_metadata_ingress_tunnel_type = tunnel_metadata_ingress_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.tunnel_metadata_ingress_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv4_dest_vtep_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da', TType.I32, 2)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da)
      oprot.writeFieldEnd()
    if self.tunnel_metadata_ingress_tunnel_type is not None:
      oprot.writeFieldBegin('tunnel_metadata_ingress_tunnel_type', TType.BYTE, 3)
      oprot.writeByte(self.tunnel_metadata_ingress_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv4_metadata_lkp_ipv4_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da is unset!')
    if self.tunnel_metadata_ingress_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_ingress_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da)
    value = (value * 31) ^ hash(self.tunnel_metadata_ingress_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_fabric_ingress_src_lkp_match_spec_t:
  """
  Attributes:
   - fabric_header_multicast_ingressIfindex
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'fabric_header_multicast_ingressIfindex', None, None, ), # 1
  )

  def __init__(self, fabric_header_multicast_ingressIfindex=None,):
    self.fabric_header_multicast_ingressIfindex = fabric_header_multicast_ingressIfindex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.fabric_header_multicast_ingressIfindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_fabric_ingress_src_lkp_match_spec_t')
    if self.fabric_header_multicast_ingressIfindex is not None:
      oprot.writeFieldBegin('fabric_header_multicast_ingressIfindex', TType.I16, 1)
      oprot.writeI16(self.fabric_header_multicast_ingressIfindex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fabric_header_multicast_ingressIfindex is None:
      raise TProtocol.TProtocolException(message='Required field fabric_header_multicast_ingressIfindex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fabric_header_multicast_ingressIfindex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_int_insert_match_spec_t:
  """
  Attributes:
   - int_metadata_i2e_source
   - int_metadata_i2e_source_mask
   - int_metadata_i2e_sink
   - int_metadata_i2e_sink_mask
   - int_header_valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'int_metadata_i2e_source', None, None, ), # 1
    (2, TType.BYTE, 'int_metadata_i2e_source_mask', None, None, ), # 2
    (3, TType.BYTE, 'int_metadata_i2e_sink', None, None, ), # 3
    (4, TType.BYTE, 'int_metadata_i2e_sink_mask', None, None, ), # 4
    (5, TType.BYTE, 'int_header_valid', None, None, ), # 5
  )

  def __init__(self, int_metadata_i2e_source=None, int_metadata_i2e_source_mask=None, int_metadata_i2e_sink=None, int_metadata_i2e_sink_mask=None, int_header_valid=None,):
    self.int_metadata_i2e_source = int_metadata_i2e_source
    self.int_metadata_i2e_source_mask = int_metadata_i2e_source_mask
    self.int_metadata_i2e_sink = int_metadata_i2e_sink
    self.int_metadata_i2e_sink_mask = int_metadata_i2e_sink_mask
    self.int_header_valid = int_header_valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.int_metadata_i2e_source = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.int_metadata_i2e_source_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.int_metadata_i2e_sink = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.int_metadata_i2e_sink_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.int_header_valid = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_int_insert_match_spec_t')
    if self.int_metadata_i2e_source is not None:
      oprot.writeFieldBegin('int_metadata_i2e_source', TType.BYTE, 1)
      oprot.writeByte(self.int_metadata_i2e_source)
      oprot.writeFieldEnd()
    if self.int_metadata_i2e_source_mask is not None:
      oprot.writeFieldBegin('int_metadata_i2e_source_mask', TType.BYTE, 2)
      oprot.writeByte(self.int_metadata_i2e_source_mask)
      oprot.writeFieldEnd()
    if self.int_metadata_i2e_sink is not None:
      oprot.writeFieldBegin('int_metadata_i2e_sink', TType.BYTE, 3)
      oprot.writeByte(self.int_metadata_i2e_sink)
      oprot.writeFieldEnd()
    if self.int_metadata_i2e_sink_mask is not None:
      oprot.writeFieldBegin('int_metadata_i2e_sink_mask', TType.BYTE, 4)
      oprot.writeByte(self.int_metadata_i2e_sink_mask)
      oprot.writeFieldEnd()
    if self.int_header_valid is not None:
      oprot.writeFieldBegin('int_header_valid', TType.BYTE, 5)
      oprot.writeByte(self.int_header_valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.int_metadata_i2e_source is None:
      raise TProtocol.TProtocolException(message='Required field int_metadata_i2e_source is unset!')
    if self.int_metadata_i2e_source_mask is None:
      raise TProtocol.TProtocolException(message='Required field int_metadata_i2e_source_mask is unset!')
    if self.int_metadata_i2e_sink is None:
      raise TProtocol.TProtocolException(message='Required field int_metadata_i2e_sink is unset!')
    if self.int_metadata_i2e_sink_mask is None:
      raise TProtocol.TProtocolException(message='Required field int_metadata_i2e_sink_mask is unset!')
    if self.int_header_valid is None:
      raise TProtocol.TProtocolException(message='Required field int_header_valid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.int_metadata_i2e_source)
    value = (value * 31) ^ hash(self.int_metadata_i2e_source_mask)
    value = (value * 31) ^ hash(self.int_metadata_i2e_sink)
    value = (value * 31) ^ hash(self.int_metadata_i2e_sink_mask)
    value = (value * 31) ^ hash(self.int_header_valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_tunnel_smac_rewrite_match_spec_t:
  """
  Attributes:
   - tunnel_metadata_tunnel_smac_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'tunnel_metadata_tunnel_smac_index', None, None, ), # 1
  )

  def __init__(self, tunnel_metadata_tunnel_smac_index=None,):
    self.tunnel_metadata_tunnel_smac_index = tunnel_metadata_tunnel_smac_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.tunnel_metadata_tunnel_smac_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_tunnel_smac_rewrite_match_spec_t')
    if self.tunnel_metadata_tunnel_smac_index is not None:
      oprot.writeFieldBegin('tunnel_metadata_tunnel_smac_index', TType.I16, 1)
      oprot.writeI16(self.tunnel_metadata_tunnel_smac_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tunnel_metadata_tunnel_smac_index is None:
      raise TProtocol.TProtocolException(message='Required field tunnel_metadata_tunnel_smac_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tunnel_metadata_tunnel_smac_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv4_urpf_match_spec_t:
  """
  Attributes:
   - l3_metadata_vrf
   - ipv4_metadata_lkp_ipv4_sa
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_vrf', None, None, ), # 1
    (2, TType.I32, 'ipv4_metadata_lkp_ipv4_sa', None, None, ), # 2
  )

  def __init__(self, l3_metadata_vrf=None, ipv4_metadata_lkp_ipv4_sa=None,):
    self.l3_metadata_vrf = l3_metadata_vrf
    self.ipv4_metadata_lkp_ipv4_sa = ipv4_metadata_lkp_ipv4_sa

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv4_urpf_match_spec_t')
    if self.l3_metadata_vrf is not None:
      oprot.writeFieldBegin('l3_metadata_vrf', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_vrf)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa', TType.I32, 2)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_vrf is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_vrf is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_vrf)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_fabric_lag_match_spec_t:
  """
  Attributes:
   - fabric_metadata_dst_device
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'fabric_metadata_dst_device', None, None, ), # 1
  )

  def __init__(self, fabric_metadata_dst_device=None,):
    self.fabric_metadata_dst_device = fabric_metadata_dst_device

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.fabric_metadata_dst_device = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_fabric_lag_match_spec_t')
    if self.fabric_metadata_dst_device is not None:
      oprot.writeFieldBegin('fabric_metadata_dst_device', TType.BYTE, 1)
      oprot.writeByte(self.fabric_metadata_dst_device)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fabric_metadata_dst_device is None:
      raise TProtocol.TProtocolException(message='Required field fabric_metadata_dst_device is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fabric_metadata_dst_device)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_int_meta_header_update_match_spec_t:
  """
  Attributes:
   - int_metadata_insert_cnt
   - int_metadata_insert_cnt_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'int_metadata_insert_cnt', None, None, ), # 1
    (2, TType.BYTE, 'int_metadata_insert_cnt_mask', None, None, ), # 2
  )

  def __init__(self, int_metadata_insert_cnt=None, int_metadata_insert_cnt_mask=None,):
    self.int_metadata_insert_cnt = int_metadata_insert_cnt
    self.int_metadata_insert_cnt_mask = int_metadata_insert_cnt_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.int_metadata_insert_cnt = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.int_metadata_insert_cnt_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_int_meta_header_update_match_spec_t')
    if self.int_metadata_insert_cnt is not None:
      oprot.writeFieldBegin('int_metadata_insert_cnt', TType.BYTE, 1)
      oprot.writeByte(self.int_metadata_insert_cnt)
      oprot.writeFieldEnd()
    if self.int_metadata_insert_cnt_mask is not None:
      oprot.writeFieldBegin('int_metadata_insert_cnt_mask', TType.BYTE, 2)
      oprot.writeByte(self.int_metadata_insert_cnt_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.int_metadata_insert_cnt is None:
      raise TProtocol.TProtocolException(message='Required field int_metadata_insert_cnt is unset!')
    if self.int_metadata_insert_cnt_mask is None:
      raise TProtocol.TProtocolException(message='Required field int_metadata_insert_cnt_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.int_metadata_insert_cnt)
    value = (value * 31) ^ hash(self.int_metadata_insert_cnt_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipsg_permit_special_match_spec_t:
  """
  Attributes:
   - l3_metadata_lkp_ip_proto
   - l3_metadata_lkp_ip_proto_mask
   - l3_metadata_lkp_l4_dport
   - l3_metadata_lkp_l4_dport_mask
   - ipv4_metadata_lkp_ipv4_da
   - ipv4_metadata_lkp_ipv4_da_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'l3_metadata_lkp_ip_proto', None, None, ), # 1
    (2, TType.BYTE, 'l3_metadata_lkp_ip_proto_mask', None, None, ), # 2
    (3, TType.I16, 'l3_metadata_lkp_l4_dport', None, None, ), # 3
    (4, TType.I16, 'l3_metadata_lkp_l4_dport_mask', None, None, ), # 4
    (5, TType.I32, 'ipv4_metadata_lkp_ipv4_da', None, None, ), # 5
    (6, TType.I32, 'ipv4_metadata_lkp_ipv4_da_mask', None, None, ), # 6
  )

  def __init__(self, l3_metadata_lkp_ip_proto=None, l3_metadata_lkp_ip_proto_mask=None, l3_metadata_lkp_l4_dport=None, l3_metadata_lkp_l4_dport_mask=None, ipv4_metadata_lkp_ipv4_da=None, ipv4_metadata_lkp_ipv4_da_mask=None,):
    self.l3_metadata_lkp_ip_proto = l3_metadata_lkp_ip_proto
    self.l3_metadata_lkp_ip_proto_mask = l3_metadata_lkp_ip_proto_mask
    self.l3_metadata_lkp_l4_dport = l3_metadata_lkp_l4_dport
    self.l3_metadata_lkp_l4_dport_mask = l3_metadata_lkp_l4_dport_mask
    self.ipv4_metadata_lkp_ipv4_da = ipv4_metadata_lkp_ipv4_da
    self.ipv4_metadata_lkp_ipv4_da_mask = ipv4_metadata_lkp_ipv4_da_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_dport = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_dport_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipsg_permit_special_match_spec_t')
    if self.l3_metadata_lkp_ip_proto is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto', TType.BYTE, 1)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto_mask', TType.BYTE, 2)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_dport is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_dport', TType.I16, 3)
      oprot.writeI16(self.l3_metadata_lkp_l4_dport)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_dport_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_dport_mask', TType.I16, 4)
      oprot.writeI16(self.l3_metadata_lkp_l4_dport_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da', TType.I32, 5)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da_mask', TType.I32, 6)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_lkp_ip_proto is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto is unset!')
    if self.l3_metadata_lkp_ip_proto_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto_mask is unset!')
    if self.l3_metadata_lkp_l4_dport is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_dport is unset!')
    if self.l3_metadata_lkp_l4_dport_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_dport_mask is unset!')
    if self.ipv4_metadata_lkp_ipv4_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da is unset!')
    if self.ipv4_metadata_lkp_ipv4_da_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_dport)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_dport_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv4_racl_match_spec_t:
  """
  Attributes:
   - acl_metadata_bd_label
   - acl_metadata_bd_label_mask
   - ipv4_metadata_lkp_ipv4_sa
   - ipv4_metadata_lkp_ipv4_sa_mask
   - ipv4_metadata_lkp_ipv4_da
   - ipv4_metadata_lkp_ipv4_da_mask
   - l3_metadata_lkp_ip_proto
   - l3_metadata_lkp_ip_proto_mask
   - l3_metadata_lkp_l4_sport
   - l3_metadata_lkp_l4_sport_mask
   - l3_metadata_lkp_l4_dport
   - l3_metadata_lkp_l4_dport_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'acl_metadata_bd_label', None, None, ), # 1
    (2, TType.I16, 'acl_metadata_bd_label_mask', None, None, ), # 2
    (3, TType.I32, 'ipv4_metadata_lkp_ipv4_sa', None, None, ), # 3
    (4, TType.I32, 'ipv4_metadata_lkp_ipv4_sa_mask', None, None, ), # 4
    (5, TType.I32, 'ipv4_metadata_lkp_ipv4_da', None, None, ), # 5
    (6, TType.I32, 'ipv4_metadata_lkp_ipv4_da_mask', None, None, ), # 6
    (7, TType.BYTE, 'l3_metadata_lkp_ip_proto', None, None, ), # 7
    (8, TType.BYTE, 'l3_metadata_lkp_ip_proto_mask', None, None, ), # 8
    (9, TType.I16, 'l3_metadata_lkp_l4_sport', None, None, ), # 9
    (10, TType.I16, 'l3_metadata_lkp_l4_sport_mask', None, None, ), # 10
    (11, TType.I16, 'l3_metadata_lkp_l4_dport', None, None, ), # 11
    (12, TType.I16, 'l3_metadata_lkp_l4_dport_mask', None, None, ), # 12
  )

  def __init__(self, acl_metadata_bd_label=None, acl_metadata_bd_label_mask=None, ipv4_metadata_lkp_ipv4_sa=None, ipv4_metadata_lkp_ipv4_sa_mask=None, ipv4_metadata_lkp_ipv4_da=None, ipv4_metadata_lkp_ipv4_da_mask=None, l3_metadata_lkp_ip_proto=None, l3_metadata_lkp_ip_proto_mask=None, l3_metadata_lkp_l4_sport=None, l3_metadata_lkp_l4_sport_mask=None, l3_metadata_lkp_l4_dport=None, l3_metadata_lkp_l4_dport_mask=None,):
    self.acl_metadata_bd_label = acl_metadata_bd_label
    self.acl_metadata_bd_label_mask = acl_metadata_bd_label_mask
    self.ipv4_metadata_lkp_ipv4_sa = ipv4_metadata_lkp_ipv4_sa
    self.ipv4_metadata_lkp_ipv4_sa_mask = ipv4_metadata_lkp_ipv4_sa_mask
    self.ipv4_metadata_lkp_ipv4_da = ipv4_metadata_lkp_ipv4_da
    self.ipv4_metadata_lkp_ipv4_da_mask = ipv4_metadata_lkp_ipv4_da_mask
    self.l3_metadata_lkp_ip_proto = l3_metadata_lkp_ip_proto
    self.l3_metadata_lkp_ip_proto_mask = l3_metadata_lkp_ip_proto_mask
    self.l3_metadata_lkp_l4_sport = l3_metadata_lkp_l4_sport
    self.l3_metadata_lkp_l4_sport_mask = l3_metadata_lkp_l4_sport_mask
    self.l3_metadata_lkp_l4_dport = l3_metadata_lkp_l4_dport
    self.l3_metadata_lkp_l4_dport_mask = l3_metadata_lkp_l4_dport_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.acl_metadata_bd_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.acl_metadata_bd_label_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_sport = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_sport_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_dport = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_dport_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv4_racl_match_spec_t')
    if self.acl_metadata_bd_label is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label', TType.I16, 1)
      oprot.writeI16(self.acl_metadata_bd_label)
      oprot.writeFieldEnd()
    if self.acl_metadata_bd_label_mask is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label_mask', TType.I16, 2)
      oprot.writeI16(self.acl_metadata_bd_label_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa', TType.I32, 3)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa_mask', TType.I32, 4)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da', TType.I32, 5)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da_mask', TType.I32, 6)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto', TType.BYTE, 7)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto_mask', TType.BYTE, 8)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_sport is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_sport', TType.I16, 9)
      oprot.writeI16(self.l3_metadata_lkp_l4_sport)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_sport_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_sport_mask', TType.I16, 10)
      oprot.writeI16(self.l3_metadata_lkp_l4_sport_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_dport is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_dport', TType.I16, 11)
      oprot.writeI16(self.l3_metadata_lkp_l4_dport)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_dport_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_dport_mask', TType.I16, 12)
      oprot.writeI16(self.l3_metadata_lkp_l4_dport_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.acl_metadata_bd_label is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label is unset!')
    if self.acl_metadata_bd_label_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label_mask is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa_mask is unset!')
    if self.ipv4_metadata_lkp_ipv4_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da is unset!')
    if self.ipv4_metadata_lkp_ipv4_da_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da_mask is unset!')
    if self.l3_metadata_lkp_ip_proto is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto is unset!')
    if self.l3_metadata_lkp_ip_proto_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto_mask is unset!')
    if self.l3_metadata_lkp_l4_sport is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_sport is unset!')
    if self.l3_metadata_lkp_l4_sport_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_sport_mask is unset!')
    if self.l3_metadata_lkp_l4_dport is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_dport is unset!')
    if self.l3_metadata_lkp_l4_dport_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_dport_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.acl_metadata_bd_label)
    value = (value * 31) ^ hash(self.acl_metadata_bd_label_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_sport)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_sport_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_dport)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_dport_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ip_acl_match_spec_t:
  """
  Attributes:
   - acl_metadata_if_label
   - acl_metadata_if_label_mask
   - acl_metadata_bd_label
   - acl_metadata_bd_label_mask
   - ipv4_metadata_lkp_ipv4_sa
   - ipv4_metadata_lkp_ipv4_sa_mask
   - ipv4_metadata_lkp_ipv4_da
   - ipv4_metadata_lkp_ipv4_da_mask
   - l3_metadata_lkp_ip_proto
   - l3_metadata_lkp_ip_proto_mask
   - l3_metadata_lkp_l4_sport
   - l3_metadata_lkp_l4_sport_mask
   - l3_metadata_lkp_l4_dport
   - l3_metadata_lkp_l4_dport_mask
   - tcp_flags
   - tcp_flags_mask
   - l3_metadata_lkp_ip_ttl
   - l3_metadata_lkp_ip_ttl_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'acl_metadata_if_label', None, None, ), # 1
    (2, TType.I16, 'acl_metadata_if_label_mask', None, None, ), # 2
    (3, TType.I16, 'acl_metadata_bd_label', None, None, ), # 3
    (4, TType.I16, 'acl_metadata_bd_label_mask', None, None, ), # 4
    (5, TType.I32, 'ipv4_metadata_lkp_ipv4_sa', None, None, ), # 5
    (6, TType.I32, 'ipv4_metadata_lkp_ipv4_sa_mask', None, None, ), # 6
    (7, TType.I32, 'ipv4_metadata_lkp_ipv4_da', None, None, ), # 7
    (8, TType.I32, 'ipv4_metadata_lkp_ipv4_da_mask', None, None, ), # 8
    (9, TType.BYTE, 'l3_metadata_lkp_ip_proto', None, None, ), # 9
    (10, TType.BYTE, 'l3_metadata_lkp_ip_proto_mask', None, None, ), # 10
    (11, TType.I16, 'l3_metadata_lkp_l4_sport', None, None, ), # 11
    (12, TType.I16, 'l3_metadata_lkp_l4_sport_mask', None, None, ), # 12
    (13, TType.I16, 'l3_metadata_lkp_l4_dport', None, None, ), # 13
    (14, TType.I16, 'l3_metadata_lkp_l4_dport_mask', None, None, ), # 14
    (15, TType.BYTE, 'tcp_flags', None, None, ), # 15
    (16, TType.BYTE, 'tcp_flags_mask', None, None, ), # 16
    (17, TType.BYTE, 'l3_metadata_lkp_ip_ttl', None, None, ), # 17
    (18, TType.BYTE, 'l3_metadata_lkp_ip_ttl_mask', None, None, ), # 18
  )

  def __init__(self, acl_metadata_if_label=None, acl_metadata_if_label_mask=None, acl_metadata_bd_label=None, acl_metadata_bd_label_mask=None, ipv4_metadata_lkp_ipv4_sa=None, ipv4_metadata_lkp_ipv4_sa_mask=None, ipv4_metadata_lkp_ipv4_da=None, ipv4_metadata_lkp_ipv4_da_mask=None, l3_metadata_lkp_ip_proto=None, l3_metadata_lkp_ip_proto_mask=None, l3_metadata_lkp_l4_sport=None, l3_metadata_lkp_l4_sport_mask=None, l3_metadata_lkp_l4_dport=None, l3_metadata_lkp_l4_dport_mask=None, tcp_flags=None, tcp_flags_mask=None, l3_metadata_lkp_ip_ttl=None, l3_metadata_lkp_ip_ttl_mask=None,):
    self.acl_metadata_if_label = acl_metadata_if_label
    self.acl_metadata_if_label_mask = acl_metadata_if_label_mask
    self.acl_metadata_bd_label = acl_metadata_bd_label
    self.acl_metadata_bd_label_mask = acl_metadata_bd_label_mask
    self.ipv4_metadata_lkp_ipv4_sa = ipv4_metadata_lkp_ipv4_sa
    self.ipv4_metadata_lkp_ipv4_sa_mask = ipv4_metadata_lkp_ipv4_sa_mask
    self.ipv4_metadata_lkp_ipv4_da = ipv4_metadata_lkp_ipv4_da
    self.ipv4_metadata_lkp_ipv4_da_mask = ipv4_metadata_lkp_ipv4_da_mask
    self.l3_metadata_lkp_ip_proto = l3_metadata_lkp_ip_proto
    self.l3_metadata_lkp_ip_proto_mask = l3_metadata_lkp_ip_proto_mask
    self.l3_metadata_lkp_l4_sport = l3_metadata_lkp_l4_sport
    self.l3_metadata_lkp_l4_sport_mask = l3_metadata_lkp_l4_sport_mask
    self.l3_metadata_lkp_l4_dport = l3_metadata_lkp_l4_dport
    self.l3_metadata_lkp_l4_dport_mask = l3_metadata_lkp_l4_dport_mask
    self.tcp_flags = tcp_flags
    self.tcp_flags_mask = tcp_flags_mask
    self.l3_metadata_lkp_ip_ttl = l3_metadata_lkp_ip_ttl
    self.l3_metadata_lkp_ip_ttl_mask = l3_metadata_lkp_ip_ttl_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.acl_metadata_if_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.acl_metadata_if_label_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.acl_metadata_bd_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.acl_metadata_bd_label_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_da_mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_proto_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_sport = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_sport_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_dport = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I16:
          self.l3_metadata_lkp_l4_dport_mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BYTE:
          self.tcp_flags = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BYTE:
          self.tcp_flags_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.BYTE:
          self.l3_metadata_lkp_ip_ttl_mask = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ip_acl_match_spec_t')
    if self.acl_metadata_if_label is not None:
      oprot.writeFieldBegin('acl_metadata_if_label', TType.I16, 1)
      oprot.writeI16(self.acl_metadata_if_label)
      oprot.writeFieldEnd()
    if self.acl_metadata_if_label_mask is not None:
      oprot.writeFieldBegin('acl_metadata_if_label_mask', TType.I16, 2)
      oprot.writeI16(self.acl_metadata_if_label_mask)
      oprot.writeFieldEnd()
    if self.acl_metadata_bd_label is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label', TType.I16, 3)
      oprot.writeI16(self.acl_metadata_bd_label)
      oprot.writeFieldEnd()
    if self.acl_metadata_bd_label_mask is not None:
      oprot.writeFieldBegin('acl_metadata_bd_label_mask', TType.I16, 4)
      oprot.writeI16(self.acl_metadata_bd_label_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa', TType.I32, 5)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa_mask', TType.I32, 6)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa_mask)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da', TType.I32, 7)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_da_mask is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_da_mask', TType.I32, 8)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_da_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto', TType.BYTE, 9)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_proto_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_proto_mask', TType.BYTE, 10)
      oprot.writeByte(self.l3_metadata_lkp_ip_proto_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_sport is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_sport', TType.I16, 11)
      oprot.writeI16(self.l3_metadata_lkp_l4_sport)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_sport_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_sport_mask', TType.I16, 12)
      oprot.writeI16(self.l3_metadata_lkp_l4_sport_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_dport is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_dport', TType.I16, 13)
      oprot.writeI16(self.l3_metadata_lkp_l4_dport)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_l4_dport_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_l4_dport_mask', TType.I16, 14)
      oprot.writeI16(self.l3_metadata_lkp_l4_dport_mask)
      oprot.writeFieldEnd()
    if self.tcp_flags is not None:
      oprot.writeFieldBegin('tcp_flags', TType.BYTE, 15)
      oprot.writeByte(self.tcp_flags)
      oprot.writeFieldEnd()
    if self.tcp_flags_mask is not None:
      oprot.writeFieldBegin('tcp_flags_mask', TType.BYTE, 16)
      oprot.writeByte(self.tcp_flags_mask)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl', TType.BYTE, 17)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl)
      oprot.writeFieldEnd()
    if self.l3_metadata_lkp_ip_ttl_mask is not None:
      oprot.writeFieldBegin('l3_metadata_lkp_ip_ttl_mask', TType.BYTE, 18)
      oprot.writeByte(self.l3_metadata_lkp_ip_ttl_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.acl_metadata_if_label is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_if_label is unset!')
    if self.acl_metadata_if_label_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_if_label_mask is unset!')
    if self.acl_metadata_bd_label is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label is unset!')
    if self.acl_metadata_bd_label_mask is None:
      raise TProtocol.TProtocolException(message='Required field acl_metadata_bd_label_mask is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa_mask is unset!')
    if self.ipv4_metadata_lkp_ipv4_da is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da is unset!')
    if self.ipv4_metadata_lkp_ipv4_da_mask is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_da_mask is unset!')
    if self.l3_metadata_lkp_ip_proto is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto is unset!')
    if self.l3_metadata_lkp_ip_proto_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_proto_mask is unset!')
    if self.l3_metadata_lkp_l4_sport is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_sport is unset!')
    if self.l3_metadata_lkp_l4_sport_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_sport_mask is unset!')
    if self.l3_metadata_lkp_l4_dport is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_dport is unset!')
    if self.l3_metadata_lkp_l4_dport_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_l4_dport_mask is unset!')
    if self.tcp_flags is None:
      raise TProtocol.TProtocolException(message='Required field tcp_flags is unset!')
    if self.tcp_flags_mask is None:
      raise TProtocol.TProtocolException(message='Required field tcp_flags_mask is unset!')
    if self.l3_metadata_lkp_ip_ttl is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl is unset!')
    if self.l3_metadata_lkp_ip_ttl_mask is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_lkp_ip_ttl_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.acl_metadata_if_label)
    value = (value * 31) ^ hash(self.acl_metadata_if_label_mask)
    value = (value * 31) ^ hash(self.acl_metadata_bd_label)
    value = (value * 31) ^ hash(self.acl_metadata_bd_label_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa_mask)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_da_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_proto_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_sport)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_sport_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_dport)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_l4_dport_mask)
    value = (value * 31) ^ hash(self.tcp_flags)
    value = (value * 31) ^ hash(self.tcp_flags_mask)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl)
    value = (value * 31) ^ hash(self.l3_metadata_lkp_ip_ttl_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_outer_rmac_match_spec_t:
  """
  Attributes:
   - l3_metadata_rmac_group
   - l2_metadata_lkp_mac_da
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'l3_metadata_rmac_group', None, None, ), # 1
    (2, TType.STRING, 'l2_metadata_lkp_mac_da', None, None, ), # 2
  )

  def __init__(self, l3_metadata_rmac_group=None, l2_metadata_lkp_mac_da=None,):
    self.l3_metadata_rmac_group = l3_metadata_rmac_group
    self.l2_metadata_lkp_mac_da = l2_metadata_lkp_mac_da

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.l3_metadata_rmac_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_da = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_outer_rmac_match_spec_t')
    if self.l3_metadata_rmac_group is not None:
      oprot.writeFieldBegin('l3_metadata_rmac_group', TType.I16, 1)
      oprot.writeI16(self.l3_metadata_rmac_group)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_da is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_da', TType.STRING, 2)
      oprot.writeString(self.l2_metadata_lkp_mac_da)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.l3_metadata_rmac_group is None:
      raise TProtocol.TProtocolException(message='Required field l3_metadata_rmac_group is unset!')
    if self.l2_metadata_lkp_mac_da is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_da is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.l3_metadata_rmac_group)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_da)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_int_inst_0811_match_spec_t:
  """
  Attributes:
   - int_header_instruction_mask_0811
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'int_header_instruction_mask_0811', None, None, ), # 1
  )

  def __init__(self, int_header_instruction_mask_0811=None,):
    self.int_header_instruction_mask_0811 = int_header_instruction_mask_0811

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.int_header_instruction_mask_0811 = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_int_inst_0811_match_spec_t')
    if self.int_header_instruction_mask_0811 is not None:
      oprot.writeFieldBegin('int_header_instruction_mask_0811', TType.BYTE, 1)
      oprot.writeByte(self.int_header_instruction_mask_0811)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.int_header_instruction_mask_0811 is None:
      raise TProtocol.TProtocolException(message='Required field int_header_instruction_mask_0811 is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.int_header_instruction_mask_0811)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipsg_match_spec_t:
  """
  Attributes:
   - ingress_metadata_ifindex
   - ingress_metadata_bd
   - l2_metadata_lkp_mac_sa
   - ipv4_metadata_lkp_ipv4_sa
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'ingress_metadata_ifindex', None, None, ), # 1
    (2, TType.I16, 'ingress_metadata_bd', None, None, ), # 2
    (3, TType.STRING, 'l2_metadata_lkp_mac_sa', None, None, ), # 3
    (4, TType.I32, 'ipv4_metadata_lkp_ipv4_sa', None, None, ), # 4
  )

  def __init__(self, ingress_metadata_ifindex=None, ingress_metadata_bd=None, l2_metadata_lkp_mac_sa=None, ipv4_metadata_lkp_ipv4_sa=None,):
    self.ingress_metadata_ifindex = ingress_metadata_ifindex
    self.ingress_metadata_bd = ingress_metadata_bd
    self.l2_metadata_lkp_mac_sa = l2_metadata_lkp_mac_sa
    self.ipv4_metadata_lkp_ipv4_sa = ipv4_metadata_lkp_ipv4_sa

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.ingress_metadata_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.ingress_metadata_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.l2_metadata_lkp_mac_sa = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.ipv4_metadata_lkp_ipv4_sa = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipsg_match_spec_t')
    if self.ingress_metadata_ifindex is not None:
      oprot.writeFieldBegin('ingress_metadata_ifindex', TType.I16, 1)
      oprot.writeI16(self.ingress_metadata_ifindex)
      oprot.writeFieldEnd()
    if self.ingress_metadata_bd is not None:
      oprot.writeFieldBegin('ingress_metadata_bd', TType.I16, 2)
      oprot.writeI16(self.ingress_metadata_bd)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_sa is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_sa', TType.STRING, 3)
      oprot.writeString(self.l2_metadata_lkp_mac_sa)
      oprot.writeFieldEnd()
    if self.ipv4_metadata_lkp_ipv4_sa is not None:
      oprot.writeFieldBegin('ipv4_metadata_lkp_ipv4_sa', TType.I32, 4)
      oprot.writeI32(self.ipv4_metadata_lkp_ipv4_sa)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_ifindex is unset!')
    if self.ingress_metadata_bd is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_bd is unset!')
    if self.l2_metadata_lkp_mac_sa is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_sa is unset!')
    if self.ipv4_metadata_lkp_ipv4_sa is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_metadata_lkp_ipv4_sa is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_ifindex)
    value = (value * 31) ^ hash(self.ingress_metadata_bd)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_sa)
    value = (value * 31) ^ hash(self.ipv4_metadata_lkp_ipv4_sa)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_smac_hit_action_spec_t:
  """
  Attributes:
   - action_ifindex
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_ifindex', None, None, ), # 1
  )

  def __init__(self, action_ifindex=None,):
    self.action_ifindex = action_ifindex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_smac_hit_action_spec_t')
    if self.action_ifindex is not None:
      oprot.writeFieldBegin('action_ifindex', TType.I16, 1)
      oprot.writeI16(self.action_ifindex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field action_ifindex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ifindex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_redirect_to_cpu_action_spec_t:
  """
  Attributes:
   - action_reason_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_reason_code', None, None, ), # 1
  )

  def __init__(self, action_reason_code=None,):
    self.action_reason_code = action_reason_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_reason_code = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_redirect_to_cpu_action_spec_t')
    if self.action_reason_code is not None:
      oprot.writeFieldBegin('action_reason_code', TType.I16, 1)
      oprot.writeI16(self.action_reason_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_reason_code is None:
      raise TProtocol.TProtocolException(message='Required field action_reason_code is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_reason_code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_tunnel_ipv4_dst_action_spec_t:
  """
  Attributes:
   - action_ip
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_ip', None, None, ), # 1
  )

  def __init__(self, action_ip=None,):
    self.action_ip = action_ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_ip = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_tunnel_ipv4_dst_action_spec_t')
    if self.action_ip is not None:
      oprot.writeFieldBegin('action_ip', TType.I32, 1)
      oprot.writeI32(self.action_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ip is None:
      raise TProtocol.TProtocolException(message='Required field action_ip is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ip)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_tunnel_ipv6_src_action_spec_t:
  """
  Attributes:
   - action_ip
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_ip', None, None, ), # 1
  )

  def __init__(self, action_ip=None,):
    self.action_ip = action_ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_ip = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_tunnel_ipv6_src_action_spec_t')
    if self.action_ip is not None:
      oprot.writeFieldBegin('action_ip', TType.STRING, 1)
      oprot.writeString(self.action_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ip is None:
      raise TProtocol.TProtocolException(message='Required field action_ip is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ip)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_egress_ifindex_action_spec_t:
  """
  Attributes:
   - action_egress_ifindex
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_egress_ifindex', None, None, ), # 1
  )

  def __init__(self, action_egress_ifindex=None,):
    self.action_egress_ifindex = action_egress_ifindex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_egress_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_egress_ifindex_action_spec_t')
    if self.action_egress_ifindex is not None:
      oprot.writeFieldBegin('action_egress_ifindex', TType.I16, 1)
      oprot.writeI16(self.action_egress_ifindex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_egress_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field action_egress_ifindex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_egress_ifindex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_int_transit_action_spec_t:
  """
  Attributes:
   - action_switch_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switch_id', None, None, ), # 1
  )

  def __init__(self, action_switch_id=None,):
    self.action_switch_id = action_switch_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switch_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_int_transit_action_spec_t')
    if self.action_switch_id is not None:
      oprot.writeFieldBegin('action_switch_id', TType.I32, 1)
      oprot.writeI32(self.action_switch_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switch_id is None:
      raise TProtocol.TProtocolException(message='Required field action_switch_id is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switch_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_apply_cos_marking_action_spec_t:
  """
  Attributes:
   - action_cos
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'action_cos', None, None, ), # 1
  )

  def __init__(self, action_cos=None,):
    self.action_cos = action_cos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.action_cos = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_apply_cos_marking_action_spec_t')
    if self.action_cos is not None:
      oprot.writeFieldBegin('action_cos', TType.BYTE, 1)
      oprot.writeByte(self.action_cos)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_cos is None:
      raise TProtocol.TProtocolException(message='Required field action_cos is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_cos)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_l2_rewrite_with_tunnel_action_spec_t:
  """
  Attributes:
   - action_tunnel_index
   - action_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_tunnel_index', None, None, ), # 1
    (2, TType.BYTE, 'action_tunnel_type', None, None, ), # 2
  )

  def __init__(self, action_tunnel_index=None, action_tunnel_type=None,):
    self.action_tunnel_index = action_tunnel_index
    self.action_tunnel_type = action_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_l2_rewrite_with_tunnel_action_spec_t')
    if self.action_tunnel_index is not None:
      oprot.writeFieldBegin('action_tunnel_index', TType.I16, 1)
      oprot.writeI16(self.action_tunnel_index)
      oprot.writeFieldEnd()
    if self.action_tunnel_type is not None:
      oprot.writeFieldBegin('action_tunnel_type', TType.BYTE, 2)
      oprot.writeByte(self.action_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_index is unset!')
    if self.action_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_tunnel_index)
    value = (value * 31) ^ hash(self.action_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_nexthop_details_for_post_routed_flood_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_uuc_mc_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_uuc_mc_index', None, None, ), # 2
  )

  def __init__(self, action_bd=None, action_uuc_mc_index=None,):
    self.action_bd = action_bd
    self.action_uuc_mc_index = action_uuc_mc_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_uuc_mc_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_nexthop_details_for_post_routed_flood_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_uuc_mc_index is not None:
      oprot.writeFieldBegin('action_uuc_mc_index', TType.I16, 2)
      oprot.writeI16(self.action_uuc_mc_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_uuc_mc_index is None:
      raise TProtocol.TProtocolException(message='Required field action_uuc_mc_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_uuc_mc_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_terminate_tunnel_inner_ipv4_action_spec_t:
  """
  Attributes:
   - action_vrf
   - action_rmac_group
   - action_ipv4_urpf_mode
   - action_ipv4_unicast_enabled
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_vrf', None, None, ), # 1
    (2, TType.I16, 'action_rmac_group', None, None, ), # 2
    (3, TType.BYTE, 'action_ipv4_urpf_mode', None, None, ), # 3
    (4, TType.BYTE, 'action_ipv4_unicast_enabled', None, None, ), # 4
  )

  def __init__(self, action_vrf=None, action_rmac_group=None, action_ipv4_urpf_mode=None, action_ipv4_unicast_enabled=None,):
    self.action_vrf = action_vrf
    self.action_rmac_group = action_rmac_group
    self.action_ipv4_urpf_mode = action_ipv4_urpf_mode
    self.action_ipv4_unicast_enabled = action_ipv4_unicast_enabled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_rmac_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_ipv4_urpf_mode = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.action_ipv4_unicast_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_terminate_tunnel_inner_ipv4_action_spec_t')
    if self.action_vrf is not None:
      oprot.writeFieldBegin('action_vrf', TType.I16, 1)
      oprot.writeI16(self.action_vrf)
      oprot.writeFieldEnd()
    if self.action_rmac_group is not None:
      oprot.writeFieldBegin('action_rmac_group', TType.I16, 2)
      oprot.writeI16(self.action_rmac_group)
      oprot.writeFieldEnd()
    if self.action_ipv4_urpf_mode is not None:
      oprot.writeFieldBegin('action_ipv4_urpf_mode', TType.BYTE, 3)
      oprot.writeByte(self.action_ipv4_urpf_mode)
      oprot.writeFieldEnd()
    if self.action_ipv4_unicast_enabled is not None:
      oprot.writeFieldBegin('action_ipv4_unicast_enabled', TType.BYTE, 4)
      oprot.writeByte(self.action_ipv4_unicast_enabled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_vrf is None:
      raise TProtocol.TProtocolException(message='Required field action_vrf is unset!')
    if self.action_rmac_group is None:
      raise TProtocol.TProtocolException(message='Required field action_rmac_group is unset!')
    if self.action_ipv4_urpf_mode is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv4_urpf_mode is unset!')
    if self.action_ipv4_unicast_enabled is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv4_unicast_enabled is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_vrf)
    value = (value * 31) ^ hash(self.action_rmac_group)
    value = (value * 31) ^ hash(self.action_ipv4_urpf_mode)
    value = (value * 31) ^ hash(self.action_ipv4_unicast_enabled)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_nexthop_details_action_spec_t:
  """
  Attributes:
   - action_ifindex
   - action_bd
   - action_tunnel
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_ifindex', None, None, ), # 1
    (2, TType.I16, 'action_bd', None, None, ), # 2
    (3, TType.BYTE, 'action_tunnel', None, None, ), # 3
  )

  def __init__(self, action_ifindex=None, action_bd=None, action_tunnel=None,):
    self.action_ifindex = action_ifindex
    self.action_bd = action_bd
    self.action_tunnel = action_tunnel

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_tunnel = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_nexthop_details_action_spec_t')
    if self.action_ifindex is not None:
      oprot.writeFieldBegin('action_ifindex', TType.I16, 1)
      oprot.writeI16(self.action_ifindex)
      oprot.writeFieldEnd()
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 2)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_tunnel is not None:
      oprot.writeFieldBegin('action_tunnel', TType.BYTE, 3)
      oprot.writeByte(self.action_tunnel)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field action_ifindex is unset!')
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_tunnel is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ifindex)
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_tunnel)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_fib_hit_ecmp_action_spec_t:
  """
  Attributes:
   - action_ecmp_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_ecmp_index', None, None, ), # 1
  )

  def __init__(self, action_ecmp_index=None,):
    self.action_ecmp_index = action_ecmp_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_ecmp_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_fib_hit_ecmp_action_spec_t')
    if self.action_ecmp_index is not None:
      oprot.writeFieldBegin('action_ecmp_index', TType.I16, 1)
      oprot.writeI16(self.action_ecmp_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ecmp_index is None:
      raise TProtocol.TProtocolException(message='Required field action_ecmp_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ecmp_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_ifindex_action_spec_t:
  """
  Attributes:
   - action_ifindex
   - action_if_label
   - action_port_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_ifindex', None, None, ), # 1
    (2, TType.I16, 'action_if_label', None, None, ), # 2
    (3, TType.BYTE, 'action_port_type', None, None, ), # 3
  )

  def __init__(self, action_ifindex=None, action_if_label=None, action_port_type=None,):
    self.action_ifindex = action_ifindex
    self.action_if_label = action_if_label
    self.action_port_type = action_port_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_if_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_port_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_ifindex_action_spec_t')
    if self.action_ifindex is not None:
      oprot.writeFieldBegin('action_ifindex', TType.I16, 1)
      oprot.writeI16(self.action_ifindex)
      oprot.writeFieldEnd()
    if self.action_if_label is not None:
      oprot.writeFieldBegin('action_if_label', TType.I16, 2)
      oprot.writeI16(self.action_if_label)
      oprot.writeFieldEnd()
    if self.action_port_type is not None:
      oprot.writeFieldBegin('action_port_type', TType.BYTE, 3)
      oprot.writeByte(self.action_port_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field action_ifindex is unset!')
    if self.action_if_label is None:
      raise TProtocol.TProtocolException(message='Required field action_if_label is unset!')
    if self.action_port_type is None:
      raise TProtocol.TProtocolException(message='Required field action_port_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ifindex)
    value = (value * 31) ^ hash(self.action_if_label)
    value = (value * 31) ^ hash(self.action_port_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_mpls_rewrite_push1_action_spec_t:
  """
  Attributes:
   - action_label1
   - action_exp1
   - action_ttl1
   - action_smac_idx
   - action_dmac_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_label1', None, None, ), # 1
    (2, TType.BYTE, 'action_exp1', None, None, ), # 2
    (3, TType.BYTE, 'action_ttl1', None, None, ), # 3
    (4, TType.I16, 'action_smac_idx', None, None, ), # 4
    (5, TType.I16, 'action_dmac_idx', None, None, ), # 5
  )

  def __init__(self, action_label1=None, action_exp1=None, action_ttl1=None, action_smac_idx=None, action_dmac_idx=None,):
    self.action_label1 = action_label1
    self.action_exp1 = action_exp1
    self.action_ttl1 = action_ttl1
    self.action_smac_idx = action_smac_idx
    self.action_dmac_idx = action_dmac_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_label1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_exp1 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_ttl1 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.action_smac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.action_dmac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_mpls_rewrite_push1_action_spec_t')
    if self.action_label1 is not None:
      oprot.writeFieldBegin('action_label1', TType.I32, 1)
      oprot.writeI32(self.action_label1)
      oprot.writeFieldEnd()
    if self.action_exp1 is not None:
      oprot.writeFieldBegin('action_exp1', TType.BYTE, 2)
      oprot.writeByte(self.action_exp1)
      oprot.writeFieldEnd()
    if self.action_ttl1 is not None:
      oprot.writeFieldBegin('action_ttl1', TType.BYTE, 3)
      oprot.writeByte(self.action_ttl1)
      oprot.writeFieldEnd()
    if self.action_smac_idx is not None:
      oprot.writeFieldBegin('action_smac_idx', TType.I16, 4)
      oprot.writeI16(self.action_smac_idx)
      oprot.writeFieldEnd()
    if self.action_dmac_idx is not None:
      oprot.writeFieldBegin('action_dmac_idx', TType.I16, 5)
      oprot.writeI16(self.action_dmac_idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_label1 is None:
      raise TProtocol.TProtocolException(message='Required field action_label1 is unset!')
    if self.action_exp1 is None:
      raise TProtocol.TProtocolException(message='Required field action_exp1 is unset!')
    if self.action_ttl1 is None:
      raise TProtocol.TProtocolException(message='Required field action_ttl1 is unset!')
    if self.action_smac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_smac_idx is unset!')
    if self.action_dmac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_dmac_idx is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_label1)
    value = (value * 31) ^ hash(self.action_exp1)
    value = (value * 31) ^ hash(self.action_ttl1)
    value = (value * 31) ^ hash(self.action_smac_idx)
    value = (value * 31) ^ hash(self.action_dmac_idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_malformed_outer_ipv4_packet_action_spec_t:
  """
  Attributes:
   - action_drop_reason
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'action_drop_reason', None, None, ), # 1
  )

  def __init__(self, action_drop_reason=None,):
    self.action_drop_reason = action_drop_reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.action_drop_reason = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_malformed_outer_ipv4_packet_action_spec_t')
    if self.action_drop_reason is not None:
      oprot.writeFieldBegin('action_drop_reason', TType.BYTE, 1)
      oprot.writeByte(self.action_drop_reason)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_drop_reason is None:
      raise TProtocol.TProtocolException(message='Required field action_drop_reason is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_drop_reason)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_egress_tunnel_vni_action_spec_t:
  """
  Attributes:
   - action_vnid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_vnid', None, None, ), # 1
  )

  def __init__(self, action_vnid=None,):
    self.action_vnid = action_vnid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_vnid = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_egress_tunnel_vni_action_spec_t')
    if self.action_vnid is not None:
      oprot.writeFieldBegin('action_vnid', TType.I32, 1)
      oprot.writeI32(self.action_vnid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_vnid is None:
      raise TProtocol.TProtocolException(message='Required field action_vnid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_vnid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_racl_log_action_spec_t:
  """
  Attributes:
   - action_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_acl_stats_index', None, None, ), # 1
  )

  def __init__(self, action_acl_stats_index=None,):
    self.action_acl_stats_index = action_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_racl_log_action_spec_t')
    if self.action_acl_stats_index is not None:
      oprot.writeFieldBegin('action_acl_stats_index', TType.I32, 1)
      oprot.writeI32(self.action_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field action_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_ecmp_nexthop_details_action_spec_t:
  """
  Attributes:
   - action_ifindex
   - action_bd
   - action_nhop_index
   - action_tunnel
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_ifindex', None, None, ), # 1
    (2, TType.I16, 'action_bd', None, None, ), # 2
    (3, TType.I16, 'action_nhop_index', None, None, ), # 3
    (4, TType.BYTE, 'action_tunnel', None, None, ), # 4
  )

  def __init__(self, action_ifindex=None, action_bd=None, action_nhop_index=None, action_tunnel=None,):
    self.action_ifindex = action_ifindex
    self.action_bd = action_bd
    self.action_nhop_index = action_nhop_index
    self.action_tunnel = action_tunnel

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_nhop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.action_tunnel = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_ecmp_nexthop_details_action_spec_t')
    if self.action_ifindex is not None:
      oprot.writeFieldBegin('action_ifindex', TType.I16, 1)
      oprot.writeI16(self.action_ifindex)
      oprot.writeFieldEnd()
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 2)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_nhop_index is not None:
      oprot.writeFieldBegin('action_nhop_index', TType.I16, 3)
      oprot.writeI16(self.action_nhop_index)
      oprot.writeFieldEnd()
    if self.action_tunnel is not None:
      oprot.writeFieldBegin('action_tunnel', TType.BYTE, 4)
      oprot.writeByte(self.action_tunnel)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field action_ifindex is unset!')
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_nhop_index is None:
      raise TProtocol.TProtocolException(message='Required field action_nhop_index is unset!')
    if self.action_tunnel is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ifindex)
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_nhop_index)
    value = (value * 31) ^ hash(self.action_tunnel)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_apply_dscp_marking_action_spec_t:
  """
  Attributes:
   - action_dscp
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'action_dscp', None, None, ), # 1
  )

  def __init__(self, action_dscp=None,):
    self.action_dscp = action_dscp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.action_dscp = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_apply_dscp_marking_action_spec_t')
    if self.action_dscp is not None:
      oprot.writeFieldBegin('action_dscp', TType.BYTE, 1)
      oprot.writeByte(self.action_dscp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_dscp is None:
      raise TProtocol.TProtocolException(message='Required field action_dscp is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_dscp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_terminate_eompls_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.BYTE, 'action_tunnel_type', None, None, ), # 2
  )

  def __init__(self, action_bd=None, action_tunnel_type=None,):
    self.action_bd = action_bd
    self.action_tunnel_type = action_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_terminate_eompls_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_tunnel_type is not None:
      oprot.writeFieldBegin('action_tunnel_type', TType.BYTE, 2)
      oprot.writeByte(self.action_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_mpls_rewrite_push3_action_spec_t:
  """
  Attributes:
   - action_label1
   - action_exp1
   - action_ttl1
   - action_label2
   - action_exp2
   - action_ttl2
   - action_label3
   - action_exp3
   - action_ttl3
   - action_smac_idx
   - action_dmac_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_label1', None, None, ), # 1
    (2, TType.BYTE, 'action_exp1', None, None, ), # 2
    (3, TType.BYTE, 'action_ttl1', None, None, ), # 3
    (4, TType.I32, 'action_label2', None, None, ), # 4
    (5, TType.BYTE, 'action_exp2', None, None, ), # 5
    (6, TType.BYTE, 'action_ttl2', None, None, ), # 6
    (7, TType.I32, 'action_label3', None, None, ), # 7
    (8, TType.BYTE, 'action_exp3', None, None, ), # 8
    (9, TType.BYTE, 'action_ttl3', None, None, ), # 9
    (10, TType.I16, 'action_smac_idx', None, None, ), # 10
    (11, TType.I16, 'action_dmac_idx', None, None, ), # 11
  )

  def __init__(self, action_label1=None, action_exp1=None, action_ttl1=None, action_label2=None, action_exp2=None, action_ttl2=None, action_label3=None, action_exp3=None, action_ttl3=None, action_smac_idx=None, action_dmac_idx=None,):
    self.action_label1 = action_label1
    self.action_exp1 = action_exp1
    self.action_ttl1 = action_ttl1
    self.action_label2 = action_label2
    self.action_exp2 = action_exp2
    self.action_ttl2 = action_ttl2
    self.action_label3 = action_label3
    self.action_exp3 = action_exp3
    self.action_ttl3 = action_ttl3
    self.action_smac_idx = action_smac_idx
    self.action_dmac_idx = action_dmac_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_label1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_exp1 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_ttl1 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.action_label2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.action_exp2 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.action_ttl2 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.action_label3 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.action_exp3 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.action_ttl3 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I16:
          self.action_smac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.action_dmac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_mpls_rewrite_push3_action_spec_t')
    if self.action_label1 is not None:
      oprot.writeFieldBegin('action_label1', TType.I32, 1)
      oprot.writeI32(self.action_label1)
      oprot.writeFieldEnd()
    if self.action_exp1 is not None:
      oprot.writeFieldBegin('action_exp1', TType.BYTE, 2)
      oprot.writeByte(self.action_exp1)
      oprot.writeFieldEnd()
    if self.action_ttl1 is not None:
      oprot.writeFieldBegin('action_ttl1', TType.BYTE, 3)
      oprot.writeByte(self.action_ttl1)
      oprot.writeFieldEnd()
    if self.action_label2 is not None:
      oprot.writeFieldBegin('action_label2', TType.I32, 4)
      oprot.writeI32(self.action_label2)
      oprot.writeFieldEnd()
    if self.action_exp2 is not None:
      oprot.writeFieldBegin('action_exp2', TType.BYTE, 5)
      oprot.writeByte(self.action_exp2)
      oprot.writeFieldEnd()
    if self.action_ttl2 is not None:
      oprot.writeFieldBegin('action_ttl2', TType.BYTE, 6)
      oprot.writeByte(self.action_ttl2)
      oprot.writeFieldEnd()
    if self.action_label3 is not None:
      oprot.writeFieldBegin('action_label3', TType.I32, 7)
      oprot.writeI32(self.action_label3)
      oprot.writeFieldEnd()
    if self.action_exp3 is not None:
      oprot.writeFieldBegin('action_exp3', TType.BYTE, 8)
      oprot.writeByte(self.action_exp3)
      oprot.writeFieldEnd()
    if self.action_ttl3 is not None:
      oprot.writeFieldBegin('action_ttl3', TType.BYTE, 9)
      oprot.writeByte(self.action_ttl3)
      oprot.writeFieldEnd()
    if self.action_smac_idx is not None:
      oprot.writeFieldBegin('action_smac_idx', TType.I16, 10)
      oprot.writeI16(self.action_smac_idx)
      oprot.writeFieldEnd()
    if self.action_dmac_idx is not None:
      oprot.writeFieldBegin('action_dmac_idx', TType.I16, 11)
      oprot.writeI16(self.action_dmac_idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_label1 is None:
      raise TProtocol.TProtocolException(message='Required field action_label1 is unset!')
    if self.action_exp1 is None:
      raise TProtocol.TProtocolException(message='Required field action_exp1 is unset!')
    if self.action_ttl1 is None:
      raise TProtocol.TProtocolException(message='Required field action_ttl1 is unset!')
    if self.action_label2 is None:
      raise TProtocol.TProtocolException(message='Required field action_label2 is unset!')
    if self.action_exp2 is None:
      raise TProtocol.TProtocolException(message='Required field action_exp2 is unset!')
    if self.action_ttl2 is None:
      raise TProtocol.TProtocolException(message='Required field action_ttl2 is unset!')
    if self.action_label3 is None:
      raise TProtocol.TProtocolException(message='Required field action_label3 is unset!')
    if self.action_exp3 is None:
      raise TProtocol.TProtocolException(message='Required field action_exp3 is unset!')
    if self.action_ttl3 is None:
      raise TProtocol.TProtocolException(message='Required field action_ttl3 is unset!')
    if self.action_smac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_smac_idx is unset!')
    if self.action_dmac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_dmac_idx is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_label1)
    value = (value * 31) ^ hash(self.action_exp1)
    value = (value * 31) ^ hash(self.action_ttl1)
    value = (value * 31) ^ hash(self.action_label2)
    value = (value * 31) ^ hash(self.action_exp2)
    value = (value * 31) ^ hash(self.action_ttl2)
    value = (value * 31) ^ hash(self.action_label3)
    value = (value * 31) ^ hash(self.action_exp3)
    value = (value * 31) ^ hash(self.action_ttl3)
    value = (value * 31) ^ hash(self.action_smac_idx)
    value = (value * 31) ^ hash(self.action_dmac_idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_acl_log_action_spec_t:
  """
  Attributes:
   - action_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_acl_stats_index', None, None, ), # 1
  )

  def __init__(self, action_acl_stats_index=None,):
    self.action_acl_stats_index = action_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_acl_log_action_spec_t')
    if self.action_acl_stats_index is not None:
      oprot.writeFieldBegin('action_acl_stats_index', TType.I32, 1)
      oprot.writeI32(self.action_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field action_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_fabric_rewrite_action_spec_t:
  """
  Attributes:
   - action_tunnel_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_tunnel_index', None, None, ), # 1
  )

  def __init__(self, action_tunnel_index=None,):
    self.action_tunnel_index = action_tunnel_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_fabric_rewrite_action_spec_t')
    if self.action_tunnel_index is not None:
      oprot.writeFieldBegin('action_tunnel_index', TType.I16, 1)
      oprot.writeI16(self.action_tunnel_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_tunnel_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_malformed_outer_ipv6_packet_action_spec_t:
  """
  Attributes:
   - action_drop_reason
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'action_drop_reason', None, None, ), # 1
  )

  def __init__(self, action_drop_reason=None,):
    self.action_drop_reason = action_drop_reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.action_drop_reason = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_malformed_outer_ipv6_packet_action_spec_t')
    if self.action_drop_reason is not None:
      oprot.writeFieldBegin('action_drop_reason', TType.BYTE, 1)
      oprot.writeByte(self.action_drop_reason)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_drop_reason is None:
      raise TProtocol.TProtocolException(message='Required field action_drop_reason is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_drop_reason)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_mpls_mac_action_spec_t:
  """
  Attributes:
   - action_smac
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_smac', None, None, ), # 1
  )

  def __init__(self, action_smac=None,):
    self.action_smac = action_smac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_smac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_mpls_mac_action_spec_t')
    if self.action_smac is not None:
      oprot.writeFieldBegin('action_smac', TType.STRING, 1)
      oprot.writeString(self.action_smac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_smac is None:
      raise TProtocol.TProtocolException(message='Required field action_smac is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_smac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_terminate_tunnel_inner_ethernet_ipv6_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_vrf
   - action_rmac_group
   - action_bd_label
   - action_ipv6_unicast_enabled
   - action_ipv6_urpf_mode
   - action_mld_snooping_enabled
   - action_stats_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_vrf', None, None, ), # 2
    (3, TType.I16, 'action_rmac_group', None, None, ), # 3
    (4, TType.I16, 'action_bd_label', None, None, ), # 4
    (5, TType.BYTE, 'action_ipv6_unicast_enabled', None, None, ), # 5
    (6, TType.BYTE, 'action_ipv6_urpf_mode', None, None, ), # 6
    (7, TType.BYTE, 'action_mld_snooping_enabled', None, None, ), # 7
    (8, TType.I16, 'action_stats_idx', None, None, ), # 8
  )

  def __init__(self, action_bd=None, action_vrf=None, action_rmac_group=None, action_bd_label=None, action_ipv6_unicast_enabled=None, action_ipv6_urpf_mode=None, action_mld_snooping_enabled=None, action_stats_idx=None,):
    self.action_bd = action_bd
    self.action_vrf = action_vrf
    self.action_rmac_group = action_rmac_group
    self.action_bd_label = action_bd_label
    self.action_ipv6_unicast_enabled = action_ipv6_unicast_enabled
    self.action_ipv6_urpf_mode = action_ipv6_urpf_mode
    self.action_mld_snooping_enabled = action_mld_snooping_enabled
    self.action_stats_idx = action_stats_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_rmac_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.action_bd_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.action_ipv6_unicast_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.action_ipv6_urpf_mode = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BYTE:
          self.action_mld_snooping_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I16:
          self.action_stats_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_terminate_tunnel_inner_ethernet_ipv6_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_vrf is not None:
      oprot.writeFieldBegin('action_vrf', TType.I16, 2)
      oprot.writeI16(self.action_vrf)
      oprot.writeFieldEnd()
    if self.action_rmac_group is not None:
      oprot.writeFieldBegin('action_rmac_group', TType.I16, 3)
      oprot.writeI16(self.action_rmac_group)
      oprot.writeFieldEnd()
    if self.action_bd_label is not None:
      oprot.writeFieldBegin('action_bd_label', TType.I16, 4)
      oprot.writeI16(self.action_bd_label)
      oprot.writeFieldEnd()
    if self.action_ipv6_unicast_enabled is not None:
      oprot.writeFieldBegin('action_ipv6_unicast_enabled', TType.BYTE, 5)
      oprot.writeByte(self.action_ipv6_unicast_enabled)
      oprot.writeFieldEnd()
    if self.action_ipv6_urpf_mode is not None:
      oprot.writeFieldBegin('action_ipv6_urpf_mode', TType.BYTE, 6)
      oprot.writeByte(self.action_ipv6_urpf_mode)
      oprot.writeFieldEnd()
    if self.action_mld_snooping_enabled is not None:
      oprot.writeFieldBegin('action_mld_snooping_enabled', TType.BYTE, 7)
      oprot.writeByte(self.action_mld_snooping_enabled)
      oprot.writeFieldEnd()
    if self.action_stats_idx is not None:
      oprot.writeFieldBegin('action_stats_idx', TType.I16, 8)
      oprot.writeI16(self.action_stats_idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_vrf is None:
      raise TProtocol.TProtocolException(message='Required field action_vrf is unset!')
    if self.action_rmac_group is None:
      raise TProtocol.TProtocolException(message='Required field action_rmac_group is unset!')
    if self.action_bd_label is None:
      raise TProtocol.TProtocolException(message='Required field action_bd_label is unset!')
    if self.action_ipv6_unicast_enabled is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv6_unicast_enabled is unset!')
    if self.action_ipv6_urpf_mode is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv6_urpf_mode is unset!')
    if self.action_mld_snooping_enabled is None:
      raise TProtocol.TProtocolException(message='Required field action_mld_snooping_enabled is unset!')
    if self.action_stats_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_stats_idx is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_vrf)
    value = (value * 31) ^ hash(self.action_rmac_group)
    value = (value * 31) ^ hash(self.action_bd_label)
    value = (value * 31) ^ hash(self.action_ipv6_unicast_enabled)
    value = (value * 31) ^ hash(self.action_ipv6_urpf_mode)
    value = (value * 31) ^ hash(self.action_mld_snooping_enabled)
    value = (value * 31) ^ hash(self.action_stats_idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_bd_flood_mc_index_action_spec_t:
  """
  Attributes:
   - action_mc_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_mc_index', None, None, ), # 1
  )

  def __init__(self, action_mc_index=None,):
    self.action_mc_index = action_mc_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_mc_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_bd_flood_mc_index_action_spec_t')
    if self.action_mc_index is not None:
      oprot.writeFieldBegin('action_mc_index', TType.I16, 1)
      oprot.writeI16(self.action_mc_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_mc_index is None:
      raise TProtocol.TProtocolException(message='Required field action_mc_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_mc_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_acl_mirror_action_spec_t:
  """
  Attributes:
   - action_session_id
   - action_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_session_id', None, None, ), # 1
    (2, TType.I32, 'action_acl_stats_index', None, None, ), # 2
  )

  def __init__(self, action_session_id=None, action_acl_stats_index=None,):
    self.action_session_id = action_session_id
    self.action_acl_stats_index = action_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_session_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_acl_mirror_action_spec_t')
    if self.action_session_id is not None:
      oprot.writeFieldBegin('action_session_id', TType.I32, 1)
      oprot.writeI32(self.action_session_id)
      oprot.writeFieldEnd()
    if self.action_acl_stats_index is not None:
      oprot.writeFieldBegin('action_acl_stats_index', TType.I32, 2)
      oprot.writeI32(self.action_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_session_id is None:
      raise TProtocol.TProtocolException(message='Required field action_session_id is unset!')
    if self.action_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field action_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_session_id)
    value = (value * 31) ^ hash(self.action_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_malformed_packet_action_spec_t:
  """
  Attributes:
   - action_drop_reason
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'action_drop_reason', None, None, ), # 1
  )

  def __init__(self, action_drop_reason=None,):
    self.action_drop_reason = action_drop_reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.action_drop_reason = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_malformed_packet_action_spec_t')
    if self.action_drop_reason is not None:
      oprot.writeFieldBegin('action_drop_reason', TType.BYTE, 1)
      oprot.writeByte(self.action_drop_reason)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_drop_reason is None:
      raise TProtocol.TProtocolException(message='Required field action_drop_reason is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_drop_reason)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_egress_packet_vlan_tagged_action_spec_t:
  """
  Attributes:
   - action_vlan_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_vlan_id', None, None, ), # 1
  )

  def __init__(self, action_vlan_id=None,):
    self.action_vlan_id = action_vlan_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_vlan_id = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_egress_packet_vlan_tagged_action_spec_t')
    if self.action_vlan_id is not None:
      oprot.writeFieldBegin('action_vlan_id', TType.I16, 1)
      oprot.writeI16(self.action_vlan_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_vlan_id is None:
      raise TProtocol.TProtocolException(message='Required field action_vlan_id is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_vlan_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_mpls_rewrite_push2_action_spec_t:
  """
  Attributes:
   - action_label1
   - action_exp1
   - action_ttl1
   - action_label2
   - action_exp2
   - action_ttl2
   - action_smac_idx
   - action_dmac_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_label1', None, None, ), # 1
    (2, TType.BYTE, 'action_exp1', None, None, ), # 2
    (3, TType.BYTE, 'action_ttl1', None, None, ), # 3
    (4, TType.I32, 'action_label2', None, None, ), # 4
    (5, TType.BYTE, 'action_exp2', None, None, ), # 5
    (6, TType.BYTE, 'action_ttl2', None, None, ), # 6
    (7, TType.I16, 'action_smac_idx', None, None, ), # 7
    (8, TType.I16, 'action_dmac_idx', None, None, ), # 8
  )

  def __init__(self, action_label1=None, action_exp1=None, action_ttl1=None, action_label2=None, action_exp2=None, action_ttl2=None, action_smac_idx=None, action_dmac_idx=None,):
    self.action_label1 = action_label1
    self.action_exp1 = action_exp1
    self.action_ttl1 = action_ttl1
    self.action_label2 = action_label2
    self.action_exp2 = action_exp2
    self.action_ttl2 = action_ttl2
    self.action_smac_idx = action_smac_idx
    self.action_dmac_idx = action_dmac_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_label1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_exp1 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_ttl1 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.action_label2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.action_exp2 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.action_ttl2 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.action_smac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I16:
          self.action_dmac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_mpls_rewrite_push2_action_spec_t')
    if self.action_label1 is not None:
      oprot.writeFieldBegin('action_label1', TType.I32, 1)
      oprot.writeI32(self.action_label1)
      oprot.writeFieldEnd()
    if self.action_exp1 is not None:
      oprot.writeFieldBegin('action_exp1', TType.BYTE, 2)
      oprot.writeByte(self.action_exp1)
      oprot.writeFieldEnd()
    if self.action_ttl1 is not None:
      oprot.writeFieldBegin('action_ttl1', TType.BYTE, 3)
      oprot.writeByte(self.action_ttl1)
      oprot.writeFieldEnd()
    if self.action_label2 is not None:
      oprot.writeFieldBegin('action_label2', TType.I32, 4)
      oprot.writeI32(self.action_label2)
      oprot.writeFieldEnd()
    if self.action_exp2 is not None:
      oprot.writeFieldBegin('action_exp2', TType.BYTE, 5)
      oprot.writeByte(self.action_exp2)
      oprot.writeFieldEnd()
    if self.action_ttl2 is not None:
      oprot.writeFieldBegin('action_ttl2', TType.BYTE, 6)
      oprot.writeByte(self.action_ttl2)
      oprot.writeFieldEnd()
    if self.action_smac_idx is not None:
      oprot.writeFieldBegin('action_smac_idx', TType.I16, 7)
      oprot.writeI16(self.action_smac_idx)
      oprot.writeFieldEnd()
    if self.action_dmac_idx is not None:
      oprot.writeFieldBegin('action_dmac_idx', TType.I16, 8)
      oprot.writeI16(self.action_dmac_idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_label1 is None:
      raise TProtocol.TProtocolException(message='Required field action_label1 is unset!')
    if self.action_exp1 is None:
      raise TProtocol.TProtocolException(message='Required field action_exp1 is unset!')
    if self.action_ttl1 is None:
      raise TProtocol.TProtocolException(message='Required field action_ttl1 is unset!')
    if self.action_label2 is None:
      raise TProtocol.TProtocolException(message='Required field action_label2 is unset!')
    if self.action_exp2 is None:
      raise TProtocol.TProtocolException(message='Required field action_exp2 is unset!')
    if self.action_ttl2 is None:
      raise TProtocol.TProtocolException(message='Required field action_ttl2 is unset!')
    if self.action_smac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_smac_idx is unset!')
    if self.action_dmac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_dmac_idx is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_label1)
    value = (value * 31) ^ hash(self.action_exp1)
    value = (value * 31) ^ hash(self.action_ttl1)
    value = (value * 31) ^ hash(self.action_label2)
    value = (value * 31) ^ hash(self.action_exp2)
    value = (value * 31) ^ hash(self.action_ttl2)
    value = (value * 31) ^ hash(self.action_smac_idx)
    value = (value * 31) ^ hash(self.action_dmac_idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_mpls_push_rewrite_l2_action_spec_t:
  """
  Attributes:
   - action_tunnel_index
   - action_header_count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_tunnel_index', None, None, ), # 1
    (2, TType.BYTE, 'action_header_count', None, None, ), # 2
  )

  def __init__(self, action_tunnel_index=None, action_header_count=None,):
    self.action_tunnel_index = action_tunnel_index
    self.action_header_count = action_header_count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_header_count = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_mpls_push_rewrite_l2_action_spec_t')
    if self.action_tunnel_index is not None:
      oprot.writeFieldBegin('action_tunnel_index', TType.I16, 1)
      oprot.writeI16(self.action_tunnel_index)
      oprot.writeFieldEnd()
    if self.action_header_count is not None:
      oprot.writeFieldBegin('action_header_count', TType.BYTE, 2)
      oprot.writeByte(self.action_header_count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_index is unset!')
    if self.action_header_count is None:
      raise TProtocol.TProtocolException(message='Required field action_header_count is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_tunnel_index)
    value = (value * 31) ^ hash(self.action_header_count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_mpls_push_rewrite_l3_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_smac_idx
   - action_dmac
   - action_tunnel_index
   - action_header_count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_smac_idx', None, None, ), # 2
    (3, TType.STRING, 'action_dmac', None, None, ), # 3
    (4, TType.I16, 'action_tunnel_index', None, None, ), # 4
    (5, TType.BYTE, 'action_header_count', None, None, ), # 5
  )

  def __init__(self, action_bd=None, action_smac_idx=None, action_dmac=None, action_tunnel_index=None, action_header_count=None,):
    self.action_bd = action_bd
    self.action_smac_idx = action_smac_idx
    self.action_dmac = action_dmac
    self.action_tunnel_index = action_tunnel_index
    self.action_header_count = action_header_count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_smac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.action_dmac = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.action_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.action_header_count = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_mpls_push_rewrite_l3_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_smac_idx is not None:
      oprot.writeFieldBegin('action_smac_idx', TType.I16, 2)
      oprot.writeI16(self.action_smac_idx)
      oprot.writeFieldEnd()
    if self.action_dmac is not None:
      oprot.writeFieldBegin('action_dmac', TType.STRING, 3)
      oprot.writeString(self.action_dmac)
      oprot.writeFieldEnd()
    if self.action_tunnel_index is not None:
      oprot.writeFieldBegin('action_tunnel_index', TType.I16, 4)
      oprot.writeI16(self.action_tunnel_index)
      oprot.writeFieldEnd()
    if self.action_header_count is not None:
      oprot.writeFieldBegin('action_header_count', TType.BYTE, 5)
      oprot.writeByte(self.action_header_count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_smac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_smac_idx is unset!')
    if self.action_dmac is None:
      raise TProtocol.TProtocolException(message='Required field action_dmac is unset!')
    if self.action_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_index is unset!')
    if self.action_header_count is None:
      raise TProtocol.TProtocolException(message='Required field action_header_count is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_smac_idx)
    value = (value * 31) ^ hash(self.action_dmac)
    value = (value * 31) ^ hash(self.action_tunnel_index)
    value = (value * 31) ^ hash(self.action_header_count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_dmac_hit_action_spec_t:
  """
  Attributes:
   - action_ifindex
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_ifindex', None, None, ), # 1
  )

  def __init__(self, action_ifindex=None,):
    self.action_ifindex = action_ifindex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_dmac_hit_action_spec_t')
    if self.action_ifindex is not None:
      oprot.writeFieldBegin('action_ifindex', TType.I16, 1)
      oprot.writeI16(self.action_ifindex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field action_ifindex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ifindex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_inner_replica_from_rid_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_tunnel_index
   - action_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_tunnel_index', None, None, ), # 2
    (3, TType.BYTE, 'action_tunnel_type', None, None, ), # 3
  )

  def __init__(self, action_bd=None, action_tunnel_index=None, action_tunnel_type=None,):
    self.action_bd = action_bd
    self.action_tunnel_index = action_tunnel_index
    self.action_tunnel_type = action_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_inner_replica_from_rid_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_tunnel_index is not None:
      oprot.writeFieldBegin('action_tunnel_index', TType.I16, 2)
      oprot.writeI16(self.action_tunnel_index)
      oprot.writeFieldEnd()
    if self.action_tunnel_type is not None:
      oprot.writeFieldBegin('action_tunnel_type', TType.BYTE, 3)
      oprot.writeByte(self.action_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_index is unset!')
    if self.action_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_tunnel_index)
    value = (value * 31) ^ hash(self.action_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_fib_hit_nexthop_action_spec_t:
  """
  Attributes:
   - action_nexthop_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_nexthop_index', None, None, ), # 1
  )

  def __init__(self, action_nexthop_index=None,):
    self.action_nexthop_index = action_nexthop_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_nexthop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_fib_hit_nexthop_action_spec_t')
    if self.action_nexthop_index is not None:
      oprot.writeFieldBegin('action_nexthop_index', TType.I16, 1)
      oprot.writeI16(self.action_nexthop_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_nexthop_index is None:
      raise TProtocol.TProtocolException(message='Required field action_nexthop_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_nexthop_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_racl_redirect_nexthop_action_spec_t:
  """
  Attributes:
   - action_nexthop_index
   - action_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_nexthop_index', None, None, ), # 1
    (2, TType.I32, 'action_acl_stats_index', None, None, ), # 2
  )

  def __init__(self, action_nexthop_index=None, action_acl_stats_index=None,):
    self.action_nexthop_index = action_nexthop_index
    self.action_acl_stats_index = action_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_nexthop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_racl_redirect_nexthop_action_spec_t')
    if self.action_nexthop_index is not None:
      oprot.writeFieldBegin('action_nexthop_index', TType.I16, 1)
      oprot.writeI16(self.action_nexthop_index)
      oprot.writeFieldEnd()
    if self.action_acl_stats_index is not None:
      oprot.writeFieldBegin('action_acl_stats_index', TType.I32, 2)
      oprot.writeI32(self.action_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_nexthop_index is None:
      raise TProtocol.TProtocolException(message='Required field action_nexthop_index is unset!')
    if self.action_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field action_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_nexthop_index)
    value = (value * 31) ^ hash(self.action_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_ipv4_multicast_mac_action_spec_t:
  """
  Attributes:
   - action_smac
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_smac', None, None, ), # 1
  )

  def __init__(self, action_smac=None,):
    self.action_smac = action_smac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_smac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_ipv4_multicast_mac_action_spec_t')
    if self.action_smac is not None:
      oprot.writeFieldBegin('action_smac', TType.STRING, 1)
      oprot.writeString(self.action_smac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_smac is None:
      raise TProtocol.TProtocolException(message='Required field action_smac is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_smac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_tunnel_smac_action_spec_t:
  """
  Attributes:
   - action_smac
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_smac', None, None, ), # 1
  )

  def __init__(self, action_smac=None,):
    self.action_smac = action_smac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_smac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_tunnel_smac_action_spec_t')
    if self.action_smac is not None:
      oprot.writeFieldBegin('action_smac', TType.STRING, 1)
      oprot.writeString(self.action_smac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_smac is None:
      raise TProtocol.TProtocolException(message='Required field action_smac is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_smac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_inner_replica_from_rid_with_nexthop_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_nexthop_index
   - action_tunnel_index
   - action_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_nexthop_index', None, None, ), # 2
    (3, TType.I16, 'action_tunnel_index', None, None, ), # 3
    (4, TType.BYTE, 'action_tunnel_type', None, None, ), # 4
  )

  def __init__(self, action_bd=None, action_nexthop_index=None, action_tunnel_index=None, action_tunnel_type=None,):
    self.action_bd = action_bd
    self.action_nexthop_index = action_nexthop_index
    self.action_tunnel_index = action_tunnel_index
    self.action_tunnel_type = action_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_nexthop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.action_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_inner_replica_from_rid_with_nexthop_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_nexthop_index is not None:
      oprot.writeFieldBegin('action_nexthop_index', TType.I16, 2)
      oprot.writeI16(self.action_nexthop_index)
      oprot.writeFieldEnd()
    if self.action_tunnel_index is not None:
      oprot.writeFieldBegin('action_tunnel_index', TType.I16, 3)
      oprot.writeI16(self.action_tunnel_index)
      oprot.writeFieldEnd()
    if self.action_tunnel_type is not None:
      oprot.writeFieldBegin('action_tunnel_type', TType.BYTE, 4)
      oprot.writeByte(self.action_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_nexthop_index is None:
      raise TProtocol.TProtocolException(message='Required field action_nexthop_index is unset!')
    if self.action_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_index is unset!')
    if self.action_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_nexthop_index)
    value = (value * 31) ^ hash(self.action_tunnel_index)
    value = (value * 31) ^ hash(self.action_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_dmac_redirect_nexthop_action_spec_t:
  """
  Attributes:
   - action_nexthop_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_nexthop_index', None, None, ), # 1
  )

  def __init__(self, action_nexthop_index=None,):
    self.action_nexthop_index = action_nexthop_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_nexthop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_dmac_redirect_nexthop_action_spec_t')
    if self.action_nexthop_index is not None:
      oprot.writeFieldBegin('action_nexthop_index', TType.I16, 1)
      oprot.writeI16(self.action_nexthop_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_nexthop_index is None:
      raise TProtocol.TProtocolException(message='Required field action_nexthop_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_nexthop_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_copy_to_cpu_action_spec_t:
  """
  Attributes:
   - action_reason_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_reason_code', None, None, ), # 1
  )

  def __init__(self, action_reason_code=None,):
    self.action_reason_code = action_reason_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_reason_code = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_copy_to_cpu_action_spec_t')
    if self.action_reason_code is not None:
      oprot.writeFieldBegin('action_reason_code', TType.I16, 1)
      oprot.writeI16(self.action_reason_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_reason_code is None:
      raise TProtocol.TProtocolException(message='Required field action_reason_code is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_reason_code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_fabric_lag_port_action_spec_t:
  """
  Attributes:
   - action_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_port', None, None, ), # 1
  )

  def __init__(self, action_port=None,):
    self.action_port = action_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_fabric_lag_port_action_spec_t')
    if self.action_port is not None:
      oprot.writeFieldBegin('action_port', TType.I16, 1)
      oprot.writeI16(self.action_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_port is None:
      raise TProtocol.TProtocolException(message='Required field action_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_tunnel_dmac_action_spec_t:
  """
  Attributes:
   - action_dmac
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_dmac', None, None, ), # 1
  )

  def __init__(self, action_dmac=None,):
    self.action_dmac = action_dmac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_dmac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_tunnel_dmac_action_spec_t')
    if self.action_dmac is not None:
      oprot.writeFieldBegin('action_dmac', TType.STRING, 1)
      oprot.writeString(self.action_dmac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_dmac is None:
      raise TProtocol.TProtocolException(message='Required field action_dmac is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_dmac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_egress_packet_vlan_double_tagged_action_spec_t:
  """
  Attributes:
   - action_s_tag
   - action_c_tag
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_s_tag', None, None, ), # 1
    (2, TType.I16, 'action_c_tag', None, None, ), # 2
  )

  def __init__(self, action_s_tag=None, action_c_tag=None,):
    self.action_s_tag = action_s_tag
    self.action_c_tag = action_c_tag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_s_tag = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_c_tag = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_egress_packet_vlan_double_tagged_action_spec_t')
    if self.action_s_tag is not None:
      oprot.writeFieldBegin('action_s_tag', TType.I16, 1)
      oprot.writeI16(self.action_s_tag)
      oprot.writeFieldEnd()
    if self.action_c_tag is not None:
      oprot.writeFieldBegin('action_c_tag', TType.I16, 2)
      oprot.writeI16(self.action_c_tag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_s_tag is None:
      raise TProtocol.TProtocolException(message='Required field action_s_tag is unset!')
    if self.action_c_tag is None:
      raise TProtocol.TProtocolException(message='Required field action_c_tag is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_s_tag)
    value = (value * 31) ^ hash(self.action_c_tag)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_acl_redirect_nexthop_action_spec_t:
  """
  Attributes:
   - action_nexthop_index
   - action_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_nexthop_index', None, None, ), # 1
    (2, TType.I32, 'action_acl_stats_index', None, None, ), # 2
  )

  def __init__(self, action_nexthop_index=None, action_acl_stats_index=None,):
    self.action_nexthop_index = action_nexthop_index
    self.action_acl_stats_index = action_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_nexthop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_acl_redirect_nexthop_action_spec_t')
    if self.action_nexthop_index is not None:
      oprot.writeFieldBegin('action_nexthop_index', TType.I16, 1)
      oprot.writeI16(self.action_nexthop_index)
      oprot.writeFieldEnd()
    if self.action_acl_stats_index is not None:
      oprot.writeFieldBegin('action_acl_stats_index', TType.I32, 2)
      oprot.writeI32(self.action_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_nexthop_index is None:
      raise TProtocol.TProtocolException(message='Required field action_nexthop_index is unset!')
    if self.action_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field action_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_nexthop_index)
    value = (value * 31) ^ hash(self.action_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_egress_mirror_action_spec_t:
  """
  Attributes:
   - action_session_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_session_id', None, None, ), # 1
  )

  def __init__(self, action_session_id=None,):
    self.action_session_id = action_session_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_session_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_egress_mirror_action_spec_t')
    if self.action_session_id is not None:
      oprot.writeFieldBegin('action_session_id', TType.I32, 1)
      oprot.writeI32(self.action_session_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_session_id is None:
      raise TProtocol.TProtocolException(message='Required field action_session_id is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_session_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_l3_rewrite_with_tunnel_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_smac_idx
   - action_dmac
   - action_tunnel_index
   - action_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_smac_idx', None, None, ), # 2
    (3, TType.STRING, 'action_dmac', None, None, ), # 3
    (4, TType.I16, 'action_tunnel_index', None, None, ), # 4
    (5, TType.BYTE, 'action_tunnel_type', None, None, ), # 5
  )

  def __init__(self, action_bd=None, action_smac_idx=None, action_dmac=None, action_tunnel_index=None, action_tunnel_type=None,):
    self.action_bd = action_bd
    self.action_smac_idx = action_smac_idx
    self.action_dmac = action_dmac
    self.action_tunnel_index = action_tunnel_index
    self.action_tunnel_type = action_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_smac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.action_dmac = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.action_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.action_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_l3_rewrite_with_tunnel_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_smac_idx is not None:
      oprot.writeFieldBegin('action_smac_idx', TType.I16, 2)
      oprot.writeI16(self.action_smac_idx)
      oprot.writeFieldEnd()
    if self.action_dmac is not None:
      oprot.writeFieldBegin('action_dmac', TType.STRING, 3)
      oprot.writeString(self.action_dmac)
      oprot.writeFieldEnd()
    if self.action_tunnel_index is not None:
      oprot.writeFieldBegin('action_tunnel_index', TType.I16, 4)
      oprot.writeI16(self.action_tunnel_index)
      oprot.writeFieldEnd()
    if self.action_tunnel_type is not None:
      oprot.writeFieldBegin('action_tunnel_type', TType.BYTE, 5)
      oprot.writeByte(self.action_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_smac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_smac_idx is unset!')
    if self.action_dmac is None:
      raise TProtocol.TProtocolException(message='Required field action_dmac is unset!')
    if self.action_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_index is unset!')
    if self.action_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_smac_idx)
    value = (value * 31) ^ hash(self.action_dmac)
    value = (value * 31) ^ hash(self.action_tunnel_index)
    value = (value * 31) ^ hash(self.action_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_src_vtep_hit_action_spec_t:
  """
  Attributes:
   - action_ifindex
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_ifindex', None, None, ), # 1
  )

  def __init__(self, action_ifindex=None,):
    self.action_ifindex = action_ifindex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_src_vtep_hit_action_spec_t')
    if self.action_ifindex is not None:
      oprot.writeFieldBegin('action_ifindex', TType.I16, 1)
      oprot.writeI16(self.action_ifindex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field action_ifindex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ifindex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_racl_redirect_ecmp_action_spec_t:
  """
  Attributes:
   - action_ecmp_index
   - action_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_ecmp_index', None, None, ), # 1
    (2, TType.I32, 'action_acl_stats_index', None, None, ), # 2
  )

  def __init__(self, action_ecmp_index=None, action_acl_stats_index=None,):
    self.action_ecmp_index = action_ecmp_index
    self.action_acl_stats_index = action_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_ecmp_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_racl_redirect_ecmp_action_spec_t')
    if self.action_ecmp_index is not None:
      oprot.writeFieldBegin('action_ecmp_index', TType.I16, 1)
      oprot.writeI16(self.action_ecmp_index)
      oprot.writeFieldEnd()
    if self.action_acl_stats_index is not None:
      oprot.writeFieldBegin('action_acl_stats_index', TType.I32, 2)
      oprot.writeI32(self.action_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ecmp_index is None:
      raise TProtocol.TProtocolException(message='Required field action_ecmp_index is unset!')
    if self.action_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field action_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ecmp_index)
    value = (value * 31) ^ hash(self.action_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_dmac_redirect_ecmp_action_spec_t:
  """
  Attributes:
   - action_ecmp_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_ecmp_index', None, None, ), # 1
  )

  def __init__(self, action_ecmp_index=None,):
    self.action_ecmp_index = action_ecmp_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_ecmp_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_dmac_redirect_ecmp_action_spec_t')
    if self.action_ecmp_index is not None:
      oprot.writeFieldBegin('action_ecmp_index', TType.I16, 1)
      oprot.writeI16(self.action_ecmp_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ecmp_index is None:
      raise TProtocol.TProtocolException(message='Required field action_ecmp_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ecmp_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_acl_permit_action_spec_t:
  """
  Attributes:
   - action_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_acl_stats_index', None, None, ), # 1
  )

  def __init__(self, action_acl_stats_index=None,):
    self.action_acl_stats_index = action_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_acl_permit_action_spec_t')
    if self.action_acl_stats_index is not None:
      oprot.writeFieldBegin('action_acl_stats_index', TType.I32, 1)
      oprot.writeI32(self.action_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field action_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_storm_control_meter_action_spec_t:
  """
  Attributes:
   - action_meter_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_meter_idx', None, None, ), # 1
  )

  def __init__(self, action_meter_idx=None,):
    self.action_meter_idx = action_meter_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_meter_idx = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_storm_control_meter_action_spec_t')
    if self.action_meter_idx is not None:
      oprot.writeFieldBegin('action_meter_idx', TType.I32, 1)
      oprot.writeI32(self.action_meter_idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_meter_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_meter_idx is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_meter_idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_bd_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_vrf
   - action_rmac_group
   - action_ipv4_unicast_enabled
   - action_ipv6_unicast_enabled
   - action_ipv4_urpf_mode
   - action_ipv6_urpf_mode
   - action_igmp_snooping_enabled
   - action_mld_snooping_enabled
   - action_bd_label
   - action_stp_group
   - action_stats_idx
   - action_learning_enabled
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_vrf', None, None, ), # 2
    (3, TType.I16, 'action_rmac_group', None, None, ), # 3
    (4, TType.BYTE, 'action_ipv4_unicast_enabled', None, None, ), # 4
    (5, TType.BYTE, 'action_ipv6_unicast_enabled', None, None, ), # 5
    (6, TType.BYTE, 'action_ipv4_urpf_mode', None, None, ), # 6
    (7, TType.BYTE, 'action_ipv6_urpf_mode', None, None, ), # 7
    (8, TType.BYTE, 'action_igmp_snooping_enabled', None, None, ), # 8
    (9, TType.BYTE, 'action_mld_snooping_enabled', None, None, ), # 9
    (10, TType.I16, 'action_bd_label', None, None, ), # 10
    (11, TType.I16, 'action_stp_group', None, None, ), # 11
    (12, TType.I16, 'action_stats_idx', None, None, ), # 12
    (13, TType.BYTE, 'action_learning_enabled', None, None, ), # 13
  )

  def __init__(self, action_bd=None, action_vrf=None, action_rmac_group=None, action_ipv4_unicast_enabled=None, action_ipv6_unicast_enabled=None, action_ipv4_urpf_mode=None, action_ipv6_urpf_mode=None, action_igmp_snooping_enabled=None, action_mld_snooping_enabled=None, action_bd_label=None, action_stp_group=None, action_stats_idx=None, action_learning_enabled=None,):
    self.action_bd = action_bd
    self.action_vrf = action_vrf
    self.action_rmac_group = action_rmac_group
    self.action_ipv4_unicast_enabled = action_ipv4_unicast_enabled
    self.action_ipv6_unicast_enabled = action_ipv6_unicast_enabled
    self.action_ipv4_urpf_mode = action_ipv4_urpf_mode
    self.action_ipv6_urpf_mode = action_ipv6_urpf_mode
    self.action_igmp_snooping_enabled = action_igmp_snooping_enabled
    self.action_mld_snooping_enabled = action_mld_snooping_enabled
    self.action_bd_label = action_bd_label
    self.action_stp_group = action_stp_group
    self.action_stats_idx = action_stats_idx
    self.action_learning_enabled = action_learning_enabled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_rmac_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.action_ipv4_unicast_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.action_ipv6_unicast_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.action_ipv4_urpf_mode = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BYTE:
          self.action_ipv6_urpf_mode = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.action_igmp_snooping_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.action_mld_snooping_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I16:
          self.action_bd_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.action_stp_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I16:
          self.action_stats_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BYTE:
          self.action_learning_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_bd_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_vrf is not None:
      oprot.writeFieldBegin('action_vrf', TType.I16, 2)
      oprot.writeI16(self.action_vrf)
      oprot.writeFieldEnd()
    if self.action_rmac_group is not None:
      oprot.writeFieldBegin('action_rmac_group', TType.I16, 3)
      oprot.writeI16(self.action_rmac_group)
      oprot.writeFieldEnd()
    if self.action_ipv4_unicast_enabled is not None:
      oprot.writeFieldBegin('action_ipv4_unicast_enabled', TType.BYTE, 4)
      oprot.writeByte(self.action_ipv4_unicast_enabled)
      oprot.writeFieldEnd()
    if self.action_ipv6_unicast_enabled is not None:
      oprot.writeFieldBegin('action_ipv6_unicast_enabled', TType.BYTE, 5)
      oprot.writeByte(self.action_ipv6_unicast_enabled)
      oprot.writeFieldEnd()
    if self.action_ipv4_urpf_mode is not None:
      oprot.writeFieldBegin('action_ipv4_urpf_mode', TType.BYTE, 6)
      oprot.writeByte(self.action_ipv4_urpf_mode)
      oprot.writeFieldEnd()
    if self.action_ipv6_urpf_mode is not None:
      oprot.writeFieldBegin('action_ipv6_urpf_mode', TType.BYTE, 7)
      oprot.writeByte(self.action_ipv6_urpf_mode)
      oprot.writeFieldEnd()
    if self.action_igmp_snooping_enabled is not None:
      oprot.writeFieldBegin('action_igmp_snooping_enabled', TType.BYTE, 8)
      oprot.writeByte(self.action_igmp_snooping_enabled)
      oprot.writeFieldEnd()
    if self.action_mld_snooping_enabled is not None:
      oprot.writeFieldBegin('action_mld_snooping_enabled', TType.BYTE, 9)
      oprot.writeByte(self.action_mld_snooping_enabled)
      oprot.writeFieldEnd()
    if self.action_bd_label is not None:
      oprot.writeFieldBegin('action_bd_label', TType.I16, 10)
      oprot.writeI16(self.action_bd_label)
      oprot.writeFieldEnd()
    if self.action_stp_group is not None:
      oprot.writeFieldBegin('action_stp_group', TType.I16, 11)
      oprot.writeI16(self.action_stp_group)
      oprot.writeFieldEnd()
    if self.action_stats_idx is not None:
      oprot.writeFieldBegin('action_stats_idx', TType.I16, 12)
      oprot.writeI16(self.action_stats_idx)
      oprot.writeFieldEnd()
    if self.action_learning_enabled is not None:
      oprot.writeFieldBegin('action_learning_enabled', TType.BYTE, 13)
      oprot.writeByte(self.action_learning_enabled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_vrf is None:
      raise TProtocol.TProtocolException(message='Required field action_vrf is unset!')
    if self.action_rmac_group is None:
      raise TProtocol.TProtocolException(message='Required field action_rmac_group is unset!')
    if self.action_ipv4_unicast_enabled is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv4_unicast_enabled is unset!')
    if self.action_ipv6_unicast_enabled is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv6_unicast_enabled is unset!')
    if self.action_ipv4_urpf_mode is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv4_urpf_mode is unset!')
    if self.action_ipv6_urpf_mode is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv6_urpf_mode is unset!')
    if self.action_igmp_snooping_enabled is None:
      raise TProtocol.TProtocolException(message='Required field action_igmp_snooping_enabled is unset!')
    if self.action_mld_snooping_enabled is None:
      raise TProtocol.TProtocolException(message='Required field action_mld_snooping_enabled is unset!')
    if self.action_bd_label is None:
      raise TProtocol.TProtocolException(message='Required field action_bd_label is unset!')
    if self.action_stp_group is None:
      raise TProtocol.TProtocolException(message='Required field action_stp_group is unset!')
    if self.action_stats_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_stats_idx is unset!')
    if self.action_learning_enabled is None:
      raise TProtocol.TProtocolException(message='Required field action_learning_enabled is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_vrf)
    value = (value * 31) ^ hash(self.action_rmac_group)
    value = (value * 31) ^ hash(self.action_ipv4_unicast_enabled)
    value = (value * 31) ^ hash(self.action_ipv6_unicast_enabled)
    value = (value * 31) ^ hash(self.action_ipv4_urpf_mode)
    value = (value * 31) ^ hash(self.action_ipv6_urpf_mode)
    value = (value * 31) ^ hash(self.action_igmp_snooping_enabled)
    value = (value * 31) ^ hash(self.action_mld_snooping_enabled)
    value = (value * 31) ^ hash(self.action_bd_label)
    value = (value * 31) ^ hash(self.action_stp_group)
    value = (value * 31) ^ hash(self.action_stats_idx)
    value = (value * 31) ^ hash(self.action_learning_enabled)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_lag_remote_port_action_spec_t:
  """
  Attributes:
   - action_device
   - action_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'action_device', None, None, ), # 1
    (2, TType.I16, 'action_port', None, None, ), # 2
  )

  def __init__(self, action_device=None, action_port=None,):
    self.action_device = action_device
    self.action_port = action_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.action_device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_lag_remote_port_action_spec_t')
    if self.action_device is not None:
      oprot.writeFieldBegin('action_device', TType.BYTE, 1)
      oprot.writeByte(self.action_device)
      oprot.writeFieldEnd()
    if self.action_port is not None:
      oprot.writeFieldBegin('action_port', TType.I16, 2)
      oprot.writeI16(self.action_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_device is None:
      raise TProtocol.TProtocolException(message='Required field action_device is unset!')
    if self.action_port is None:
      raise TProtocol.TProtocolException(message='Required field action_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_device)
    value = (value * 31) ^ hash(self.action_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_ipv6_unicast_mac_action_spec_t:
  """
  Attributes:
   - action_smac
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_smac', None, None, ), # 1
  )

  def __init__(self, action_smac=None,):
    self.action_smac = action_smac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_smac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_ipv6_unicast_mac_action_spec_t')
    if self.action_smac is not None:
      oprot.writeFieldBegin('action_smac', TType.STRING, 1)
      oprot.writeString(self.action_smac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_smac is None:
      raise TProtocol.TProtocolException(message='Required field action_smac is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_smac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_l3_rewrite_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_mtu_index
   - action_smac_idx
   - action_dmac
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.BYTE, 'action_mtu_index', None, None, ), # 2
    (3, TType.I16, 'action_smac_idx', None, None, ), # 3
    (4, TType.STRING, 'action_dmac', None, None, ), # 4
  )

  def __init__(self, action_bd=None, action_mtu_index=None, action_smac_idx=None, action_dmac=None,):
    self.action_bd = action_bd
    self.action_mtu_index = action_mtu_index
    self.action_smac_idx = action_smac_idx
    self.action_dmac = action_dmac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_mtu_index = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_smac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.action_dmac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_l3_rewrite_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_mtu_index is not None:
      oprot.writeFieldBegin('action_mtu_index', TType.BYTE, 2)
      oprot.writeByte(self.action_mtu_index)
      oprot.writeFieldEnd()
    if self.action_smac_idx is not None:
      oprot.writeFieldBegin('action_smac_idx', TType.I16, 3)
      oprot.writeI16(self.action_smac_idx)
      oprot.writeFieldEnd()
    if self.action_dmac is not None:
      oprot.writeFieldBegin('action_dmac', TType.STRING, 4)
      oprot.writeString(self.action_dmac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_mtu_index is None:
      raise TProtocol.TProtocolException(message='Required field action_mtu_index is unset!')
    if self.action_smac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_smac_idx is unset!')
    if self.action_dmac is None:
      raise TProtocol.TProtocolException(message='Required field action_dmac is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_mtu_index)
    value = (value * 31) ^ hash(self.action_smac_idx)
    value = (value * 31) ^ hash(self.action_dmac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_mirror_nhop_action_spec_t:
  """
  Attributes:
   - action_nhop_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_nhop_idx', None, None, ), # 1
  )

  def __init__(self, action_nhop_idx=None,):
    self.action_nhop_idx = action_nhop_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_nhop_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_mirror_nhop_action_spec_t')
    if self.action_nhop_idx is not None:
      oprot.writeFieldBegin('action_nhop_idx', TType.I16, 1)
      oprot.writeI16(self.action_nhop_idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_nhop_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_nhop_idx is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_nhop_idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_apply_tc_marking_action_spec_t:
  """
  Attributes:
   - action_tc
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'action_tc', None, None, ), # 1
  )

  def __init__(self, action_tc=None,):
    self.action_tc = action_tc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.action_tc = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_apply_tc_marking_action_spec_t')
    if self.action_tc is not None:
      oprot.writeFieldBegin('action_tc', TType.BYTE, 1)
      oprot.writeByte(self.action_tc)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_tc is None:
      raise TProtocol.TProtocolException(message='Required field action_tc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_tc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_terminate_tunnel_inner_non_ip_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_bd_label
   - action_stats_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_bd_label', None, None, ), # 2
    (3, TType.I16, 'action_stats_idx', None, None, ), # 3
  )

  def __init__(self, action_bd=None, action_bd_label=None, action_stats_idx=None,):
    self.action_bd = action_bd
    self.action_bd_label = action_bd_label
    self.action_stats_idx = action_stats_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_bd_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_stats_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_terminate_tunnel_inner_non_ip_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_bd_label is not None:
      oprot.writeFieldBegin('action_bd_label', TType.I16, 2)
      oprot.writeI16(self.action_bd_label)
      oprot.writeFieldEnd()
    if self.action_stats_idx is not None:
      oprot.writeFieldBegin('action_stats_idx', TType.I16, 3)
      oprot.writeI16(self.action_stats_idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_bd_label is None:
      raise TProtocol.TProtocolException(message='Required field action_bd_label is unset!')
    if self.action_stats_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_stats_idx is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_bd_label)
    value = (value * 31) ^ hash(self.action_stats_idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_fabric_multicast_rewrite_action_spec_t:
  """
  Attributes:
   - action_fabric_mgid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_fabric_mgid', None, None, ), # 1
  )

  def __init__(self, action_fabric_mgid=None,):
    self.action_fabric_mgid = action_fabric_mgid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_fabric_mgid = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_fabric_multicast_rewrite_action_spec_t')
    if self.action_fabric_mgid is not None:
      oprot.writeFieldBegin('action_fabric_mgid', TType.I16, 1)
      oprot.writeI16(self.action_fabric_mgid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_fabric_mgid is None:
      raise TProtocol.TProtocolException(message='Required field action_fabric_mgid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_fabric_mgid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_ipv6_multicast_mac_action_spec_t:
  """
  Attributes:
   - action_smac
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_smac', None, None, ), # 1
  )

  def __init__(self, action_smac=None,):
    self.action_smac = action_smac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_smac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_ipv6_multicast_mac_action_spec_t')
    if self.action_smac is not None:
      oprot.writeFieldBegin('action_smac', TType.STRING, 1)
      oprot.writeString(self.action_smac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_smac is None:
      raise TProtocol.TProtocolException(message='Required field action_smac is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_smac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_ecmp_nexthop_details_for_post_routed_flood_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_uuc_mc_index
   - action_nhop_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_uuc_mc_index', None, None, ), # 2
    (3, TType.I16, 'action_nhop_index', None, None, ), # 3
  )

  def __init__(self, action_bd=None, action_uuc_mc_index=None, action_nhop_index=None,):
    self.action_bd = action_bd
    self.action_uuc_mc_index = action_uuc_mc_index
    self.action_nhop_index = action_nhop_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_uuc_mc_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_nhop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_ecmp_nexthop_details_for_post_routed_flood_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_uuc_mc_index is not None:
      oprot.writeFieldBegin('action_uuc_mc_index', TType.I16, 2)
      oprot.writeI16(self.action_uuc_mc_index)
      oprot.writeFieldEnd()
    if self.action_nhop_index is not None:
      oprot.writeFieldBegin('action_nhop_index', TType.I16, 3)
      oprot.writeI16(self.action_nhop_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_uuc_mc_index is None:
      raise TProtocol.TProtocolException(message='Required field action_uuc_mc_index is unset!')
    if self.action_nhop_index is None:
      raise TProtocol.TProtocolException(message='Required field action_nhop_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_uuc_mc_index)
    value = (value * 31) ^ hash(self.action_nhop_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_terminate_ipv4_over_mpls_action_spec_t:
  """
  Attributes:
   - action_vrf
   - action_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_vrf', None, None, ), # 1
    (2, TType.BYTE, 'action_tunnel_type', None, None, ), # 2
  )

  def __init__(self, action_vrf=None, action_tunnel_type=None,):
    self.action_vrf = action_vrf
    self.action_tunnel_type = action_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_terminate_ipv4_over_mpls_action_spec_t')
    if self.action_vrf is not None:
      oprot.writeFieldBegin('action_vrf', TType.I16, 1)
      oprot.writeI16(self.action_vrf)
      oprot.writeFieldEnd()
    if self.action_tunnel_type is not None:
      oprot.writeFieldBegin('action_tunnel_type', TType.BYTE, 2)
      oprot.writeByte(self.action_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_vrf is None:
      raise TProtocol.TProtocolException(message='Required field action_vrf is unset!')
    if self.action_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_vrf)
    value = (value * 31) ^ hash(self.action_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_acl_redirect_ecmp_action_spec_t:
  """
  Attributes:
   - action_ecmp_index
   - action_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_ecmp_index', None, None, ), # 1
    (2, TType.I32, 'action_acl_stats_index', None, None, ), # 2
  )

  def __init__(self, action_ecmp_index=None, action_acl_stats_index=None,):
    self.action_ecmp_index = action_ecmp_index
    self.action_acl_stats_index = action_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_ecmp_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_acl_redirect_ecmp_action_spec_t')
    if self.action_ecmp_index is not None:
      oprot.writeFieldBegin('action_ecmp_index', TType.I16, 1)
      oprot.writeI16(self.action_ecmp_index)
      oprot.writeFieldEnd()
    if self.action_acl_stats_index is not None:
      oprot.writeFieldBegin('action_acl_stats_index', TType.I32, 2)
      oprot.writeI32(self.action_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ecmp_index is None:
      raise TProtocol.TProtocolException(message='Required field action_ecmp_index is unset!')
    if self.action_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field action_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ecmp_index)
    value = (value * 31) ^ hash(self.action_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_egress_redirect_to_cpu_action_spec_t:
  """
  Attributes:
   - action_reason_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_reason_code', None, None, ), # 1
  )

  def __init__(self, action_reason_code=None,):
    self.action_reason_code = action_reason_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_reason_code = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_egress_redirect_to_cpu_action_spec_t')
    if self.action_reason_code is not None:
      oprot.writeFieldBegin('action_reason_code', TType.I16, 1)
      oprot.writeI16(self.action_reason_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_reason_code is None:
      raise TProtocol.TProtocolException(message='Required field action_reason_code is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_reason_code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_forward_mpls_action_spec_t:
  """
  Attributes:
   - action_nexthop_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_nexthop_index', None, None, ), # 1
  )

  def __init__(self, action_nexthop_index=None,):
    self.action_nexthop_index = action_nexthop_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_nexthop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_forward_mpls_action_spec_t')
    if self.action_nexthop_index is not None:
      oprot.writeFieldBegin('action_nexthop_index', TType.I16, 1)
      oprot.writeI16(self.action_nexthop_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_nexthop_index is None:
      raise TProtocol.TProtocolException(message='Required field action_nexthop_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_nexthop_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_terminate_vpls_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.BYTE, 'action_tunnel_type', None, None, ), # 2
  )

  def __init__(self, action_bd=None, action_tunnel_type=None,):
    self.action_bd = action_bd
    self.action_tunnel_type = action_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_terminate_vpls_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_tunnel_type is not None:
      oprot.writeFieldBegin('action_tunnel_type', TType.BYTE, 2)
      oprot.writeByte(self.action_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_mpls_swap_push_rewrite_l3_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_smac_idx
   - action_dmac
   - action_label
   - action_tunnel_index
   - action_header_count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_smac_idx', None, None, ), # 2
    (3, TType.STRING, 'action_dmac', None, None, ), # 3
    (4, TType.I32, 'action_label', None, None, ), # 4
    (5, TType.I16, 'action_tunnel_index', None, None, ), # 5
    (6, TType.BYTE, 'action_header_count', None, None, ), # 6
  )

  def __init__(self, action_bd=None, action_smac_idx=None, action_dmac=None, action_label=None, action_tunnel_index=None, action_header_count=None,):
    self.action_bd = action_bd
    self.action_smac_idx = action_smac_idx
    self.action_dmac = action_dmac
    self.action_label = action_label
    self.action_tunnel_index = action_tunnel_index
    self.action_header_count = action_header_count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_smac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.action_dmac = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.action_label = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.action_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.action_header_count = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_mpls_swap_push_rewrite_l3_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_smac_idx is not None:
      oprot.writeFieldBegin('action_smac_idx', TType.I16, 2)
      oprot.writeI16(self.action_smac_idx)
      oprot.writeFieldEnd()
    if self.action_dmac is not None:
      oprot.writeFieldBegin('action_dmac', TType.STRING, 3)
      oprot.writeString(self.action_dmac)
      oprot.writeFieldEnd()
    if self.action_label is not None:
      oprot.writeFieldBegin('action_label', TType.I32, 4)
      oprot.writeI32(self.action_label)
      oprot.writeFieldEnd()
    if self.action_tunnel_index is not None:
      oprot.writeFieldBegin('action_tunnel_index', TType.I16, 5)
      oprot.writeI16(self.action_tunnel_index)
      oprot.writeFieldEnd()
    if self.action_header_count is not None:
      oprot.writeFieldBegin('action_header_count', TType.BYTE, 6)
      oprot.writeByte(self.action_header_count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_smac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_smac_idx is unset!')
    if self.action_dmac is None:
      raise TProtocol.TProtocolException(message='Required field action_dmac is unset!')
    if self.action_label is None:
      raise TProtocol.TProtocolException(message='Required field action_label is unset!')
    if self.action_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_index is unset!')
    if self.action_header_count is None:
      raise TProtocol.TProtocolException(message='Required field action_header_count is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_smac_idx)
    value = (value * 31) ^ hash(self.action_dmac)
    value = (value * 31) ^ hash(self.action_label)
    value = (value * 31) ^ hash(self.action_tunnel_index)
    value = (value * 31) ^ hash(self.action_header_count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_mpls_swap_push_rewrite_l2_action_spec_t:
  """
  Attributes:
   - action_label
   - action_tunnel_index
   - action_header_count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_label', None, None, ), # 1
    (2, TType.I16, 'action_tunnel_index', None, None, ), # 2
    (3, TType.BYTE, 'action_header_count', None, None, ), # 3
  )

  def __init__(self, action_label=None, action_tunnel_index=None, action_header_count=None,):
    self.action_label = action_label
    self.action_tunnel_index = action_tunnel_index
    self.action_header_count = action_header_count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_label = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_header_count = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_mpls_swap_push_rewrite_l2_action_spec_t')
    if self.action_label is not None:
      oprot.writeFieldBegin('action_label', TType.I32, 1)
      oprot.writeI32(self.action_label)
      oprot.writeFieldEnd()
    if self.action_tunnel_index is not None:
      oprot.writeFieldBegin('action_tunnel_index', TType.I16, 2)
      oprot.writeI16(self.action_tunnel_index)
      oprot.writeFieldEnd()
    if self.action_header_count is not None:
      oprot.writeFieldBegin('action_header_count', TType.BYTE, 3)
      oprot.writeByte(self.action_header_count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_label is None:
      raise TProtocol.TProtocolException(message='Required field action_label is unset!')
    if self.action_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_index is unset!')
    if self.action_header_count is None:
      raise TProtocol.TProtocolException(message='Required field action_header_count is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_label)
    value = (value * 31) ^ hash(self.action_tunnel_index)
    value = (value * 31) ^ hash(self.action_header_count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_tunnel_rewrite_details_action_spec_t:
  """
  Attributes:
   - action_outer_bd
   - action_mtu_index
   - action_smac_idx
   - action_dmac_idx
   - action_sip_index
   - action_dip_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_outer_bd', None, None, ), # 1
    (2, TType.BYTE, 'action_mtu_index', None, None, ), # 2
    (3, TType.I16, 'action_smac_idx', None, None, ), # 3
    (4, TType.I16, 'action_dmac_idx', None, None, ), # 4
    (5, TType.I16, 'action_sip_index', None, None, ), # 5
    (6, TType.I16, 'action_dip_index', None, None, ), # 6
  )

  def __init__(self, action_outer_bd=None, action_mtu_index=None, action_smac_idx=None, action_dmac_idx=None, action_sip_index=None, action_dip_index=None,):
    self.action_outer_bd = action_outer_bd
    self.action_mtu_index = action_mtu_index
    self.action_smac_idx = action_smac_idx
    self.action_dmac_idx = action_dmac_idx
    self.action_sip_index = action_sip_index
    self.action_dip_index = action_dip_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_outer_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_mtu_index = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_smac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.action_dmac_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.action_sip_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I16:
          self.action_dip_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_tunnel_rewrite_details_action_spec_t')
    if self.action_outer_bd is not None:
      oprot.writeFieldBegin('action_outer_bd', TType.I16, 1)
      oprot.writeI16(self.action_outer_bd)
      oprot.writeFieldEnd()
    if self.action_mtu_index is not None:
      oprot.writeFieldBegin('action_mtu_index', TType.BYTE, 2)
      oprot.writeByte(self.action_mtu_index)
      oprot.writeFieldEnd()
    if self.action_smac_idx is not None:
      oprot.writeFieldBegin('action_smac_idx', TType.I16, 3)
      oprot.writeI16(self.action_smac_idx)
      oprot.writeFieldEnd()
    if self.action_dmac_idx is not None:
      oprot.writeFieldBegin('action_dmac_idx', TType.I16, 4)
      oprot.writeI16(self.action_dmac_idx)
      oprot.writeFieldEnd()
    if self.action_sip_index is not None:
      oprot.writeFieldBegin('action_sip_index', TType.I16, 5)
      oprot.writeI16(self.action_sip_index)
      oprot.writeFieldEnd()
    if self.action_dip_index is not None:
      oprot.writeFieldBegin('action_dip_index', TType.I16, 6)
      oprot.writeI16(self.action_dip_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_outer_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_outer_bd is unset!')
    if self.action_mtu_index is None:
      raise TProtocol.TProtocolException(message='Required field action_mtu_index is unset!')
    if self.action_smac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_smac_idx is unset!')
    if self.action_dmac_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_dmac_idx is unset!')
    if self.action_sip_index is None:
      raise TProtocol.TProtocolException(message='Required field action_sip_index is unset!')
    if self.action_dip_index is None:
      raise TProtocol.TProtocolException(message='Required field action_dip_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_outer_bd)
    value = (value * 31) ^ hash(self.action_mtu_index)
    value = (value * 31) ^ hash(self.action_smac_idx)
    value = (value * 31) ^ hash(self.action_dmac_idx)
    value = (value * 31) ^ hash(self.action_sip_index)
    value = (value * 31) ^ hash(self.action_dip_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_racl_permit_action_spec_t:
  """
  Attributes:
   - action_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_acl_stats_index', None, None, ), # 1
  )

  def __init__(self, action_acl_stats_index=None,):
    self.action_acl_stats_index = action_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_racl_permit_action_spec_t')
    if self.action_acl_stats_index is not None:
      oprot.writeFieldBegin('action_acl_stats_index', TType.I32, 1)
      oprot.writeI32(self.action_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field action_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_stp_state_action_spec_t:
  """
  Attributes:
   - action_stp_state
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'action_stp_state', None, None, ), # 1
  )

  def __init__(self, action_stp_state=None,):
    self.action_stp_state = action_stp_state

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.action_stp_state = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_stp_state_action_spec_t')
    if self.action_stp_state is not None:
      oprot.writeFieldBegin('action_stp_state', TType.BYTE, 1)
      oprot.writeByte(self.action_stp_state)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_stp_state is None:
      raise TProtocol.TProtocolException(message='Required field action_stp_state is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_stp_state)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_racl_deny_action_spec_t:
  """
  Attributes:
   - action_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_acl_stats_index', None, None, ), # 1
  )

  def __init__(self, action_acl_stats_index=None,):
    self.action_acl_stats_index = action_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_racl_deny_action_spec_t')
    if self.action_acl_stats_index is not None:
      oprot.writeFieldBegin('action_acl_stats_index', TType.I32, 1)
      oprot.writeI32(self.action_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field action_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_outer_replica_from_rid_with_nexthop_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_nexthop_index
   - action_tunnel_index
   - action_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_nexthop_index', None, None, ), # 2
    (3, TType.I16, 'action_tunnel_index', None, None, ), # 3
    (4, TType.BYTE, 'action_tunnel_type', None, None, ), # 4
  )

  def __init__(self, action_bd=None, action_nexthop_index=None, action_tunnel_index=None, action_tunnel_type=None,):
    self.action_bd = action_bd
    self.action_nexthop_index = action_nexthop_index
    self.action_tunnel_index = action_tunnel_index
    self.action_tunnel_type = action_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_nexthop_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.action_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_outer_replica_from_rid_with_nexthop_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_nexthop_index is not None:
      oprot.writeFieldBegin('action_nexthop_index', TType.I16, 2)
      oprot.writeI16(self.action_nexthop_index)
      oprot.writeFieldEnd()
    if self.action_tunnel_index is not None:
      oprot.writeFieldBegin('action_tunnel_index', TType.I16, 3)
      oprot.writeI16(self.action_tunnel_index)
      oprot.writeFieldEnd()
    if self.action_tunnel_type is not None:
      oprot.writeFieldBegin('action_tunnel_type', TType.BYTE, 4)
      oprot.writeByte(self.action_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_nexthop_index is None:
      raise TProtocol.TProtocolException(message='Required field action_nexthop_index is unset!')
    if self.action_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_index is unset!')
    if self.action_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_nexthop_index)
    value = (value * 31) ^ hash(self.action_tunnel_index)
    value = (value * 31) ^ hash(self.action_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv4_urpf_hit_action_spec_t:
  """
  Attributes:
   - action_urpf_bd_group
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_urpf_bd_group', None, None, ), # 1
  )

  def __init__(self, action_urpf_bd_group=None,):
    self.action_urpf_bd_group = action_urpf_bd_group

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_urpf_bd_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv4_urpf_hit_action_spec_t')
    if self.action_urpf_bd_group is not None:
      oprot.writeFieldBegin('action_urpf_bd_group', TType.I16, 1)
      oprot.writeI16(self.action_urpf_bd_group)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_urpf_bd_group is None:
      raise TProtocol.TProtocolException(message='Required field action_urpf_bd_group is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_urpf_bd_group)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_terminate_tunnel_inner_ipv6_action_spec_t:
  """
  Attributes:
   - action_vrf
   - action_rmac_group
   - action_ipv6_unicast_enabled
   - action_ipv6_urpf_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_vrf', None, None, ), # 1
    (2, TType.I16, 'action_rmac_group', None, None, ), # 2
    (3, TType.BYTE, 'action_ipv6_unicast_enabled', None, None, ), # 3
    (4, TType.BYTE, 'action_ipv6_urpf_mode', None, None, ), # 4
  )

  def __init__(self, action_vrf=None, action_rmac_group=None, action_ipv6_unicast_enabled=None, action_ipv6_urpf_mode=None,):
    self.action_vrf = action_vrf
    self.action_rmac_group = action_rmac_group
    self.action_ipv6_unicast_enabled = action_ipv6_unicast_enabled
    self.action_ipv6_urpf_mode = action_ipv6_urpf_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_rmac_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_ipv6_unicast_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.action_ipv6_urpf_mode = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_terminate_tunnel_inner_ipv6_action_spec_t')
    if self.action_vrf is not None:
      oprot.writeFieldBegin('action_vrf', TType.I16, 1)
      oprot.writeI16(self.action_vrf)
      oprot.writeFieldEnd()
    if self.action_rmac_group is not None:
      oprot.writeFieldBegin('action_rmac_group', TType.I16, 2)
      oprot.writeI16(self.action_rmac_group)
      oprot.writeFieldEnd()
    if self.action_ipv6_unicast_enabled is not None:
      oprot.writeFieldBegin('action_ipv6_unicast_enabled', TType.BYTE, 3)
      oprot.writeByte(self.action_ipv6_unicast_enabled)
      oprot.writeFieldEnd()
    if self.action_ipv6_urpf_mode is not None:
      oprot.writeFieldBegin('action_ipv6_urpf_mode', TType.BYTE, 4)
      oprot.writeByte(self.action_ipv6_urpf_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_vrf is None:
      raise TProtocol.TProtocolException(message='Required field action_vrf is unset!')
    if self.action_rmac_group is None:
      raise TProtocol.TProtocolException(message='Required field action_rmac_group is unset!')
    if self.action_ipv6_unicast_enabled is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv6_unicast_enabled is unset!')
    if self.action_ipv6_urpf_mode is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv6_urpf_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_vrf)
    value = (value * 31) ^ hash(self.action_rmac_group)
    value = (value * 31) ^ hash(self.action_ipv6_unicast_enabled)
    value = (value * 31) ^ hash(self.action_ipv6_urpf_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_ipv6_urpf_hit_action_spec_t:
  """
  Attributes:
   - action_urpf_bd_group
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_urpf_bd_group', None, None, ), # 1
  )

  def __init__(self, action_urpf_bd_group=None,):
    self.action_urpf_bd_group = action_urpf_bd_group

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_urpf_bd_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_ipv6_urpf_hit_action_spec_t')
    if self.action_urpf_bd_group is not None:
      oprot.writeFieldBegin('action_urpf_bd_group', TType.I16, 1)
      oprot.writeI16(self.action_urpf_bd_group)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_urpf_bd_group is None:
      raise TProtocol.TProtocolException(message='Required field action_urpf_bd_group is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_urpf_bd_group)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_drop_packet_with_reason_action_spec_t:
  """
  Attributes:
   - action_drop_reason
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_drop_reason', None, None, ), # 1
  )

  def __init__(self, action_drop_reason=None,):
    self.action_drop_reason = action_drop_reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_drop_reason = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_drop_packet_with_reason_action_spec_t')
    if self.action_drop_reason is not None:
      oprot.writeFieldBegin('action_drop_reason', TType.I32, 1)
      oprot.writeI32(self.action_drop_reason)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_drop_reason is None:
      raise TProtocol.TProtocolException(message='Required field action_drop_reason is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_drop_reason)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_ipv4_unicast_mac_action_spec_t:
  """
  Attributes:
   - action_smac
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_smac', None, None, ), # 1
  )

  def __init__(self, action_smac=None,):
    self.action_smac = action_smac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_smac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_ipv4_unicast_mac_action_spec_t')
    if self.action_smac is not None:
      oprot.writeFieldBegin('action_smac', TType.STRING, 1)
      oprot.writeString(self.action_smac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_smac is None:
      raise TProtocol.TProtocolException(message='Required field action_smac is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_smac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_terminate_pw_action_spec_t:
  """
  Attributes:
   - action_ifindex
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_ifindex', None, None, ), # 1
  )

  def __init__(self, action_ifindex=None,):
    self.action_ifindex = action_ifindex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_terminate_pw_action_spec_t')
    if self.action_ifindex is not None:
      oprot.writeFieldBegin('action_ifindex', TType.I16, 1)
      oprot.writeI16(self.action_ifindex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field action_ifindex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ifindex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_dmac_multicast_hit_action_spec_t:
  """
  Attributes:
   - action_mc_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_mc_index', None, None, ), # 1
  )

  def __init__(self, action_mc_index=None,):
    self.action_mc_index = action_mc_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_mc_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_dmac_multicast_hit_action_spec_t')
    if self.action_mc_index is not None:
      oprot.writeFieldBegin('action_mc_index', TType.I16, 1)
      oprot.writeI16(self.action_mc_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_mc_index is None:
      raise TProtocol.TProtocolException(message='Required field action_mc_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_mc_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_tunnel_ipv6_dst_action_spec_t:
  """
  Attributes:
   - action_ip
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_ip', None, None, ), # 1
  )

  def __init__(self, action_ip=None,):
    self.action_ip = action_ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_ip = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_tunnel_ipv6_dst_action_spec_t')
    if self.action_ip is not None:
      oprot.writeFieldBegin('action_ip', TType.STRING, 1)
      oprot.writeString(self.action_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ip is None:
      raise TProtocol.TProtocolException(message='Required field action_ip is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ip)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_terminate_tunnel_inner_ethernet_ipv4_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_vrf
   - action_rmac_group
   - action_bd_label
   - action_ipv4_unicast_enabled
   - action_ipv4_urpf_mode
   - action_igmp_snooping_enabled
   - action_stats_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_vrf', None, None, ), # 2
    (3, TType.I16, 'action_rmac_group', None, None, ), # 3
    (4, TType.I16, 'action_bd_label', None, None, ), # 4
    (5, TType.BYTE, 'action_ipv4_unicast_enabled', None, None, ), # 5
    (6, TType.BYTE, 'action_ipv4_urpf_mode', None, None, ), # 6
    (7, TType.BYTE, 'action_igmp_snooping_enabled', None, None, ), # 7
    (8, TType.I16, 'action_stats_idx', None, None, ), # 8
  )

  def __init__(self, action_bd=None, action_vrf=None, action_rmac_group=None, action_bd_label=None, action_ipv4_unicast_enabled=None, action_ipv4_urpf_mode=None, action_igmp_snooping_enabled=None, action_stats_idx=None,):
    self.action_bd = action_bd
    self.action_vrf = action_vrf
    self.action_rmac_group = action_rmac_group
    self.action_bd_label = action_bd_label
    self.action_ipv4_unicast_enabled = action_ipv4_unicast_enabled
    self.action_ipv4_urpf_mode = action_ipv4_urpf_mode
    self.action_igmp_snooping_enabled = action_igmp_snooping_enabled
    self.action_stats_idx = action_stats_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_rmac_group = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.action_bd_label = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.action_ipv4_unicast_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.action_ipv4_urpf_mode = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BYTE:
          self.action_igmp_snooping_enabled = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I16:
          self.action_stats_idx = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_terminate_tunnel_inner_ethernet_ipv4_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_vrf is not None:
      oprot.writeFieldBegin('action_vrf', TType.I16, 2)
      oprot.writeI16(self.action_vrf)
      oprot.writeFieldEnd()
    if self.action_rmac_group is not None:
      oprot.writeFieldBegin('action_rmac_group', TType.I16, 3)
      oprot.writeI16(self.action_rmac_group)
      oprot.writeFieldEnd()
    if self.action_bd_label is not None:
      oprot.writeFieldBegin('action_bd_label', TType.I16, 4)
      oprot.writeI16(self.action_bd_label)
      oprot.writeFieldEnd()
    if self.action_ipv4_unicast_enabled is not None:
      oprot.writeFieldBegin('action_ipv4_unicast_enabled', TType.BYTE, 5)
      oprot.writeByte(self.action_ipv4_unicast_enabled)
      oprot.writeFieldEnd()
    if self.action_ipv4_urpf_mode is not None:
      oprot.writeFieldBegin('action_ipv4_urpf_mode', TType.BYTE, 6)
      oprot.writeByte(self.action_ipv4_urpf_mode)
      oprot.writeFieldEnd()
    if self.action_igmp_snooping_enabled is not None:
      oprot.writeFieldBegin('action_igmp_snooping_enabled', TType.BYTE, 7)
      oprot.writeByte(self.action_igmp_snooping_enabled)
      oprot.writeFieldEnd()
    if self.action_stats_idx is not None:
      oprot.writeFieldBegin('action_stats_idx', TType.I16, 8)
      oprot.writeI16(self.action_stats_idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_vrf is None:
      raise TProtocol.TProtocolException(message='Required field action_vrf is unset!')
    if self.action_rmac_group is None:
      raise TProtocol.TProtocolException(message='Required field action_rmac_group is unset!')
    if self.action_bd_label is None:
      raise TProtocol.TProtocolException(message='Required field action_bd_label is unset!')
    if self.action_ipv4_unicast_enabled is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv4_unicast_enabled is unset!')
    if self.action_ipv4_urpf_mode is None:
      raise TProtocol.TProtocolException(message='Required field action_ipv4_urpf_mode is unset!')
    if self.action_igmp_snooping_enabled is None:
      raise TProtocol.TProtocolException(message='Required field action_igmp_snooping_enabled is unset!')
    if self.action_stats_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_stats_idx is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_vrf)
    value = (value * 31) ^ hash(self.action_rmac_group)
    value = (value * 31) ^ hash(self.action_bd_label)
    value = (value * 31) ^ hash(self.action_ipv4_unicast_enabled)
    value = (value * 31) ^ hash(self.action_ipv4_urpf_mode)
    value = (value * 31) ^ hash(self.action_igmp_snooping_enabled)
    value = (value * 31) ^ hash(self.action_stats_idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_egress_mirror_drop_action_spec_t:
  """
  Attributes:
   - action_session_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_session_id', None, None, ), # 1
  )

  def __init__(self, action_session_id=None,):
    self.action_session_id = action_session_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_session_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_egress_mirror_drop_action_spec_t')
    if self.action_session_id is not None:
      oprot.writeFieldBegin('action_session_id', TType.I32, 1)
      oprot.writeI32(self.action_session_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_session_id is None:
      raise TProtocol.TProtocolException(message='Required field action_session_id is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_session_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_mirror_bd_action_spec_t:
  """
  Attributes:
   - action_bd
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
  )

  def __init__(self, action_bd=None,):
    self.action_bd = action_bd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_mirror_bd_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_set_lag_port_action_spec_t:
  """
  Attributes:
   - action_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_port', None, None, ), # 1
  )

  def __init__(self, action_port=None,):
    self.action_port = action_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_set_lag_port_action_spec_t')
    if self.action_port is not None:
      oprot.writeFieldBegin('action_port', TType.I16, 1)
      oprot.writeI16(self.action_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_port is None:
      raise TProtocol.TProtocolException(message='Required field action_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_terminate_ipv6_over_mpls_action_spec_t:
  """
  Attributes:
   - action_vrf
   - action_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_vrf', None, None, ), # 1
    (2, TType.BYTE, 'action_tunnel_type', None, None, ), # 2
  )

  def __init__(self, action_vrf=None, action_tunnel_type=None,):
    self.action_vrf = action_vrf
    self.action_tunnel_type = action_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_vrf = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_terminate_ipv6_over_mpls_action_spec_t')
    if self.action_vrf is not None:
      oprot.writeFieldBegin('action_vrf', TType.I16, 1)
      oprot.writeI16(self.action_vrf)
      oprot.writeFieldEnd()
    if self.action_tunnel_type is not None:
      oprot.writeFieldBegin('action_tunnel_type', TType.BYTE, 2)
      oprot.writeByte(self.action_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_vrf is None:
      raise TProtocol.TProtocolException(message='Required field action_vrf is unset!')
    if self.action_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_vrf)
    value = (value * 31) ^ hash(self.action_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_rewrite_tunnel_ipv4_src_action_spec_t:
  """
  Attributes:
   - action_ip
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_ip', None, None, ), # 1
  )

  def __init__(self, action_ip=None,):
    self.action_ip = action_ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_ip = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_rewrite_tunnel_ipv4_src_action_spec_t')
    if self.action_ip is not None:
      oprot.writeFieldBegin('action_ip', TType.I32, 1)
      oprot.writeI32(self.action_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_ip is None:
      raise TProtocol.TProtocolException(message='Required field action_ip is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_ip)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_outer_replica_from_rid_action_spec_t:
  """
  Attributes:
   - action_bd
   - action_tunnel_index
   - action_tunnel_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_bd', None, None, ), # 1
    (2, TType.I16, 'action_tunnel_index', None, None, ), # 2
    (3, TType.BYTE, 'action_tunnel_type', None, None, ), # 3
  )

  def __init__(self, action_bd=None, action_tunnel_index=None, action_tunnel_type=None,):
    self.action_bd = action_bd
    self.action_tunnel_index = action_tunnel_index
    self.action_tunnel_type = action_tunnel_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_tunnel_index = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_tunnel_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_outer_replica_from_rid_action_spec_t')
    if self.action_bd is not None:
      oprot.writeFieldBegin('action_bd', TType.I16, 1)
      oprot.writeI16(self.action_bd)
      oprot.writeFieldEnd()
    if self.action_tunnel_index is not None:
      oprot.writeFieldBegin('action_tunnel_index', TType.I16, 2)
      oprot.writeI16(self.action_tunnel_index)
      oprot.writeFieldEnd()
    if self.action_tunnel_type is not None:
      oprot.writeFieldBegin('action_tunnel_type', TType.BYTE, 3)
      oprot.writeByte(self.action_tunnel_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_bd is None:
      raise TProtocol.TProtocolException(message='Required field action_bd is unset!')
    if self.action_tunnel_index is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_index is unset!')
    if self.action_tunnel_type is None:
      raise TProtocol.TProtocolException(message='Required field action_tunnel_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_bd)
    value = (value * 31) ^ hash(self.action_tunnel_index)
    value = (value * 31) ^ hash(self.action_tunnel_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_malformed_outer_ethernet_packet_action_spec_t:
  """
  Attributes:
   - action_drop_reason
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'action_drop_reason', None, None, ), # 1
  )

  def __init__(self, action_drop_reason=None,):
    self.action_drop_reason = action_drop_reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.action_drop_reason = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_malformed_outer_ethernet_packet_action_spec_t')
    if self.action_drop_reason is not None:
      oprot.writeFieldBegin('action_drop_reason', TType.BYTE, 1)
      oprot.writeByte(self.action_drop_reason)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_drop_reason is None:
      raise TProtocol.TProtocolException(message='Required field action_drop_reason is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_drop_reason)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_acl_deny_action_spec_t:
  """
  Attributes:
   - action_acl_stats_index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_acl_stats_index', None, None, ), # 1
  )

  def __init__(self, action_acl_stats_index=None,):
    self.action_acl_stats_index = action_acl_stats_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_acl_stats_index = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_acl_deny_action_spec_t')
    if self.action_acl_stats_index is not None:
      oprot.writeFieldBegin('action_acl_stats_index', TType.I32, 1)
      oprot.writeI32(self.action_acl_stats_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_acl_stats_index is None:
      raise TProtocol.TProtocolException(message='Required field action_acl_stats_index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_acl_stats_index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_mac_learn_digest_digest_entry_t:
  """
  Attributes:
   - ingress_metadata_bd
   - l2_metadata_lkp_mac_sa
   - ingress_metadata_ifindex
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'ingress_metadata_bd', None, None, ), # 1
    (2, TType.LIST, 'l2_metadata_lkp_mac_sa', (TType.BYTE,None), None, ), # 2
    (3, TType.I16, 'ingress_metadata_ifindex', None, None, ), # 3
  )

  def __init__(self, ingress_metadata_bd=None, l2_metadata_lkp_mac_sa=None, ingress_metadata_ifindex=None,):
    self.ingress_metadata_bd = ingress_metadata_bd
    self.l2_metadata_lkp_mac_sa = l2_metadata_lkp_mac_sa
    self.ingress_metadata_ifindex = ingress_metadata_ifindex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.ingress_metadata_bd = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.l2_metadata_lkp_mac_sa = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readByte()
            self.l2_metadata_lkp_mac_sa.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.ingress_metadata_ifindex = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_mac_learn_digest_digest_entry_t')
    if self.ingress_metadata_bd is not None:
      oprot.writeFieldBegin('ingress_metadata_bd', TType.I16, 1)
      oprot.writeI16(self.ingress_metadata_bd)
      oprot.writeFieldEnd()
    if self.l2_metadata_lkp_mac_sa is not None:
      oprot.writeFieldBegin('l2_metadata_lkp_mac_sa', TType.LIST, 2)
      oprot.writeListBegin(TType.BYTE, len(self.l2_metadata_lkp_mac_sa))
      for iter6 in self.l2_metadata_lkp_mac_sa:
        oprot.writeByte(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ingress_metadata_ifindex is not None:
      oprot.writeFieldBegin('ingress_metadata_ifindex', TType.I16, 3)
      oprot.writeI16(self.ingress_metadata_ifindex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ingress_metadata_bd is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_bd is unset!')
    if self.l2_metadata_lkp_mac_sa is None:
      raise TProtocol.TProtocolException(message='Required field l2_metadata_lkp_mac_sa is unset!')
    if self.ingress_metadata_ifindex is None:
      raise TProtocol.TProtocolException(message='Required field ingress_metadata_ifindex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ingress_metadata_bd)
    value = (value * 31) ^ hash(self.l2_metadata_lkp_mac_sa)
    value = (value * 31) ^ hash(self.ingress_metadata_ifindex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dc_mac_learn_digest_digest_msg_t:
  """
  Attributes:
   - dev_tgt
   - msg
   - msg_ptr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 1
    (2, TType.LIST, 'msg', (TType.STRUCT,(dc_mac_learn_digest_digest_entry_t, dc_mac_learn_digest_digest_entry_t.thrift_spec)), None, ), # 2
    (3, TType.I64, 'msg_ptr', None, None, ), # 3
  )

  def __init__(self, dev_tgt=None, msg=None, msg_ptr=None,):
    self.dev_tgt = dev_tgt
    self.msg = msg
    self.msg_ptr = msg_ptr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.msg = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = dc_mac_learn_digest_digest_entry_t()
            _elem12.read(iprot)
            self.msg.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.msg_ptr = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dc_mac_learn_digest_digest_msg_t')
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.msg))
      for iter13 in self.msg:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.msg_ptr is not None:
      oprot.writeFieldBegin('msg_ptr', TType.I64, 3)
      oprot.writeI64(self.msg_ptr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dev_tgt is None:
      raise TProtocol.TProtocolException(message='Required field dev_tgt is unset!')
    if self.msg is None:
      raise TProtocol.TProtocolException(message='Required field msg is unset!')
    if self.msg_ptr is None:
      raise TProtocol.TProtocolException(message='Required field msg_ptr is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.msg)
    value = (value * 31) ^ hash(self.msg_ptr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
