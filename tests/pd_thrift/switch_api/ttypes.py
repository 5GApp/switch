#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class switcht_neighbor_type_t:
  SWITCHT_API_NEIGHBOR_L3_UNICAST = 0
  SWITCHT_API_NEIGHBOR_MPLS_L2VPN = 1
  SWITCHT_API_NEIGHBOR_MPLS_L3VPN = 2

  _VALUES_TO_NAMES = {
    0: "SWITCHT_API_NEIGHBOR_L3_UNICAST",
    1: "SWITCHT_API_NEIGHBOR_MPLS_L2VPN",
    2: "SWITCHT_API_NEIGHBOR_MPLS_L3VPN",
  }

  _NAMES_TO_VALUES = {
    "SWITCHT_API_NEIGHBOR_L3_UNICAST": 0,
    "SWITCHT_API_NEIGHBOR_MPLS_L2VPN": 1,
    "SWITCHT_API_NEIGHBOR_MPLS_L3VPN": 2,
  }

class switcht_neighbor_rw_type_t:
  SWITCH_API_NEIGHBOR_RW_TYPE_L2 = 0
  SWITCH_API_NEIGHBOR_RW_TYPE_L3 = 1

  _VALUES_TO_NAMES = {
    0: "SWITCH_API_NEIGHBOR_RW_TYPE_L2",
    1: "SWITCH_API_NEIGHBOR_RW_TYPE_L3",
  }

  _NAMES_TO_VALUES = {
    "SWITCH_API_NEIGHBOR_RW_TYPE_L2": 0,
    "SWITCH_API_NEIGHBOR_RW_TYPE_L3": 1,
  }

class switcht_mpls_type_t:
  SWITCHT_API_MPLS_TYPE_EOMPLS = 0
  SWITCHT_API_MPLS_TYPE_IPV4_MPLS = 1
  SWITCHT_API_MPLS_TYPE_IPV6_MPLS = 2
  SWITCHT_API_MPLS_TYPE_VPLS = 3
  SWITCHT_API_MPLS_TYPE_PW = 4

  _VALUES_TO_NAMES = {
    0: "SWITCHT_API_MPLS_TYPE_EOMPLS",
    1: "SWITCHT_API_MPLS_TYPE_IPV4_MPLS",
    2: "SWITCHT_API_MPLS_TYPE_IPV6_MPLS",
    3: "SWITCHT_API_MPLS_TYPE_VPLS",
    4: "SWITCHT_API_MPLS_TYPE_PW",
  }

  _NAMES_TO_VALUES = {
    "SWITCHT_API_MPLS_TYPE_EOMPLS": 0,
    "SWITCHT_API_MPLS_TYPE_IPV4_MPLS": 1,
    "SWITCHT_API_MPLS_TYPE_IPV6_MPLS": 2,
    "SWITCHT_API_MPLS_TYPE_VPLS": 3,
    "SWITCHT_API_MPLS_TYPE_PW": 4,
  }

class switcht_mpls_mode_t:
  SWITCHT_API_MPLS_INITIATE = 0
  SWITCHT_API_MPLS_TRANSIT = 1
  SWITCHT_API_MPLS_TERMINATE = 2

  _VALUES_TO_NAMES = {
    0: "SWITCHT_API_MPLS_INITIATE",
    1: "SWITCHT_API_MPLS_TRANSIT",
    2: "SWITCHT_API_MPLS_TERMINATE",
  }

  _NAMES_TO_VALUES = {
    "SWITCHT_API_MPLS_INITIATE": 0,
    "SWITCHT_API_MPLS_TRANSIT": 1,
    "SWITCHT_API_MPLS_TERMINATE": 2,
  }

class switcht_mpls_action_t:
  SWITCHT_API_MPLS_ACTION_POP = 0
  SWITCHT_API_MPLS_ACTION_PUSH = 1
  SWITCHT_API_MPLS_ACTION_SWAP = 2
  SWITCHT_API_MPLS_ACTION_SWAP_PUSH = 3

  _VALUES_TO_NAMES = {
    0: "SWITCHT_API_MPLS_ACTION_POP",
    1: "SWITCHT_API_MPLS_ACTION_PUSH",
    2: "SWITCHT_API_MPLS_ACTION_SWAP",
    3: "SWITCHT_API_MPLS_ACTION_SWAP_PUSH",
  }

  _NAMES_TO_VALUES = {
    "SWITCHT_API_MPLS_ACTION_POP": 0,
    "SWITCHT_API_MPLS_ACTION_PUSH": 1,
    "SWITCHT_API_MPLS_ACTION_SWAP": 2,
    "SWITCHT_API_MPLS_ACTION_SWAP_PUSH": 3,
  }

class switcht_encap_mode_t:
  SWITCHT_API_TUNNEL_ENCAP_MODE_IP = 0
  SWITCHT_API_TUNNEL_ENCAP_MODE_MPLS = 1

  _VALUES_TO_NAMES = {
    0: "SWITCHT_API_TUNNEL_ENCAP_MODE_IP",
    1: "SWITCHT_API_TUNNEL_ENCAP_MODE_MPLS",
  }

  _NAMES_TO_VALUES = {
    "SWITCHT_API_TUNNEL_ENCAP_MODE_IP": 0,
    "SWITCHT_API_TUNNEL_ENCAP_MODE_MPLS": 1,
  }


class switcht_port_info_t:
  """
  Attributes:
   - port_number
   - l2mtu
   - l3mtu
   - vrf
   - tunnel_term
   - ipv4_term
   - v6_vrf
   - ipv6_term
   - igmp_snoop
   - urpf_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'port_number', None, None, ), # 1
    (2, TType.I32, 'l2mtu', None, None, ), # 2
    (3, TType.I32, 'l3mtu', None, None, ), # 3
    (4, TType.I32, 'vrf', None, None, ), # 4
    (5, TType.BOOL, 'tunnel_term', None, None, ), # 5
    (6, TType.BOOL, 'ipv4_term', None, True, ), # 6
    (7, TType.I32, 'v6_vrf', None, None, ), # 7
    (8, TType.BOOL, 'ipv6_term', None, None, ), # 8
    (9, TType.BOOL, 'igmp_snoop', None, None, ), # 9
    (10, TType.BYTE, 'urpf_mode', None, 0, ), # 10
  )

  def __init__(self, port_number=None, l2mtu=None, l3mtu=None, vrf=None, tunnel_term=None, ipv4_term=thrift_spec[6][4], v6_vrf=None, ipv6_term=None, igmp_snoop=None, urpf_mode=thrift_spec[10][4],):
    self.port_number = port_number
    self.l2mtu = l2mtu
    self.l3mtu = l3mtu
    self.vrf = vrf
    self.tunnel_term = tunnel_term
    self.ipv4_term = ipv4_term
    self.v6_vrf = v6_vrf
    self.ipv6_term = ipv6_term
    self.igmp_snoop = igmp_snoop
    self.urpf_mode = urpf_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.port_number = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.l2mtu = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l3mtu = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.vrf = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.tunnel_term = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.ipv4_term = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.v6_vrf = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.ipv6_term = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.igmp_snoop = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BYTE:
          self.urpf_mode = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_port_info_t')
    if self.port_number is not None:
      oprot.writeFieldBegin('port_number', TType.I32, 1)
      oprot.writeI32(self.port_number)
      oprot.writeFieldEnd()
    if self.l2mtu is not None:
      oprot.writeFieldBegin('l2mtu', TType.I32, 2)
      oprot.writeI32(self.l2mtu)
      oprot.writeFieldEnd()
    if self.l3mtu is not None:
      oprot.writeFieldBegin('l3mtu', TType.I32, 3)
      oprot.writeI32(self.l3mtu)
      oprot.writeFieldEnd()
    if self.vrf is not None:
      oprot.writeFieldBegin('vrf', TType.I32, 4)
      oprot.writeI32(self.vrf)
      oprot.writeFieldEnd()
    if self.tunnel_term is not None:
      oprot.writeFieldBegin('tunnel_term', TType.BOOL, 5)
      oprot.writeBool(self.tunnel_term)
      oprot.writeFieldEnd()
    if self.ipv4_term is not None:
      oprot.writeFieldBegin('ipv4_term', TType.BOOL, 6)
      oprot.writeBool(self.ipv4_term)
      oprot.writeFieldEnd()
    if self.v6_vrf is not None:
      oprot.writeFieldBegin('v6_vrf', TType.I32, 7)
      oprot.writeI32(self.v6_vrf)
      oprot.writeFieldEnd()
    if self.ipv6_term is not None:
      oprot.writeFieldBegin('ipv6_term', TType.BOOL, 8)
      oprot.writeBool(self.ipv6_term)
      oprot.writeFieldEnd()
    if self.igmp_snoop is not None:
      oprot.writeFieldBegin('igmp_snoop', TType.BOOL, 9)
      oprot.writeBool(self.igmp_snoop)
      oprot.writeFieldEnd()
    if self.urpf_mode is not None:
      oprot.writeFieldBegin('urpf_mode', TType.BYTE, 10)
      oprot.writeByte(self.urpf_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.port_number is None:
      raise TProtocol.TProtocolException(message='Required field port_number is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.port_number)
    value = (value * 31) ^ hash(self.l2mtu)
    value = (value * 31) ^ hash(self.l3mtu)
    value = (value * 31) ^ hash(self.vrf)
    value = (value * 31) ^ hash(self.tunnel_term)
    value = (value * 31) ^ hash(self.ipv4_term)
    value = (value * 31) ^ hash(self.v6_vrf)
    value = (value * 31) ^ hash(self.ipv6_term)
    value = (value * 31) ^ hash(self.igmp_snoop)
    value = (value * 31) ^ hash(self.urpf_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_ip_addr_t:
  """
  Attributes:
   - addr_type
   - ipaddr
   - prefix_length
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'addr_type', None, None, ), # 1
    (2, TType.STRING, 'ipaddr', None, None, ), # 2
    (3, TType.I32, 'prefix_length', None, None, ), # 3
  )

  def __init__(self, addr_type=None, ipaddr=None, prefix_length=None,):
    self.addr_type = addr_type
    self.ipaddr = ipaddr
    self.prefix_length = prefix_length

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.addr_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ipaddr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.prefix_length = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_ip_addr_t')
    if self.addr_type is not None:
      oprot.writeFieldBegin('addr_type', TType.BYTE, 1)
      oprot.writeByte(self.addr_type)
      oprot.writeFieldEnd()
    if self.ipaddr is not None:
      oprot.writeFieldBegin('ipaddr', TType.STRING, 2)
      oprot.writeString(self.ipaddr)
      oprot.writeFieldEnd()
    if self.prefix_length is not None:
      oprot.writeFieldBegin('prefix_length', TType.I32, 3)
      oprot.writeI32(self.prefix_length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.addr_type)
    value = (value * 31) ^ hash(self.ipaddr)
    value = (value * 31) ^ hash(self.prefix_length)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_port_vlan_t:
  """
  Attributes:
   - port_lag_handle
   - vlan_id
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.I32, 'port_lag_handle', None, None, ), # 2
    (3, TType.I16, 'vlan_id', None, None, ), # 3
  )

  def __init__(self, port_lag_handle=None, vlan_id=None,):
    self.port_lag_handle = port_lag_handle
    self.vlan_id = vlan_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.I32:
          self.port_lag_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.vlan_id = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_port_vlan_t')
    if self.port_lag_handle is not None:
      oprot.writeFieldBegin('port_lag_handle', TType.I32, 2)
      oprot.writeI32(self.port_lag_handle)
      oprot.writeFieldEnd()
    if self.vlan_id is not None:
      oprot.writeFieldBegin('vlan_id', TType.I16, 3)
      oprot.writeI16(self.vlan_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.port_lag_handle)
    value = (value * 31) ^ hash(self.vlan_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_udp_t:
  """
  Attributes:
   - src_port
   - dst_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'src_port', None, None, ), # 1
    (2, TType.I16, 'dst_port', None, None, ), # 2
  )

  def __init__(self, src_port=None, dst_port=None,):
    self.src_port = src_port
    self.dst_port = dst_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.src_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.dst_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_udp_t')
    if self.src_port is not None:
      oprot.writeFieldBegin('src_port', TType.I16, 1)
      oprot.writeI16(self.src_port)
      oprot.writeFieldEnd()
    if self.dst_port is not None:
      oprot.writeFieldBegin('dst_port', TType.I16, 2)
      oprot.writeI16(self.dst_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.src_port)
    value = (value * 31) ^ hash(self.dst_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_tcp_t:
  """
  Attributes:
   - src_port
   - dst_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'src_port', None, None, ), # 1
    (2, TType.I16, 'dst_port', None, None, ), # 2
  )

  def __init__(self, src_port=None, dst_port=None,):
    self.src_port = src_port
    self.dst_port = dst_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.src_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.dst_port = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_tcp_t')
    if self.src_port is not None:
      oprot.writeFieldBegin('src_port', TType.I16, 1)
      oprot.writeI16(self.src_port)
      oprot.writeFieldEnd()
    if self.dst_port is not None:
      oprot.writeFieldBegin('dst_port', TType.I16, 2)
      oprot.writeI16(self.dst_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.src_port)
    value = (value * 31) ^ hash(self.dst_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_udp_tcp_t:
  """
  Attributes:
   - udp
   - tcp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'udp', (switcht_udp_t, switcht_udp_t.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'tcp', (switcht_tcp_t, switcht_tcp_t.thrift_spec), None, ), # 2
  )

  def __init__(self, udp=None, tcp=None,):
    self.udp = udp
    self.tcp = tcp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.udp = switcht_udp_t()
          self.udp.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tcp = switcht_tcp_t()
          self.tcp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_udp_tcp_t')
    if self.udp is not None:
      oprot.writeFieldBegin('udp', TType.STRUCT, 1)
      self.udp.write(oprot)
      oprot.writeFieldEnd()
    if self.tcp is not None:
      oprot.writeFieldBegin('tcp', TType.STRUCT, 2)
      self.tcp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.udp)
    value = (value * 31) ^ hash(self.tcp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_ip_encap_t:
  """
  Attributes:
   - vrf
   - src_ip
   - dst_ip
   - ttl
   - proto
   - u
   - gre_proto
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'vrf', None, None, ), # 1
    (2, TType.STRUCT, 'src_ip', (switcht_ip_addr_t, switcht_ip_addr_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'dst_ip', (switcht_ip_addr_t, switcht_ip_addr_t.thrift_spec), None, ), # 3
    (4, TType.BYTE, 'ttl', None, None, ), # 4
    (5, TType.I32, 'proto', None, None, ), # 5
    (6, TType.STRUCT, 'u', (switcht_udp_tcp_t, switcht_udp_tcp_t.thrift_spec), None, ), # 6
    (7, TType.I16, 'gre_proto', None, None, ), # 7
  )

  def __init__(self, vrf=None, src_ip=None, dst_ip=None, ttl=None, proto=None, u=None, gre_proto=None,):
    self.vrf = vrf
    self.src_ip = src_ip
    self.dst_ip = dst_ip
    self.ttl = ttl
    self.proto = proto
    self.u = u
    self.gre_proto = gre_proto

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.vrf = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.src_ip = switcht_ip_addr_t()
          self.src_ip.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.dst_ip = switcht_ip_addr_t()
          self.dst_ip.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.ttl = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.proto = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.u = switcht_udp_tcp_t()
          self.u.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.gre_proto = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_ip_encap_t')
    if self.vrf is not None:
      oprot.writeFieldBegin('vrf', TType.I32, 1)
      oprot.writeI32(self.vrf)
      oprot.writeFieldEnd()
    if self.src_ip is not None:
      oprot.writeFieldBegin('src_ip', TType.STRUCT, 2)
      self.src_ip.write(oprot)
      oprot.writeFieldEnd()
    if self.dst_ip is not None:
      oprot.writeFieldBegin('dst_ip', TType.STRUCT, 3)
      self.dst_ip.write(oprot)
      oprot.writeFieldEnd()
    if self.ttl is not None:
      oprot.writeFieldBegin('ttl', TType.BYTE, 4)
      oprot.writeByte(self.ttl)
      oprot.writeFieldEnd()
    if self.proto is not None:
      oprot.writeFieldBegin('proto', TType.I32, 5)
      oprot.writeI32(self.proto)
      oprot.writeFieldEnd()
    if self.u is not None:
      oprot.writeFieldBegin('u', TType.STRUCT, 6)
      self.u.write(oprot)
      oprot.writeFieldEnd()
    if self.gre_proto is not None:
      oprot.writeFieldBegin('gre_proto', TType.I16, 7)
      oprot.writeI16(self.gre_proto)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vrf)
    value = (value * 31) ^ hash(self.src_ip)
    value = (value * 31) ^ hash(self.dst_ip)
    value = (value * 31) ^ hash(self.ttl)
    value = (value * 31) ^ hash(self.proto)
    value = (value * 31) ^ hash(self.u)
    value = (value * 31) ^ hash(self.gre_proto)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class interface_union:
  """
  Attributes:
   - port_lag_handle
   - vlan_id: < LAG handle
   - port_vlan: < VLAN
   - ip_encap: < Port-VLAN
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'port_lag_handle', None, None, ), # 1
    (2, TType.I16, 'vlan_id', None, None, ), # 2
    (3, TType.STRUCT, 'port_vlan', (switcht_port_vlan_t, switcht_port_vlan_t.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ip_encap', (switcht_ip_encap_t, switcht_ip_encap_t.thrift_spec), None, ), # 4
  )

  def __init__(self, port_lag_handle=None, vlan_id=None, port_vlan=None, ip_encap=None,):
    self.port_lag_handle = port_lag_handle
    self.vlan_id = vlan_id
    self.port_vlan = port_vlan
    self.ip_encap = ip_encap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.port_lag_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.vlan_id = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.port_vlan = switcht_port_vlan_t()
          self.port_vlan.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ip_encap = switcht_ip_encap_t()
          self.ip_encap.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('interface_union')
    if self.port_lag_handle is not None:
      oprot.writeFieldBegin('port_lag_handle', TType.I32, 1)
      oprot.writeI32(self.port_lag_handle)
      oprot.writeFieldEnd()
    if self.vlan_id is not None:
      oprot.writeFieldBegin('vlan_id', TType.I16, 2)
      oprot.writeI16(self.vlan_id)
      oprot.writeFieldEnd()
    if self.port_vlan is not None:
      oprot.writeFieldBegin('port_vlan', TType.STRUCT, 3)
      self.port_vlan.write(oprot)
      oprot.writeFieldEnd()
    if self.ip_encap is not None:
      oprot.writeFieldBegin('ip_encap', TType.STRUCT, 4)
      self.ip_encap.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.port_lag_handle)
    value = (value * 31) ^ hash(self.vlan_id)
    value = (value * 31) ^ hash(self.port_vlan)
    value = (value * 31) ^ hash(self.ip_encap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_interface_flags:
  """
  < Tunnel info

  Attributes:
   - core_intf
   - flood_enabled
   - learn_enabled
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'core_intf', None, None, ), # 1
    (2, TType.BOOL, 'flood_enabled', None, None, ), # 2
    (3, TType.BOOL, 'learn_enabled', None, None, ), # 3
  )

  def __init__(self, core_intf=None, flood_enabled=None, learn_enabled=None,):
    self.core_intf = core_intf
    self.flood_enabled = flood_enabled
    self.learn_enabled = learn_enabled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.core_intf = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.flood_enabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.learn_enabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_interface_flags')
    if self.core_intf is not None:
      oprot.writeFieldBegin('core_intf', TType.BOOL, 1)
      oprot.writeBool(self.core_intf)
      oprot.writeFieldEnd()
    if self.flood_enabled is not None:
      oprot.writeFieldBegin('flood_enabled', TType.BOOL, 2)
      oprot.writeBool(self.flood_enabled)
      oprot.writeFieldEnd()
    if self.learn_enabled is not None:
      oprot.writeFieldBegin('learn_enabled', TType.BOOL, 3)
      oprot.writeBool(self.learn_enabled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.core_intf)
    value = (value * 31) ^ hash(self.flood_enabled)
    value = (value * 31) ^ hash(self.learn_enabled)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_interface_info_t:
  """
  Attributes:
   - device
   - type
   - u: < type of interface
   - mac
   - label: < Mac address associated with interface
   - vrf_handle: < ACL label
   - nat_mode
   - rmac_handle: < Nat mode for L3 interface
   - flags
   - v4_urpf_mode
   - v6_urpf_mode
   - v4_unicast_enabled
   - v6_unicast_enabled
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
    (3, TType.STRUCT, 'u', (interface_union, interface_union.thrift_spec), None, ), # 3
    (4, TType.STRING, 'mac', None, None, ), # 4
    (5, TType.I32, 'label', None, None, ), # 5
    (6, TType.I32, 'vrf_handle', None, None, ), # 6
    (7, TType.I16, 'nat_mode', None, None, ), # 7
    (8, TType.I32, 'rmac_handle', None, None, ), # 8
    (9, TType.STRUCT, 'flags', (switcht_interface_flags, switcht_interface_flags.thrift_spec), None, ), # 9
    (10, TType.I16, 'v4_urpf_mode', None, None, ), # 10
    (11, TType.I16, 'v6_urpf_mode', None, None, ), # 11
    (12, TType.BOOL, 'v4_unicast_enabled', None, None, ), # 12
    (13, TType.BOOL, 'v6_unicast_enabled', None, None, ), # 13
  )

  def __init__(self, device=None, type=None, u=None, mac=None, label=None, vrf_handle=None, nat_mode=None, rmac_handle=None, flags=None, v4_urpf_mode=None, v6_urpf_mode=None, v4_unicast_enabled=None, v6_unicast_enabled=None,):
    self.device = device
    self.type = type
    self.u = u
    self.mac = mac
    self.label = label
    self.vrf_handle = vrf_handle
    self.nat_mode = nat_mode
    self.rmac_handle = rmac_handle
    self.flags = flags
    self.v4_urpf_mode = v4_urpf_mode
    self.v6_urpf_mode = v6_urpf_mode
    self.v4_unicast_enabled = v4_unicast_enabled
    self.v6_unicast_enabled = v6_unicast_enabled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.u = interface_union()
          self.u.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.mac = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.label = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.vrf_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.nat_mode = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.rmac_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.flags = switcht_interface_flags()
          self.flags.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I16:
          self.v4_urpf_mode = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.v6_urpf_mode = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.v4_unicast_enabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.v6_unicast_enabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_interface_info_t')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.u is not None:
      oprot.writeFieldBegin('u', TType.STRUCT, 3)
      self.u.write(oprot)
      oprot.writeFieldEnd()
    if self.mac is not None:
      oprot.writeFieldBegin('mac', TType.STRING, 4)
      oprot.writeString(self.mac)
      oprot.writeFieldEnd()
    if self.label is not None:
      oprot.writeFieldBegin('label', TType.I32, 5)
      oprot.writeI32(self.label)
      oprot.writeFieldEnd()
    if self.vrf_handle is not None:
      oprot.writeFieldBegin('vrf_handle', TType.I32, 6)
      oprot.writeI32(self.vrf_handle)
      oprot.writeFieldEnd()
    if self.nat_mode is not None:
      oprot.writeFieldBegin('nat_mode', TType.I16, 7)
      oprot.writeI16(self.nat_mode)
      oprot.writeFieldEnd()
    if self.rmac_handle is not None:
      oprot.writeFieldBegin('rmac_handle', TType.I32, 8)
      oprot.writeI32(self.rmac_handle)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.STRUCT, 9)
      self.flags.write(oprot)
      oprot.writeFieldEnd()
    if self.v4_urpf_mode is not None:
      oprot.writeFieldBegin('v4_urpf_mode', TType.I16, 10)
      oprot.writeI16(self.v4_urpf_mode)
      oprot.writeFieldEnd()
    if self.v6_urpf_mode is not None:
      oprot.writeFieldBegin('v6_urpf_mode', TType.I16, 11)
      oprot.writeI16(self.v6_urpf_mode)
      oprot.writeFieldEnd()
    if self.v4_unicast_enabled is not None:
      oprot.writeFieldBegin('v4_unicast_enabled', TType.BOOL, 12)
      oprot.writeBool(self.v4_unicast_enabled)
      oprot.writeFieldEnd()
    if self.v6_unicast_enabled is not None:
      oprot.writeFieldBegin('v6_unicast_enabled', TType.BOOL, 13)
      oprot.writeBool(self.v6_unicast_enabled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.u)
    value = (value * 31) ^ hash(self.mac)
    value = (value * 31) ^ hash(self.label)
    value = (value * 31) ^ hash(self.vrf_handle)
    value = (value * 31) ^ hash(self.nat_mode)
    value = (value * 31) ^ hash(self.rmac_handle)
    value = (value * 31) ^ hash(self.flags)
    value = (value * 31) ^ hash(self.v4_urpf_mode)
    value = (value * 31) ^ hash(self.v6_urpf_mode)
    value = (value * 31) ^ hash(self.v4_unicast_enabled)
    value = (value * 31) ^ hash(self.v6_unicast_enabled)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_neighbor_info_t:
  """
  Attributes:
   - neigh_type
   - nhop_handle
   - interface_handle
   - vlan
   - mac_addr
   - ip_addr
   - mpls_label
   - header_count
   - rw_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'neigh_type', None, None, ), # 1
    (2, TType.I32, 'nhop_handle', None, None, ), # 2
    (3, TType.I32, 'interface_handle', None, None, ), # 3
    (4, TType.I16, 'vlan', None, None, ), # 4
    (5, TType.STRING, 'mac_addr', None, None, ), # 5
    (6, TType.STRUCT, 'ip_addr', (switcht_ip_addr_t, switcht_ip_addr_t.thrift_spec), None, ), # 6
    (7, TType.I32, 'mpls_label', None, None, ), # 7
    (8, TType.BYTE, 'header_count', None, None, ), # 8
    (9, TType.I32, 'rw_type', None, None, ), # 9
  )

  def __init__(self, neigh_type=None, nhop_handle=None, interface_handle=None, vlan=None, mac_addr=None, ip_addr=None, mpls_label=None, header_count=None, rw_type=None,):
    self.neigh_type = neigh_type
    self.nhop_handle = nhop_handle
    self.interface_handle = interface_handle
    self.vlan = vlan
    self.mac_addr = mac_addr
    self.ip_addr = ip_addr
    self.mpls_label = mpls_label
    self.header_count = header_count
    self.rw_type = rw_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.neigh_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.nhop_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.interface_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.vlan = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.mac_addr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.ip_addr = switcht_ip_addr_t()
          self.ip_addr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.mpls_label = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.header_count = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.rw_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_neighbor_info_t')
    if self.neigh_type is not None:
      oprot.writeFieldBegin('neigh_type', TType.I32, 1)
      oprot.writeI32(self.neigh_type)
      oprot.writeFieldEnd()
    if self.nhop_handle is not None:
      oprot.writeFieldBegin('nhop_handle', TType.I32, 2)
      oprot.writeI32(self.nhop_handle)
      oprot.writeFieldEnd()
    if self.interface_handle is not None:
      oprot.writeFieldBegin('interface_handle', TType.I32, 3)
      oprot.writeI32(self.interface_handle)
      oprot.writeFieldEnd()
    if self.vlan is not None:
      oprot.writeFieldBegin('vlan', TType.I16, 4)
      oprot.writeI16(self.vlan)
      oprot.writeFieldEnd()
    if self.mac_addr is not None:
      oprot.writeFieldBegin('mac_addr', TType.STRING, 5)
      oprot.writeString(self.mac_addr)
      oprot.writeFieldEnd()
    if self.ip_addr is not None:
      oprot.writeFieldBegin('ip_addr', TType.STRUCT, 6)
      self.ip_addr.write(oprot)
      oprot.writeFieldEnd()
    if self.mpls_label is not None:
      oprot.writeFieldBegin('mpls_label', TType.I32, 7)
      oprot.writeI32(self.mpls_label)
      oprot.writeFieldEnd()
    if self.header_count is not None:
      oprot.writeFieldBegin('header_count', TType.BYTE, 8)
      oprot.writeByte(self.header_count)
      oprot.writeFieldEnd()
    if self.rw_type is not None:
      oprot.writeFieldBegin('rw_type', TType.I32, 9)
      oprot.writeI32(self.rw_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.neigh_type)
    value = (value * 31) ^ hash(self.nhop_handle)
    value = (value * 31) ^ hash(self.interface_handle)
    value = (value * 31) ^ hash(self.vlan)
    value = (value * 31) ^ hash(self.mac_addr)
    value = (value * 31) ^ hash(self.ip_addr)
    value = (value * 31) ^ hash(self.mpls_label)
    value = (value * 31) ^ hash(self.header_count)
    value = (value * 31) ^ hash(self.rw_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_vxlan_id_t:
  """
  Attributes:
   - vnid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'vnid', None, None, ), # 1
  )

  def __init__(self, vnid=None,):
    self.vnid = vnid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.vnid = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_vxlan_id_t')
    if self.vnid is not None:
      oprot.writeFieldBegin('vnid', TType.I32, 1)
      oprot.writeI32(self.vnid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vnid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_geneve_id_t:
  """
  Attributes:
   - vni
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'vni', None, None, ), # 1
  )

  def __init__(self, vni=None,):
    self.vni = vni

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.vni = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_geneve_id_t')
    if self.vni is not None:
      oprot.writeFieldBegin('vni', TType.I32, 1)
      oprot.writeI32(self.vni)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vni)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_nvgre_id_t:
  """
  Attributes:
   - tnid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tnid', None, None, ), # 1
  )

  def __init__(self, tnid=None,):
    self.tnid = tnid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tnid = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_nvgre_id_t')
    if self.tnid is not None:
      oprot.writeFieldBegin('tnid', TType.I32, 1)
      oprot.writeI32(self.tnid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tnid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_ln_flags:
  """
  Attributes:
   - flood_enabled
   - learn_enabled
   - core_bd
   - ipv4_unicast_enabled
   - ipv6_unicast_enabled
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'flood_enabled', None, None, ), # 1
    (2, TType.BOOL, 'learn_enabled', None, None, ), # 2
    (3, TType.BOOL, 'core_bd', None, None, ), # 3
    (4, TType.BOOL, 'ipv4_unicast_enabled', None, None, ), # 4
    (5, TType.BOOL, 'ipv6_unicast_enabled', None, None, ), # 5
  )

  def __init__(self, flood_enabled=None, learn_enabled=None, core_bd=None, ipv4_unicast_enabled=None, ipv6_unicast_enabled=None,):
    self.flood_enabled = flood_enabled
    self.learn_enabled = learn_enabled
    self.core_bd = core_bd
    self.ipv4_unicast_enabled = ipv4_unicast_enabled
    self.ipv6_unicast_enabled = ipv6_unicast_enabled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.flood_enabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.learn_enabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.core_bd = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.ipv4_unicast_enabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.ipv6_unicast_enabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_ln_flags')
    if self.flood_enabled is not None:
      oprot.writeFieldBegin('flood_enabled', TType.BOOL, 1)
      oprot.writeBool(self.flood_enabled)
      oprot.writeFieldEnd()
    if self.learn_enabled is not None:
      oprot.writeFieldBegin('learn_enabled', TType.BOOL, 2)
      oprot.writeBool(self.learn_enabled)
      oprot.writeFieldEnd()
    if self.core_bd is not None:
      oprot.writeFieldBegin('core_bd', TType.BOOL, 3)
      oprot.writeBool(self.core_bd)
      oprot.writeFieldEnd()
    if self.ipv4_unicast_enabled is not None:
      oprot.writeFieldBegin('ipv4_unicast_enabled', TType.BOOL, 4)
      oprot.writeBool(self.ipv4_unicast_enabled)
      oprot.writeFieldEnd()
    if self.ipv6_unicast_enabled is not None:
      oprot.writeFieldBegin('ipv6_unicast_enabled', TType.BOOL, 5)
      oprot.writeBool(self.ipv6_unicast_enabled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.flood_enabled)
    value = (value * 31) ^ hash(self.learn_enabled)
    value = (value * 31) ^ hash(self.core_bd)
    value = (value * 31) ^ hash(self.ipv4_unicast_enabled)
    value = (value * 31) ^ hash(self.ipv6_unicast_enabled)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_bridge_type:
  """
  Attributes:
   - vlan_id
   - vxlan_info
   - geneve_info
   - nvgre_info
   - tunnel_vni
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'vlan_id', None, None, ), # 1
    (2, TType.STRUCT, 'vxlan_info', (switcht_vxlan_id_t, switcht_vxlan_id_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'geneve_info', (switcht_geneve_id_t, switcht_geneve_id_t.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'nvgre_info', (switcht_nvgre_id_t, switcht_nvgre_id_t.thrift_spec), None, ), # 4
    (5, TType.I32, 'tunnel_vni', None, None, ), # 5
  )

  def __init__(self, vlan_id=None, vxlan_info=None, geneve_info=None, nvgre_info=None, tunnel_vni=None,):
    self.vlan_id = vlan_id
    self.vxlan_info = vxlan_info
    self.geneve_info = geneve_info
    self.nvgre_info = nvgre_info
    self.tunnel_vni = tunnel_vni

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.vlan_id = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.vxlan_info = switcht_vxlan_id_t()
          self.vxlan_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.geneve_info = switcht_geneve_id_t()
          self.geneve_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.nvgre_info = switcht_nvgre_id_t()
          self.nvgre_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.tunnel_vni = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_bridge_type')
    if self.vlan_id is not None:
      oprot.writeFieldBegin('vlan_id', TType.I16, 1)
      oprot.writeI16(self.vlan_id)
      oprot.writeFieldEnd()
    if self.vxlan_info is not None:
      oprot.writeFieldBegin('vxlan_info', TType.STRUCT, 2)
      self.vxlan_info.write(oprot)
      oprot.writeFieldEnd()
    if self.geneve_info is not None:
      oprot.writeFieldBegin('geneve_info', TType.STRUCT, 3)
      self.geneve_info.write(oprot)
      oprot.writeFieldEnd()
    if self.nvgre_info is not None:
      oprot.writeFieldBegin('nvgre_info', TType.STRUCT, 4)
      self.nvgre_info.write(oprot)
      oprot.writeFieldEnd()
    if self.tunnel_vni is not None:
      oprot.writeFieldBegin('tunnel_vni', TType.I32, 5)
      oprot.writeI32(self.tunnel_vni)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vlan_id)
    value = (value * 31) ^ hash(self.vxlan_info)
    value = (value * 31) ^ hash(self.geneve_info)
    value = (value * 31) ^ hash(self.nvgre_info)
    value = (value * 31) ^ hash(self.tunnel_vni)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_encap_info_t:
  """
  Attributes:
   - encap_type
   - u
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'encap_type', None, None, ), # 1
    (2, TType.STRUCT, 'u', (switcht_bridge_type, switcht_bridge_type.thrift_spec), None, ), # 2
  )

  def __init__(self, encap_type=None, u=None,):
    self.encap_type = encap_type
    self.u = u

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.encap_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.u = switcht_bridge_type()
          self.u.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_encap_info_t')
    if self.encap_type is not None:
      oprot.writeFieldBegin('encap_type', TType.I32, 1)
      oprot.writeI32(self.encap_type)
      oprot.writeFieldEnd()
    if self.u is not None:
      oprot.writeFieldBegin('u', TType.STRUCT, 2)
      self.u.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.encap_type)
    value = (value * 31) ^ hash(self.u)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_mpls_t:
  """
  Attributes:
   - label
   - exp
   - bos
   - ttl
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'label', None, None, ), # 1
    (2, TType.BYTE, 'exp', None, None, ), # 2
    (3, TType.BYTE, 'bos', None, None, ), # 3
    (4, TType.BYTE, 'ttl', None, None, ), # 4
  )

  def __init__(self, label=None, exp=None, bos=None, ttl=None,):
    self.label = label
    self.exp = exp
    self.bos = bos
    self.ttl = ttl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.label = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.exp = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.bos = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.ttl = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_mpls_t')
    if self.label is not None:
      oprot.writeFieldBegin('label', TType.I32, 1)
      oprot.writeI32(self.label)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.BYTE, 2)
      oprot.writeByte(self.exp)
      oprot.writeFieldEnd()
    if self.bos is not None:
      oprot.writeFieldBegin('bos', TType.BYTE, 3)
      oprot.writeByte(self.bos)
      oprot.writeFieldEnd()
    if self.ttl is not None:
      oprot.writeFieldBegin('ttl', TType.BYTE, 4)
      oprot.writeByte(self.ttl)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.label)
    value = (value * 31) ^ hash(self.exp)
    value = (value * 31) ^ hash(self.bos)
    value = (value * 31) ^ hash(self.ttl)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_mpls_swap_t:
  """
  Attributes:
   - old_tag
   - new_tag
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'old_tag', (switcht_mpls_t, switcht_mpls_t.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'new_tag', (switcht_mpls_t, switcht_mpls_t.thrift_spec), None, ), # 2
  )

  def __init__(self, old_tag=None, new_tag=None,):
    self.old_tag = old_tag
    self.new_tag = new_tag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.old_tag = switcht_mpls_t()
          self.old_tag.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.new_tag = switcht_mpls_t()
          self.new_tag.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_mpls_swap_t')
    if self.old_tag is not None:
      oprot.writeFieldBegin('old_tag', TType.STRUCT, 1)
      self.old_tag.write(oprot)
      oprot.writeFieldEnd()
    if self.new_tag is not None:
      oprot.writeFieldBegin('new_tag', TType.STRUCT, 2)
      self.new_tag.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.old_tag)
    value = (value * 31) ^ hash(self.new_tag)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_mpls_pop_t:
  """
  Attributes:
   - tag
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tag', (TType.STRUCT,(switcht_mpls_t, switcht_mpls_t.thrift_spec)), None, ), # 1
    (2, TType.BYTE, 'count', None, None, ), # 2
  )

  def __init__(self, tag=None, count=None,):
    self.tag = tag
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tag = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = switcht_mpls_t()
            _elem5.read(iprot)
            self.tag.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.count = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_mpls_pop_t')
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tag))
      for iter6 in self.tag:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.BYTE, 2)
      oprot.writeByte(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tag)
    value = (value * 31) ^ hash(self.count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_mpls_push_t:
  """
  Attributes:
   - tag
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tag', (TType.STRUCT,(switcht_mpls_t, switcht_mpls_t.thrift_spec)), None, ), # 1
    (2, TType.BYTE, 'count', None, None, ), # 2
  )

  def __init__(self, tag=None, count=None,):
    self.tag = tag
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tag = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = switcht_mpls_t()
            _elem12.read(iprot)
            self.tag.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.count = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_mpls_push_t')
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tag))
      for iter13 in self.tag:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.BYTE, 2)
      oprot.writeByte(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tag)
    value = (value * 31) ^ hash(self.count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_mpls_swap_push_t:
  """
  Attributes:
   - old_tag
   - new_tag
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'old_tag', (switcht_mpls_t, switcht_mpls_t.thrift_spec), None, ), # 1
    (2, TType.LIST, 'new_tag', (TType.STRUCT,(switcht_mpls_t, switcht_mpls_t.thrift_spec)), None, ), # 2
    (3, TType.BYTE, 'count', None, None, ), # 3
  )

  def __init__(self, old_tag=None, new_tag=None, count=None,):
    self.old_tag = old_tag
    self.new_tag = new_tag
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.old_tag = switcht_mpls_t()
          self.old_tag.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.new_tag = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = switcht_mpls_t()
            _elem19.read(iprot)
            self.new_tag.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.count = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_mpls_swap_push_t')
    if self.old_tag is not None:
      oprot.writeFieldBegin('old_tag', TType.STRUCT, 1)
      self.old_tag.write(oprot)
      oprot.writeFieldEnd()
    if self.new_tag is not None:
      oprot.writeFieldBegin('new_tag', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.new_tag))
      for iter20 in self.new_tag:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.BYTE, 3)
      oprot.writeByte(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.old_tag)
    value = (value * 31) ^ hash(self.new_tag)
    value = (value * 31) ^ hash(self.count)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_mpls_info_t:
  """
  Attributes:
   - swap_info
   - push_info
   - pop_info
   - swap_push_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'swap_info', (switcht_mpls_swap_t, switcht_mpls_swap_t.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'push_info', (switcht_mpls_push_t, switcht_mpls_push_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'pop_info', (switcht_mpls_pop_t, switcht_mpls_pop_t.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'swap_push_info', (switcht_mpls_swap_push_t, switcht_mpls_swap_push_t.thrift_spec), None, ), # 4
  )

  def __init__(self, swap_info=None, push_info=None, pop_info=None, swap_push_info=None,):
    self.swap_info = swap_info
    self.push_info = push_info
    self.pop_info = pop_info
    self.swap_push_info = swap_push_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.swap_info = switcht_mpls_swap_t()
          self.swap_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.push_info = switcht_mpls_push_t()
          self.push_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.pop_info = switcht_mpls_pop_t()
          self.pop_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.swap_push_info = switcht_mpls_swap_push_t()
          self.swap_push_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_mpls_info_t')
    if self.swap_info is not None:
      oprot.writeFieldBegin('swap_info', TType.STRUCT, 1)
      self.swap_info.write(oprot)
      oprot.writeFieldEnd()
    if self.push_info is not None:
      oprot.writeFieldBegin('push_info', TType.STRUCT, 2)
      self.push_info.write(oprot)
      oprot.writeFieldEnd()
    if self.pop_info is not None:
      oprot.writeFieldBegin('pop_info', TType.STRUCT, 3)
      self.pop_info.write(oprot)
      oprot.writeFieldEnd()
    if self.swap_push_info is not None:
      oprot.writeFieldBegin('swap_push_info', TType.STRUCT, 4)
      self.swap_push_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.swap_info)
    value = (value * 31) ^ hash(self.push_info)
    value = (value * 31) ^ hash(self.pop_info)
    value = (value * 31) ^ hash(self.swap_push_info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_mpls_encap_t:
  """
  Attributes:
   - mpls_type
   - mpls_action
   - mpls_mode
   - u
   - bd_handle
   - vrf_handle
   - nhop_handle
   - egress_if
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'mpls_type', None, None, ), # 1
    (2, TType.I32, 'mpls_action', None, None, ), # 2
    (3, TType.I32, 'mpls_mode', None, None, ), # 3
    (4, TType.STRUCT, 'u', (switcht_mpls_info_t, switcht_mpls_info_t.thrift_spec), None, ), # 4
    (5, TType.I32, 'bd_handle', None, None, ), # 5
    (6, TType.I32, 'vrf_handle', None, None, ), # 6
    (7, TType.I32, 'nhop_handle', None, None, ), # 7
    (8, TType.I32, 'egress_if', None, None, ), # 8
  )

  def __init__(self, mpls_type=None, mpls_action=None, mpls_mode=None, u=None, bd_handle=None, vrf_handle=None, nhop_handle=None, egress_if=None,):
    self.mpls_type = mpls_type
    self.mpls_action = mpls_action
    self.mpls_mode = mpls_mode
    self.u = u
    self.bd_handle = bd_handle
    self.vrf_handle = vrf_handle
    self.nhop_handle = nhop_handle
    self.egress_if = egress_if

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.mpls_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.mpls_action = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mpls_mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.u = switcht_mpls_info_t()
          self.u.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.bd_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.vrf_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.nhop_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.egress_if = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_mpls_encap_t')
    if self.mpls_type is not None:
      oprot.writeFieldBegin('mpls_type', TType.I32, 1)
      oprot.writeI32(self.mpls_type)
      oprot.writeFieldEnd()
    if self.mpls_action is not None:
      oprot.writeFieldBegin('mpls_action', TType.I32, 2)
      oprot.writeI32(self.mpls_action)
      oprot.writeFieldEnd()
    if self.mpls_mode is not None:
      oprot.writeFieldBegin('mpls_mode', TType.I32, 3)
      oprot.writeI32(self.mpls_mode)
      oprot.writeFieldEnd()
    if self.u is not None:
      oprot.writeFieldBegin('u', TType.STRUCT, 4)
      self.u.write(oprot)
      oprot.writeFieldEnd()
    if self.bd_handle is not None:
      oprot.writeFieldBegin('bd_handle', TType.I32, 5)
      oprot.writeI32(self.bd_handle)
      oprot.writeFieldEnd()
    if self.vrf_handle is not None:
      oprot.writeFieldBegin('vrf_handle', TType.I32, 6)
      oprot.writeI32(self.vrf_handle)
      oprot.writeFieldEnd()
    if self.nhop_handle is not None:
      oprot.writeFieldBegin('nhop_handle', TType.I32, 7)
      oprot.writeI32(self.nhop_handle)
      oprot.writeFieldEnd()
    if self.egress_if is not None:
      oprot.writeFieldBegin('egress_if', TType.I32, 8)
      oprot.writeI32(self.egress_if)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mpls_type)
    value = (value * 31) ^ hash(self.mpls_action)
    value = (value * 31) ^ hash(self.mpls_mode)
    value = (value * 31) ^ hash(self.u)
    value = (value * 31) ^ hash(self.bd_handle)
    value = (value * 31) ^ hash(self.vrf_handle)
    value = (value * 31) ^ hash(self.nhop_handle)
    value = (value * 31) ^ hash(self.egress_if)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_tunnel_encap_t:
  """
  Attributes:
   - ip_encap
   - mpls_encap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ip_encap', (switcht_ip_encap_t, switcht_ip_encap_t.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'mpls_encap', (switcht_mpls_encap_t, switcht_mpls_encap_t.thrift_spec), None, ), # 2
  )

  def __init__(self, ip_encap=None, mpls_encap=None,):
    self.ip_encap = ip_encap
    self.mpls_encap = mpls_encap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ip_encap = switcht_ip_encap_t()
          self.ip_encap.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.mpls_encap = switcht_mpls_encap_t()
          self.mpls_encap.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_tunnel_encap_t')
    if self.ip_encap is not None:
      oprot.writeFieldBegin('ip_encap', TType.STRUCT, 1)
      self.ip_encap.write(oprot)
      oprot.writeFieldEnd()
    if self.mpls_encap is not None:
      oprot.writeFieldBegin('mpls_encap', TType.STRUCT, 2)
      self.mpls_encap.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ip_encap)
    value = (value * 31) ^ hash(self.mpls_encap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_tunnel_info_t:
  """
  Attributes:
   - encap_mode
   - tunnel_encap
   - encap_info
   - out_if
   - flags
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'encap_mode', None, None, ), # 1
    (2, TType.STRUCT, 'tunnel_encap', (switcht_tunnel_encap_t, switcht_tunnel_encap_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'encap_info', (switcht_encap_info_t, switcht_encap_info_t.thrift_spec), None, ), # 3
    (4, TType.I32, 'out_if', None, None, ), # 4
    (5, TType.STRUCT, 'flags', (switcht_interface_flags, switcht_interface_flags.thrift_spec), None, ), # 5
  )

  def __init__(self, encap_mode=None, tunnel_encap=None, encap_info=None, out_if=None, flags=None,):
    self.encap_mode = encap_mode
    self.tunnel_encap = tunnel_encap
    self.encap_info = encap_info
    self.out_if = out_if
    self.flags = flags

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.encap_mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tunnel_encap = switcht_tunnel_encap_t()
          self.tunnel_encap.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.encap_info = switcht_encap_info_t()
          self.encap_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.out_if = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.flags = switcht_interface_flags()
          self.flags.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_tunnel_info_t')
    if self.encap_mode is not None:
      oprot.writeFieldBegin('encap_mode', TType.I32, 1)
      oprot.writeI32(self.encap_mode)
      oprot.writeFieldEnd()
    if self.tunnel_encap is not None:
      oprot.writeFieldBegin('tunnel_encap', TType.STRUCT, 2)
      self.tunnel_encap.write(oprot)
      oprot.writeFieldEnd()
    if self.encap_info is not None:
      oprot.writeFieldBegin('encap_info', TType.STRUCT, 3)
      self.encap_info.write(oprot)
      oprot.writeFieldEnd()
    if self.out_if is not None:
      oprot.writeFieldBegin('out_if', TType.I32, 4)
      oprot.writeI32(self.out_if)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.STRUCT, 5)
      self.flags.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.encap_mode)
    value = (value * 31) ^ hash(self.tunnel_encap)
    value = (value * 31) ^ hash(self.encap_info)
    value = (value * 31) ^ hash(self.out_if)
    value = (value * 31) ^ hash(self.flags)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_logical_network_t:
  """
  Attributes:
   - type
   - encap_info
   - age_interval
   - vrf
   - flags
   - rmac_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'encap_info', (switcht_encap_info_t, switcht_encap_info_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'age_interval', None, None, ), # 3
    (4, TType.I32, 'vrf', None, None, ), # 4
    (5, TType.STRUCT, 'flags', (switcht_ln_flags, switcht_ln_flags.thrift_spec), None, ), # 5
    (6, TType.I32, 'rmac_handle', None, None, ), # 6
  )

  def __init__(self, type=None, encap_info=None, age_interval=None, vrf=None, flags=None, rmac_handle=None,):
    self.type = type
    self.encap_info = encap_info
    self.age_interval = age_interval
    self.vrf = vrf
    self.flags = flags
    self.rmac_handle = rmac_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.encap_info = switcht_encap_info_t()
          self.encap_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.age_interval = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.vrf = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.flags = switcht_ln_flags()
          self.flags.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.rmac_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_logical_network_t')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.encap_info is not None:
      oprot.writeFieldBegin('encap_info', TType.STRUCT, 2)
      self.encap_info.write(oprot)
      oprot.writeFieldEnd()
    if self.age_interval is not None:
      oprot.writeFieldBegin('age_interval', TType.I32, 3)
      oprot.writeI32(self.age_interval)
      oprot.writeFieldEnd()
    if self.vrf is not None:
      oprot.writeFieldBegin('vrf', TType.I32, 4)
      oprot.writeI32(self.vrf)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.STRUCT, 5)
      self.flags.write(oprot)
      oprot.writeFieldEnd()
    if self.rmac_handle is not None:
      oprot.writeFieldBegin('rmac_handle', TType.I32, 6)
      oprot.writeI32(self.rmac_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.encap_info)
    value = (value * 31) ^ hash(self.age_interval)
    value = (value * 31) ^ hash(self.vrf)
    value = (value * 31) ^ hash(self.flags)
    value = (value * 31) ^ hash(self.rmac_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_system_key_value_pair_t:
  """
  Attributes:
   - field
   - value
   - mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'field', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
    (3, TType.I64, 'mask', None, None, ), # 3
  )

  def __init__(self, field=None, value=None, mask=None,):
    self.field = field
    self.value = value
    self.mask = mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.mask = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_system_key_value_pair_t')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    if self.mask is not None:
      oprot.writeFieldBegin('mask', TType.I64, 3)
      oprot.writeI64(self.mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_ip_key_value_pair_t:
  """
  Attributes:
   - field
   - value
   - mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'field', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
    (3, TType.I64, 'mask', None, None, ), # 3
  )

  def __init__(self, field=None, value=None, mask=None,):
    self.field = field
    self.value = value
    self.mask = mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.mask = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_ip_key_value_pair_t')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    if self.mask is not None:
      oprot.writeFieldBegin('mask', TType.I64, 3)
      oprot.writeI64(self.mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_mirror_key_value_pair_t:
  """
  Attributes:
   - field
   - value
   - mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'field', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
    (3, TType.I64, 'mask', None, None, ), # 3
  )

  def __init__(self, field=None, value=None, mask=None,):
    self.field = field
    self.value = value
    self.mask = mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.mask = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_mirror_key_value_pair_t')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    if self.mask is not None:
      oprot.writeFieldBegin('mask', TType.I64, 3)
      oprot.writeI64(self.mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_qos_key_value_pair_t:
  """
  Attributes:
   - field
   - value
   - mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'field', None, None, ), # 1
    (2, TType.I32, 'value', None, None, ), # 2
    (3, TType.I32, 'mask', None, None, ), # 3
  )

  def __init__(self, field=None, value=None, mask=None,):
    self.field = field
    self.value = value
    self.mask = mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.value = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mask = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_qos_key_value_pair_t')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 2)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    if self.mask is not None:
      oprot.writeFieldBegin('mask', TType.I32, 3)
      oprot.writeI32(self.mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_mac_key_value_pair_t:
  """
  Attributes:
   - field
   - value
   - mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'field', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
    (3, TType.I64, 'mask', None, None, ), # 3
  )

  def __init__(self, field=None, value=None, mask=None,):
    self.field = field
    self.value = value
    self.mask = mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.mask = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_mac_key_value_pair_t')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    if self.mask is not None:
      oprot.writeFieldBegin('mask', TType.I64, 3)
      oprot.writeI64(self.mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_ipv6_key_value_pair_t:
  """
  Attributes:
   - field
   - value
   - mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'field', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
    (3, TType.I64, 'mask', None, None, ), # 3
  )

  def __init__(self, field=None, value=None, mask=None,):
    self.field = field
    self.value = value
    self.mask = mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.mask = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_ipv6_key_value_pair_t')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    if self.mask is not None:
      oprot.writeFieldBegin('mask', TType.I64, 3)
      oprot.writeI64(self.mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_ipracl_key_value_pair_t:
  """
  Attributes:
   - field
   - value
   - mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'field', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
    (3, TType.I64, 'mask', None, None, ), # 3
  )

  def __init__(self, field=None, value=None, mask=None,):
    self.field = field
    self.value = value
    self.mask = mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.mask = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_ipracl_key_value_pair_t')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    if self.mask is not None:
      oprot.writeFieldBegin('mask', TType.I64, 3)
      oprot.writeI64(self.mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_ipv6racl_key_value_pair_t:
  """
  Attributes:
   - field
   - value
   - mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'field', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
    (3, TType.I64, 'mask', None, None, ), # 3
  )

  def __init__(self, field=None, value=None, mask=None,):
    self.field = field
    self.value = value
    self.mask = mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.mask = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_ipv6racl_key_value_pair_t')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    if self.mask is not None:
      oprot.writeFieldBegin('mask', TType.I64, 3)
      oprot.writeI64(self.mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_egr_key_value_pair_t:
  """
  Attributes:
   - field
   - value
   - mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'field', None, None, ), # 1
    (2, TType.I16, 'value', None, None, ), # 2
    (3, TType.I16, 'mask', None, None, ), # 3
  )

  def __init__(self, field=None, value=None, mask=None,):
    self.field = field
    self.value = value
    self.mask = mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.value = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.mask = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_egr_key_value_pair_t')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I16, 2)
      oprot.writeI16(self.value)
      oprot.writeFieldEnd()
    if self.mask is not None:
      oprot.writeFieldBegin('mask', TType.I16, 3)
      oprot.writeI16(self.mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_vlan_port_t:
  """
  Attributes:
   - handle
   - tagging_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.I16, 'tagging_mode', None, None, ), # 2
  )

  def __init__(self, handle=None, tagging_mode=None,):
    self.handle = handle
    self.tagging_mode = tagging_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.tagging_mode = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_vlan_port_t')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.tagging_mode is not None:
      oprot.writeFieldBegin('tagging_mode', TType.I16, 2)
      oprot.writeI16(self.tagging_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.tagging_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_nhop_key_t:
  """
  Attributes:
   - intf_handle
   - ip_addr
   - ip_addr_valid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'intf_handle', None, None, ), # 1
    (2, TType.STRUCT, 'ip_addr', (switcht_ip_addr_t, switcht_ip_addr_t.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'ip_addr_valid', None, None, ), # 3
  )

  def __init__(self, intf_handle=None, ip_addr=None, ip_addr_valid=None,):
    self.intf_handle = intf_handle
    self.ip_addr = ip_addr
    self.ip_addr_valid = ip_addr_valid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.intf_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ip_addr = switcht_ip_addr_t()
          self.ip_addr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.ip_addr_valid = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_nhop_key_t')
    if self.intf_handle is not None:
      oprot.writeFieldBegin('intf_handle', TType.I32, 1)
      oprot.writeI32(self.intf_handle)
      oprot.writeFieldEnd()
    if self.ip_addr is not None:
      oprot.writeFieldBegin('ip_addr', TType.STRUCT, 2)
      self.ip_addr.write(oprot)
      oprot.writeFieldEnd()
    if self.ip_addr_valid is not None:
      oprot.writeFieldBegin('ip_addr_valid', TType.BOOL, 3)
      oprot.writeBool(self.ip_addr_valid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.intf_handle)
    value = (value * 31) ^ hash(self.ip_addr)
    value = (value * 31) ^ hash(self.ip_addr_valid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_hostif_group_t:
  """
  Attributes:
   - egress_queue
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'egress_queue', None, None, ), # 1
    (2, TType.I32, 'priority', None, None, ), # 2
  )

  def __init__(self, egress_queue=None, priority=None,):
    self.egress_queue = egress_queue
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.egress_queue = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.priority = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_hostif_group_t')
    if self.egress_queue is not None:
      oprot.writeFieldBegin('egress_queue', TType.I32, 1)
      oprot.writeI32(self.egress_queue)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 2)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.egress_queue)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_counter_t:
  """
  Attributes:
   - num_packets
   - num_bytes
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'num_packets', None, None, ), # 1
    (2, TType.I64, 'num_bytes', None, None, ), # 2
  )

  def __init__(self, num_packets=None, num_bytes=None,):
    self.num_packets = num_packets
    self.num_bytes = num_bytes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.num_packets = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.num_bytes = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_counter_t')
    if self.num_packets is not None:
      oprot.writeFieldBegin('num_packets', TType.I64, 1)
      oprot.writeI64(self.num_packets)
      oprot.writeFieldEnd()
    if self.num_bytes is not None:
      oprot.writeFieldBegin('num_bytes', TType.I64, 2)
      oprot.writeI64(self.num_bytes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.num_packets)
    value = (value * 31) ^ hash(self.num_bytes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_rcode_info_t:
  """
  Attributes:
   - reason_code
   - action
   - priority
   - channel
   - hostif_group_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reason_code', None, None, ), # 1
    (2, TType.I32, 'action', None, None, ), # 2
    (3, TType.I32, 'priority', None, None, ), # 3
    (4, TType.BYTE, 'channel', None, None, ), # 4
    (5, TType.I32, 'hostif_group_id', None, None, ), # 5
  )

  def __init__(self, reason_code=None, action=None, priority=None, channel=None, hostif_group_id=None,):
    self.reason_code = reason_code
    self.action = action
    self.priority = priority
    self.channel = channel
    self.hostif_group_id = hostif_group_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reason_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.priority = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.channel = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.hostif_group_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_rcode_info_t')
    if self.reason_code is not None:
      oprot.writeFieldBegin('reason_code', TType.I32, 1)
      oprot.writeI32(self.reason_code)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 2)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 3)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.BYTE, 4)
      oprot.writeByte(self.channel)
      oprot.writeFieldEnd()
    if self.hostif_group_id is not None:
      oprot.writeFieldBegin('hostif_group_id', TType.I32, 5)
      oprot.writeI32(self.hostif_group_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.reason_code)
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.channel)
    value = (value * 31) ^ hash(self.hostif_group_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_hostif_t:
  """
  Attributes:
   - handle
   - intf_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
    (2, TType.STRING, 'intf_name', None, None, ), # 2
  )

  def __init__(self, handle=None, intf_name=None,):
    self.handle = handle
    self.intf_name = intf_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.intf_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_hostif_t')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.intf_name is not None:
      oprot.writeFieldBegin('intf_name', TType.STRING, 2)
      oprot.writeString(self.intf_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.intf_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_action_mirror:
  """
  Attributes:
   - mirror_handle
   - drop_reason
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'mirror_handle', None, None, ), # 1
    (2, TType.I32, 'drop_reason', None, None, ), # 2
  )

  def __init__(self, mirror_handle=None, drop_reason=None,):
    self.mirror_handle = mirror_handle
    self.drop_reason = drop_reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.mirror_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.drop_reason = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_action_mirror')
    if self.mirror_handle is not None:
      oprot.writeFieldBegin('mirror_handle', TType.I32, 1)
      oprot.writeI32(self.mirror_handle)
      oprot.writeFieldEnd()
    if self.drop_reason is not None:
      oprot.writeFieldBegin('drop_reason', TType.I32, 2)
      oprot.writeI32(self.drop_reason)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mirror_handle)
    value = (value * 31) ^ hash(self.drop_reason)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_action_cpu_redirect:
  """
  Attributes:
   - reason_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reason_code', None, None, ), # 1
  )

  def __init__(self, reason_code=None,):
    self.reason_code = reason_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reason_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_action_cpu_redirect')
    if self.reason_code is not None:
      oprot.writeFieldBegin('reason_code', TType.I32, 1)
      oprot.writeI32(self.reason_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.reason_code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_action_redirect:
  """
  Attributes:
   - handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'handle', None, None, ), # 1
  )

  def __init__(self, handle=None,):
    self.handle = handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_action_redirect')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 1)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_acl_action_params_t:
  """
  Attributes:
   - mirror
   - cpu_redirect
   - redirect
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mirror', (switcht_acl_action_mirror, switcht_acl_action_mirror.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'cpu_redirect', (switcht_acl_action_cpu_redirect, switcht_acl_action_cpu_redirect.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'redirect', (switcht_acl_action_redirect, switcht_acl_action_redirect.thrift_spec), None, ), # 3
  )

  def __init__(self, mirror=None, cpu_redirect=None, redirect=None,):
    self.mirror = mirror
    self.cpu_redirect = cpu_redirect
    self.redirect = redirect

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mirror = switcht_acl_action_mirror()
          self.mirror.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.cpu_redirect = switcht_acl_action_cpu_redirect()
          self.cpu_redirect.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.redirect = switcht_acl_action_redirect()
          self.redirect.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_acl_action_params_t')
    if self.mirror is not None:
      oprot.writeFieldBegin('mirror', TType.STRUCT, 1)
      self.mirror.write(oprot)
      oprot.writeFieldEnd()
    if self.cpu_redirect is not None:
      oprot.writeFieldBegin('cpu_redirect', TType.STRUCT, 2)
      self.cpu_redirect.write(oprot)
      oprot.writeFieldEnd()
    if self.redirect is not None:
      oprot.writeFieldBegin('redirect', TType.STRUCT, 3)
      self.redirect.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mirror)
    value = (value * 31) ^ hash(self.cpu_redirect)
    value = (value * 31) ^ hash(self.redirect)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_mirror_info_t:
  """
  Attributes:
   - session_id
   - direction
   - egress_port
   - mirror_type
   - cos
   - max_pkt_len
   - ttl
   - enable
   - nhop_handle
   - session_type
   - vlan_id
   - tun_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'session_id', None, None, ), # 1
    (2, TType.I32, 'direction', None, None, ), # 2
    (3, TType.I32, 'egress_port', None, None, ), # 3
    (4, TType.I32, 'mirror_type', None, None, ), # 4
    (5, TType.BYTE, 'cos', None, None, ), # 5
    (6, TType.I32, 'max_pkt_len', None, None, ), # 6
    (7, TType.I32, 'ttl', None, None, ), # 7
    (8, TType.BOOL, 'enable', None, None, ), # 8
    (9, TType.I32, 'nhop_handle', None, None, ), # 9
    (10, TType.I32, 'session_type', None, None, ), # 10
    (11, TType.I16, 'vlan_id', None, None, ), # 11
    (12, TType.STRUCT, 'tun_info', (switcht_tunnel_info_t, switcht_tunnel_info_t.thrift_spec), None, ), # 12
  )

  def __init__(self, session_id=None, direction=None, egress_port=None, mirror_type=None, cos=None, max_pkt_len=None, ttl=None, enable=None, nhop_handle=None, session_type=None, vlan_id=None, tun_info=None,):
    self.session_id = session_id
    self.direction = direction
    self.egress_port = egress_port
    self.mirror_type = mirror_type
    self.cos = cos
    self.max_pkt_len = max_pkt_len
    self.ttl = ttl
    self.enable = enable
    self.nhop_handle = nhop_handle
    self.session_type = session_type
    self.vlan_id = vlan_id
    self.tun_info = tun_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.session_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.direction = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.egress_port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.mirror_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.cos = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.max_pkt_len = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.ttl = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.enable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.nhop_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.session_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I16:
          self.vlan_id = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.tun_info = switcht_tunnel_info_t()
          self.tun_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_mirror_info_t')
    if self.session_id is not None:
      oprot.writeFieldBegin('session_id', TType.I32, 1)
      oprot.writeI32(self.session_id)
      oprot.writeFieldEnd()
    if self.direction is not None:
      oprot.writeFieldBegin('direction', TType.I32, 2)
      oprot.writeI32(self.direction)
      oprot.writeFieldEnd()
    if self.egress_port is not None:
      oprot.writeFieldBegin('egress_port', TType.I32, 3)
      oprot.writeI32(self.egress_port)
      oprot.writeFieldEnd()
    if self.mirror_type is not None:
      oprot.writeFieldBegin('mirror_type', TType.I32, 4)
      oprot.writeI32(self.mirror_type)
      oprot.writeFieldEnd()
    if self.cos is not None:
      oprot.writeFieldBegin('cos', TType.BYTE, 5)
      oprot.writeByte(self.cos)
      oprot.writeFieldEnd()
    if self.max_pkt_len is not None:
      oprot.writeFieldBegin('max_pkt_len', TType.I32, 6)
      oprot.writeI32(self.max_pkt_len)
      oprot.writeFieldEnd()
    if self.ttl is not None:
      oprot.writeFieldBegin('ttl', TType.I32, 7)
      oprot.writeI32(self.ttl)
      oprot.writeFieldEnd()
    if self.enable is not None:
      oprot.writeFieldBegin('enable', TType.BOOL, 8)
      oprot.writeBool(self.enable)
      oprot.writeFieldEnd()
    if self.nhop_handle is not None:
      oprot.writeFieldBegin('nhop_handle', TType.I32, 9)
      oprot.writeI32(self.nhop_handle)
      oprot.writeFieldEnd()
    if self.session_type is not None:
      oprot.writeFieldBegin('session_type', TType.I32, 10)
      oprot.writeI32(self.session_type)
      oprot.writeFieldEnd()
    if self.vlan_id is not None:
      oprot.writeFieldBegin('vlan_id', TType.I16, 11)
      oprot.writeI16(self.vlan_id)
      oprot.writeFieldEnd()
    if self.tun_info is not None:
      oprot.writeFieldBegin('tun_info', TType.STRUCT, 12)
      self.tun_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.session_id)
    value = (value * 31) ^ hash(self.direction)
    value = (value * 31) ^ hash(self.egress_port)
    value = (value * 31) ^ hash(self.mirror_type)
    value = (value * 31) ^ hash(self.cos)
    value = (value * 31) ^ hash(self.max_pkt_len)
    value = (value * 31) ^ hash(self.ttl)
    value = (value * 31) ^ hash(self.enable)
    value = (value * 31) ^ hash(self.nhop_handle)
    value = (value * 31) ^ hash(self.session_type)
    value = (value * 31) ^ hash(self.vlan_id)
    value = (value * 31) ^ hash(self.tun_info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
