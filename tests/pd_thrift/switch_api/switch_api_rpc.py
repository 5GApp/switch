#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def switcht_api_init(self, device):
    """
    Parameters:
     - device
    """
    pass

  def switcht_api_drop_stats_get(self, device):
    """
    Parameters:
     - device
    """
    pass

  def switcht_api_port_set(self, device, port_info):
    """
    Parameters:
     - device
     - port_info
    """
    pass

  def switcht_api_port_print_all(self):
    pass

  def switcht_api_vrf_create(self, device, vrf):
    """
    Parameters:
     - device
     - vrf
    """
    pass

  def switcht_api_vrf_delete(self, device, vrf_handle):
    """
    Parameters:
     - device
     - vrf_handle
    """
    pass

  def switcht_api_router_mac_group_create(self, device):
    """
    Parameters:
     - device
    """
    pass

  def switcht_api_router_mac_group_delete(self, device, rmac_handle):
    """
    Parameters:
     - device
     - rmac_handle
    """
    pass

  def switcht_api_router_mac_add(self, device, rmac_handle, mac):
    """
    Parameters:
     - device
     - rmac_handle
     - mac
    """
    pass

  def switcht_api_router_mac_delete(self, device, rmac_handle, mac):
    """
    Parameters:
     - device
     - rmac_handle
     - mac
    """
    pass

  def switcht_api_router_mac_group_print_all(self):
    pass

  def switcht_api_interface_create(self, device, interface_info):
    """
    Parameters:
     - device
     - interface_info
    """
    pass

  def switcht_api_interface_delete(self, device, interface_handle):
    """
    Parameters:
     - device
     - interface_handle
    """
    pass

  def switcht_api_interface_print_all(self):
    pass

  def switcht_api_interface_attribute_set(self, interface_handle, attr_type, value):
    """
    Parameters:
     - interface_handle
     - attr_type
     - value
    """
    pass

  def switcht_api_interface_ipv4_unicast_enabled_set(self, intf_handle, value):
    """
    Parameters:
     - intf_handle
     - value
    """
    pass

  def switcht_api_interface_ipv6_unicast_enabled_set(self, intf_handle, value):
    """
    Parameters:
     - intf_handle
     - value
    """
    pass

  def switcht_api_interface_ipv4_urpf_mode_set(self, intf_handle, value):
    """
    Parameters:
     - intf_handle
     - value
    """
    pass

  def switcht_api_interface_ipv6_urpf_mode_set(self, intf_handle, value):
    """
    Parameters:
     - intf_handle
     - value
    """
    pass

  def switcht_api_l3_interface_address_add(self, device, interface_handle, vrf, ip_addr):
    """
    Parameters:
     - device
     - interface_handle
     - vrf
     - ip_addr
    """
    pass

  def switcht_api_l3_interface_address_delete(self, device, interface_handle, vrf, ip_addr):
    """
    Parameters:
     - device
     - interface_handle
     - vrf
     - ip_addr
    """
    pass

  def switcht_api_nhop_create(self, device, nhop_key):
    """
    Parameters:
     - device
     - nhop_key
    """
    pass

  def switcht_api_nhop_delete(self, device, handle):
    """
    Parameters:
     - device
     - handle
    """
    pass

  def switcht_api_nhop_print_all(self):
    pass

  def switcht_api_neighbor_entry_add(self, device, neighbor):
    """
    Parameters:
     - device
     - neighbor
    """
    pass

  def switcht_api_neighbor_entry_remove(self, device, neighbor_handle):
    """
    Parameters:
     - device
     - neighbor_handle
    """
    pass

  def switcht_api_neighbor_print_all(self):
    pass

  def switcht_api_l3_route_add(self, device, vrf, ip_addr, nhop_handle):
    """
    Parameters:
     - device
     - vrf
     - ip_addr
     - nhop_handle
    """
    pass

  def switcht_api_l3_route_delete(self, device, vrf, ip_addr, nhop_handle):
    """
    Parameters:
     - device
     - vrf
     - ip_addr
     - nhop_handle
    """
    pass

  def switcht_api_l3_routes_print_all(self):
    pass

  def switcht_api_vlan_create(self, device, vlan_id):
    """
    Parameters:
     - device
     - vlan_id
    """
    pass

  def switcht_api_vlan_delete(self, device, vlan_handle):
    """
    Parameters:
     - device
     - vlan_handle
    """
    pass

  def switcht_api_vlan_ports_add(self, device, vlan_handle, port_vlan):
    """
    Parameters:
     - device
     - vlan_handle
     - port_vlan
    """
    pass

  def switcht_api_vlan_ports_remove(self, device, vlan_handle, port_vlan):
    """
    Parameters:
     - device
     - vlan_handle
     - port_vlan
    """
    pass

  def switcht_api_vlan_print_all(self):
    pass

  def switcht_api_vlan_learning_enabled_set(self, vlan_handle, value):
    """
    Parameters:
     - vlan_handle
     - value
    """
    pass

  def switcht_api_vlan_learning_enabled_get(self, vlan_handle, value):
    """
    Parameters:
     - vlan_handle
     - value
    """
    pass

  def switcht_api_vlan_aging_interval_set(self, vlan_handle, value):
    """
    Parameters:
     - vlan_handle
     - value
    """
    pass

  def switcht_api_vlan_stats_enable(self, device, vlan_handle):
    """
    Parameters:
     - device
     - vlan_handle
    """
    pass

  def switcht_api_vlan_stats_disable(self, device, vlan_handle):
    """
    Parameters:
     - device
     - vlan_handle
    """
    pass

  def switcht_api_vlan_stats_get(self, vlan_handle, counter_ids):
    """
    Parameters:
     - vlan_handle
     - counter_ids
    """
    pass

  def switcht_api_mac_table_entry_create(self, device, vlan_handle, mac, entry_type, handle):
    """
    Parameters:
     - device
     - vlan_handle
     - mac
     - entry_type
     - handle
    """
    pass

  def switcht_api_mac_table_entry_update(self, device, vlan_handle, mac, entry_type, handle):
    """
    Parameters:
     - device
     - vlan_handle
     - mac
     - entry_type
     - handle
    """
    pass

  def switcht_api_mac_table_entry_delete(self, device, vlan_handle, mac):
    """
    Parameters:
     - device
     - vlan_handle
     - mac
    """
    pass

  def switcht_api_mac_table_entries_delete_by_vlan(self, device, vlan_handle):
    """
    Parameters:
     - device
     - vlan_handle
    """
    pass

  def switcht_api_mac_table_entries_delete_by_interface(self, device, intf_handle):
    """
    Parameters:
     - device
     - intf_handle
    """
    pass

  def switcht_api_mac_table_entries_delete_all(self, device):
    """
    Parameters:
     - device
    """
    pass

  def switcht_api_mac_table_set_learning_timeout(self, device, timeout):
    """
    Parameters:
     - device
     - timeout
    """
    pass

  def switcht_api_mac_table_aging_time_set(self, value):
    """
    Parameters:
     - value
    """
    pass

  def switcht_api_mac_table_print_all(self):
    pass

  def switcht_api_l3_ecmp_create(self, device):
    """
    Parameters:
     - device
    """
    pass

  def switcht_api_l3_ecmp_delete(self, device, handle):
    """
    Parameters:
     - device
     - handle
    """
    pass

  def switcht_api_l3_ecmp_member_add(self, device, handle, nhop_count, nhop_handle):
    """
    Parameters:
     - device
     - handle
     - nhop_count
     - nhop_handle
    """
    pass

  def switcht_api_l3_ecmp_member_delete(self, device, handle, nhop_count, nhop_handle):
    """
    Parameters:
     - device
     - handle
     - nhop_count
     - nhop_handle
    """
    pass

  def switcht_api_lag_create(self, device):
    """
    Parameters:
     - device
    """
    pass

  def switcht_api_lag_delete(self, device, lag_handle):
    """
    Parameters:
     - device
     - lag_handle
    """
    pass

  def switcht_api_lag_member_add(self, device, lag_handle, side, port):
    """
    Parameters:
     - device
     - lag_handle
     - side
     - port
    """
    pass

  def switcht_api_lag_member_delete(self, device, lag_handle, side, port):
    """
    Parameters:
     - device
     - lag_handle
     - side
     - port
    """
    pass

  def switcht_api_lag_print_all(self):
    pass

  def switcht_api_logical_network_create(self, device, info):
    """
    Parameters:
     - device
     - info
    """
    pass

  def switcht_api_logical_network_delete(self, device, network_handle):
    """
    Parameters:
     - device
     - network_handle
    """
    pass

  def switcht_api_tunnel_interface_create(self, device, direction, tun_info):
    """
    Parameters:
     - device
     - direction
     - tun_info
    """
    pass

  def switcht_api_tunnel_interface_delete(self, device, tun_handle):
    """
    Parameters:
     - device
     - tun_handle
    """
    pass

  def switcht_api_logical_network_member_add(self, device, network_handle, interface_handle):
    """
    Parameters:
     - device
     - network_handle
     - interface_handle
    """
    pass

  def switcht_api_logical_network_member_remove(self, device, network_handle, interface_handle):
    """
    Parameters:
     - device
     - network_handle
     - interface_handle
    """
    pass

  def switcht_api_mpls_tunnel_transit_create(self, device, mpls_encap):
    """
    Parameters:
     - device
     - mpls_encap
    """
    pass

  def switcht_api_mpls_tunnel_transit_delete(self, device, mpls_encap):
    """
    Parameters:
     - device
     - mpls_encap
    """
    pass

  def switcht_api_stp_group_create(self, device, stp_mode):
    """
    Parameters:
     - device
     - stp_mode
    """
    pass

  def switcht_api_stp_group_delete(self, device, stp_handle):
    """
    Parameters:
     - device
     - stp_handle
    """
    pass

  def switcht_api_stp_group_vlans_add(self, device, stp_handle, vlan_count, vlan_handle):
    """
    Parameters:
     - device
     - stp_handle
     - vlan_count
     - vlan_handle
    """
    pass

  def switcht_api_stp_group_vlans_remove(self, device, stp_handle, vlan_count, vlan_handle):
    """
    Parameters:
     - device
     - stp_handle
     - vlan_count
     - vlan_handle
    """
    pass

  def switcht_api_stp_port_state_set(self, device, stp_handle, intf_handle, stp_state):
    """
    Parameters:
     - device
     - stp_handle
     - intf_handle
     - stp_state
    """
    pass

  def switcht_api_stp_port_state_clear(self, device, stp_handle, intf_handle):
    """
    Parameters:
     - device
     - stp_handle
     - intf_handle
    """
    pass

  def switcht_api_stp_group_print_all(self):
    pass

  def switcht_api_acl_list_create(self, device, type):
    """
    Parameters:
     - device
     - type
    """
    pass

  def switcht_api_acl_list_delete(self, device, handle):
    """
    Parameters:
     - device
     - handle
    """
    pass

  def switcht_api_acl_ip_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    """
    Parameters:
     - device
     - acl_handle
     - priority
     - key_value_count
     - acl_kvp
     - action
     - action_params
    """
    pass

  def switcht_api_acl_mirror_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    """
    Parameters:
     - device
     - acl_handle
     - priority
     - key_value_count
     - acl_kvp
     - action
     - action_params
    """
    pass

  def switcht_api_acl_system_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    """
    Parameters:
     - device
     - acl_handle
     - priority
     - key_value_count
     - acl_kvp
     - action
     - action_params
    """
    pass

  def switcht_api_acl_egr_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    """
    Parameters:
     - device
     - acl_handle
     - priority
     - key_value_count
     - acl_kvp
     - action
     - action_params
    """
    pass

  def switcht_api_acl_rule_delete(self, device, acl_handle, handle):
    """
    Parameters:
     - device
     - acl_handle
     - handle
    """
    pass

  def switcht_api_acl_reference(self, device, acl_handle, interface_handle):
    """
    Parameters:
     - device
     - acl_handle
     - interface_handle
    """
    pass

  def switcht_api_acl_remove(self, device, acl_handle, interface_handle):
    """
    Parameters:
     - device
     - acl_handle
     - interface_handle
    """
    pass

  def switcht_api_hostif_group_create(self, device, hostif_group):
    """
    Parameters:
     - device
     - hostif_group
    """
    pass

  def switcht_api_hostif_group_delete(self, device, hostif_group_handle):
    """
    Parameters:
     - device
     - hostif_group_handle
    """
    pass

  def switcht_api_hostif_reason_code_create(self, device, rcode_api_info):
    """
    Parameters:
     - device
     - rcode_api_info
    """
    pass

  def switcht_api_hostif_reason_code_delete(self, device, reason_code):
    """
    Parameters:
     - device
     - reason_code
    """
    pass

  def switcht_api_hostif_create(self, device, hostif):
    """
    Parameters:
     - device
     - hostif
    """
    pass

  def switcht_api_hostif_delete(self, device, hostif_handle):
    """
    Parameters:
     - device
     - hostif_handle
    """
    pass

  def switcht_api_mirror_session_create(self, device, api_mirror_info):
    """
    Parameters:
     - device
     - api_mirror_info
    """
    pass

  def switcht_api_mirror_session_update(self, device, mirror_handle, api_mirror_info):
    """
    Parameters:
     - device
     - mirror_handle
     - api_mirror_info
    """
    pass

  def switcht_api_mirror_session_delete(self, device, mirror_handle):
    """
    Parameters:
     - device
     - mirror_handle
    """
    pass

  def switcht_int_transit_enable(self, device, switch_id, enable):
    """
    Parameters:
     - device
     - switch_id
     - enable
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def switcht_api_init(self, device):
    """
    Parameters:
     - device
    """
    self.send_switcht_api_init(device)
    return self.recv_switcht_api_init()

  def send_switcht_api_init(self, device):
    self._oprot.writeMessageBegin('switcht_api_init', TMessageType.CALL, self._seqid)
    args = switcht_api_init_args()
    args.device = device
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_init(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_init_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_init failed: unknown result")

  def switcht_api_drop_stats_get(self, device):
    """
    Parameters:
     - device
    """
    self.send_switcht_api_drop_stats_get(device)
    return self.recv_switcht_api_drop_stats_get()

  def send_switcht_api_drop_stats_get(self, device):
    self._oprot.writeMessageBegin('switcht_api_drop_stats_get', TMessageType.CALL, self._seqid)
    args = switcht_api_drop_stats_get_args()
    args.device = device
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_drop_stats_get(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_drop_stats_get_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_drop_stats_get failed: unknown result")

  def switcht_api_port_set(self, device, port_info):
    """
    Parameters:
     - device
     - port_info
    """
    self.send_switcht_api_port_set(device, port_info)
    return self.recv_switcht_api_port_set()

  def send_switcht_api_port_set(self, device, port_info):
    self._oprot.writeMessageBegin('switcht_api_port_set', TMessageType.CALL, self._seqid)
    args = switcht_api_port_set_args()
    args.device = device
    args.port_info = port_info
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_port_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_port_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_port_set failed: unknown result")

  def switcht_api_port_print_all(self):
    self.send_switcht_api_port_print_all()
    return self.recv_switcht_api_port_print_all()

  def send_switcht_api_port_print_all(self):
    self._oprot.writeMessageBegin('switcht_api_port_print_all', TMessageType.CALL, self._seqid)
    args = switcht_api_port_print_all_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_port_print_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_port_print_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_port_print_all failed: unknown result")

  def switcht_api_vrf_create(self, device, vrf):
    """
    Parameters:
     - device
     - vrf
    """
    self.send_switcht_api_vrf_create(device, vrf)
    return self.recv_switcht_api_vrf_create()

  def send_switcht_api_vrf_create(self, device, vrf):
    self._oprot.writeMessageBegin('switcht_api_vrf_create', TMessageType.CALL, self._seqid)
    args = switcht_api_vrf_create_args()
    args.device = device
    args.vrf = vrf
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vrf_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vrf_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vrf_create failed: unknown result")

  def switcht_api_vrf_delete(self, device, vrf_handle):
    """
    Parameters:
     - device
     - vrf_handle
    """
    self.send_switcht_api_vrf_delete(device, vrf_handle)
    return self.recv_switcht_api_vrf_delete()

  def send_switcht_api_vrf_delete(self, device, vrf_handle):
    self._oprot.writeMessageBegin('switcht_api_vrf_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_vrf_delete_args()
    args.device = device
    args.vrf_handle = vrf_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vrf_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vrf_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vrf_delete failed: unknown result")

  def switcht_api_router_mac_group_create(self, device):
    """
    Parameters:
     - device
    """
    self.send_switcht_api_router_mac_group_create(device)
    return self.recv_switcht_api_router_mac_group_create()

  def send_switcht_api_router_mac_group_create(self, device):
    self._oprot.writeMessageBegin('switcht_api_router_mac_group_create', TMessageType.CALL, self._seqid)
    args = switcht_api_router_mac_group_create_args()
    args.device = device
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_router_mac_group_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_router_mac_group_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_router_mac_group_create failed: unknown result")

  def switcht_api_router_mac_group_delete(self, device, rmac_handle):
    """
    Parameters:
     - device
     - rmac_handle
    """
    self.send_switcht_api_router_mac_group_delete(device, rmac_handle)
    return self.recv_switcht_api_router_mac_group_delete()

  def send_switcht_api_router_mac_group_delete(self, device, rmac_handle):
    self._oprot.writeMessageBegin('switcht_api_router_mac_group_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_router_mac_group_delete_args()
    args.device = device
    args.rmac_handle = rmac_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_router_mac_group_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_router_mac_group_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_router_mac_group_delete failed: unknown result")

  def switcht_api_router_mac_add(self, device, rmac_handle, mac):
    """
    Parameters:
     - device
     - rmac_handle
     - mac
    """
    self.send_switcht_api_router_mac_add(device, rmac_handle, mac)
    return self.recv_switcht_api_router_mac_add()

  def send_switcht_api_router_mac_add(self, device, rmac_handle, mac):
    self._oprot.writeMessageBegin('switcht_api_router_mac_add', TMessageType.CALL, self._seqid)
    args = switcht_api_router_mac_add_args()
    args.device = device
    args.rmac_handle = rmac_handle
    args.mac = mac
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_router_mac_add(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_router_mac_add_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_router_mac_add failed: unknown result")

  def switcht_api_router_mac_delete(self, device, rmac_handle, mac):
    """
    Parameters:
     - device
     - rmac_handle
     - mac
    """
    self.send_switcht_api_router_mac_delete(device, rmac_handle, mac)
    return self.recv_switcht_api_router_mac_delete()

  def send_switcht_api_router_mac_delete(self, device, rmac_handle, mac):
    self._oprot.writeMessageBegin('switcht_api_router_mac_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_router_mac_delete_args()
    args.device = device
    args.rmac_handle = rmac_handle
    args.mac = mac
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_router_mac_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_router_mac_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_router_mac_delete failed: unknown result")

  def switcht_api_router_mac_group_print_all(self):
    self.send_switcht_api_router_mac_group_print_all()
    return self.recv_switcht_api_router_mac_group_print_all()

  def send_switcht_api_router_mac_group_print_all(self):
    self._oprot.writeMessageBegin('switcht_api_router_mac_group_print_all', TMessageType.CALL, self._seqid)
    args = switcht_api_router_mac_group_print_all_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_router_mac_group_print_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_router_mac_group_print_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_router_mac_group_print_all failed: unknown result")

  def switcht_api_interface_create(self, device, interface_info):
    """
    Parameters:
     - device
     - interface_info
    """
    self.send_switcht_api_interface_create(device, interface_info)
    return self.recv_switcht_api_interface_create()

  def send_switcht_api_interface_create(self, device, interface_info):
    self._oprot.writeMessageBegin('switcht_api_interface_create', TMessageType.CALL, self._seqid)
    args = switcht_api_interface_create_args()
    args.device = device
    args.interface_info = interface_info
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_interface_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_interface_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_interface_create failed: unknown result")

  def switcht_api_interface_delete(self, device, interface_handle):
    """
    Parameters:
     - device
     - interface_handle
    """
    self.send_switcht_api_interface_delete(device, interface_handle)
    return self.recv_switcht_api_interface_delete()

  def send_switcht_api_interface_delete(self, device, interface_handle):
    self._oprot.writeMessageBegin('switcht_api_interface_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_interface_delete_args()
    args.device = device
    args.interface_handle = interface_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_interface_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_interface_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_interface_delete failed: unknown result")

  def switcht_api_interface_print_all(self):
    self.send_switcht_api_interface_print_all()
    return self.recv_switcht_api_interface_print_all()

  def send_switcht_api_interface_print_all(self):
    self._oprot.writeMessageBegin('switcht_api_interface_print_all', TMessageType.CALL, self._seqid)
    args = switcht_api_interface_print_all_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_interface_print_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_interface_print_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_interface_print_all failed: unknown result")

  def switcht_api_interface_attribute_set(self, interface_handle, attr_type, value):
    """
    Parameters:
     - interface_handle
     - attr_type
     - value
    """
    self.send_switcht_api_interface_attribute_set(interface_handle, attr_type, value)
    return self.recv_switcht_api_interface_attribute_set()

  def send_switcht_api_interface_attribute_set(self, interface_handle, attr_type, value):
    self._oprot.writeMessageBegin('switcht_api_interface_attribute_set', TMessageType.CALL, self._seqid)
    args = switcht_api_interface_attribute_set_args()
    args.interface_handle = interface_handle
    args.attr_type = attr_type
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_interface_attribute_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_interface_attribute_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_interface_attribute_set failed: unknown result")

  def switcht_api_interface_ipv4_unicast_enabled_set(self, intf_handle, value):
    """
    Parameters:
     - intf_handle
     - value
    """
    self.send_switcht_api_interface_ipv4_unicast_enabled_set(intf_handle, value)
    return self.recv_switcht_api_interface_ipv4_unicast_enabled_set()

  def send_switcht_api_interface_ipv4_unicast_enabled_set(self, intf_handle, value):
    self._oprot.writeMessageBegin('switcht_api_interface_ipv4_unicast_enabled_set', TMessageType.CALL, self._seqid)
    args = switcht_api_interface_ipv4_unicast_enabled_set_args()
    args.intf_handle = intf_handle
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_interface_ipv4_unicast_enabled_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_interface_ipv4_unicast_enabled_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_interface_ipv4_unicast_enabled_set failed: unknown result")

  def switcht_api_interface_ipv6_unicast_enabled_set(self, intf_handle, value):
    """
    Parameters:
     - intf_handle
     - value
    """
    self.send_switcht_api_interface_ipv6_unicast_enabled_set(intf_handle, value)
    return self.recv_switcht_api_interface_ipv6_unicast_enabled_set()

  def send_switcht_api_interface_ipv6_unicast_enabled_set(self, intf_handle, value):
    self._oprot.writeMessageBegin('switcht_api_interface_ipv6_unicast_enabled_set', TMessageType.CALL, self._seqid)
    args = switcht_api_interface_ipv6_unicast_enabled_set_args()
    args.intf_handle = intf_handle
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_interface_ipv6_unicast_enabled_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_interface_ipv6_unicast_enabled_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_interface_ipv6_unicast_enabled_set failed: unknown result")

  def switcht_api_interface_ipv4_urpf_mode_set(self, intf_handle, value):
    """
    Parameters:
     - intf_handle
     - value
    """
    self.send_switcht_api_interface_ipv4_urpf_mode_set(intf_handle, value)
    return self.recv_switcht_api_interface_ipv4_urpf_mode_set()

  def send_switcht_api_interface_ipv4_urpf_mode_set(self, intf_handle, value):
    self._oprot.writeMessageBegin('switcht_api_interface_ipv4_urpf_mode_set', TMessageType.CALL, self._seqid)
    args = switcht_api_interface_ipv4_urpf_mode_set_args()
    args.intf_handle = intf_handle
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_interface_ipv4_urpf_mode_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_interface_ipv4_urpf_mode_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_interface_ipv4_urpf_mode_set failed: unknown result")

  def switcht_api_interface_ipv6_urpf_mode_set(self, intf_handle, value):
    """
    Parameters:
     - intf_handle
     - value
    """
    self.send_switcht_api_interface_ipv6_urpf_mode_set(intf_handle, value)
    return self.recv_switcht_api_interface_ipv6_urpf_mode_set()

  def send_switcht_api_interface_ipv6_urpf_mode_set(self, intf_handle, value):
    self._oprot.writeMessageBegin('switcht_api_interface_ipv6_urpf_mode_set', TMessageType.CALL, self._seqid)
    args = switcht_api_interface_ipv6_urpf_mode_set_args()
    args.intf_handle = intf_handle
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_interface_ipv6_urpf_mode_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_interface_ipv6_urpf_mode_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_interface_ipv6_urpf_mode_set failed: unknown result")

  def switcht_api_l3_interface_address_add(self, device, interface_handle, vrf, ip_addr):
    """
    Parameters:
     - device
     - interface_handle
     - vrf
     - ip_addr
    """
    self.send_switcht_api_l3_interface_address_add(device, interface_handle, vrf, ip_addr)
    return self.recv_switcht_api_l3_interface_address_add()

  def send_switcht_api_l3_interface_address_add(self, device, interface_handle, vrf, ip_addr):
    self._oprot.writeMessageBegin('switcht_api_l3_interface_address_add', TMessageType.CALL, self._seqid)
    args = switcht_api_l3_interface_address_add_args()
    args.device = device
    args.interface_handle = interface_handle
    args.vrf = vrf
    args.ip_addr = ip_addr
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_l3_interface_address_add(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_l3_interface_address_add_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_l3_interface_address_add failed: unknown result")

  def switcht_api_l3_interface_address_delete(self, device, interface_handle, vrf, ip_addr):
    """
    Parameters:
     - device
     - interface_handle
     - vrf
     - ip_addr
    """
    self.send_switcht_api_l3_interface_address_delete(device, interface_handle, vrf, ip_addr)
    return self.recv_switcht_api_l3_interface_address_delete()

  def send_switcht_api_l3_interface_address_delete(self, device, interface_handle, vrf, ip_addr):
    self._oprot.writeMessageBegin('switcht_api_l3_interface_address_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_l3_interface_address_delete_args()
    args.device = device
    args.interface_handle = interface_handle
    args.vrf = vrf
    args.ip_addr = ip_addr
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_l3_interface_address_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_l3_interface_address_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_l3_interface_address_delete failed: unknown result")

  def switcht_api_nhop_create(self, device, nhop_key):
    """
    Parameters:
     - device
     - nhop_key
    """
    self.send_switcht_api_nhop_create(device, nhop_key)
    return self.recv_switcht_api_nhop_create()

  def send_switcht_api_nhop_create(self, device, nhop_key):
    self._oprot.writeMessageBegin('switcht_api_nhop_create', TMessageType.CALL, self._seqid)
    args = switcht_api_nhop_create_args()
    args.device = device
    args.nhop_key = nhop_key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_nhop_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_nhop_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_nhop_create failed: unknown result")

  def switcht_api_nhop_delete(self, device, handle):
    """
    Parameters:
     - device
     - handle
    """
    self.send_switcht_api_nhop_delete(device, handle)
    return self.recv_switcht_api_nhop_delete()

  def send_switcht_api_nhop_delete(self, device, handle):
    self._oprot.writeMessageBegin('switcht_api_nhop_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_nhop_delete_args()
    args.device = device
    args.handle = handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_nhop_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_nhop_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_nhop_delete failed: unknown result")

  def switcht_api_nhop_print_all(self):
    self.send_switcht_api_nhop_print_all()
    return self.recv_switcht_api_nhop_print_all()

  def send_switcht_api_nhop_print_all(self):
    self._oprot.writeMessageBegin('switcht_api_nhop_print_all', TMessageType.CALL, self._seqid)
    args = switcht_api_nhop_print_all_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_nhop_print_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_nhop_print_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_nhop_print_all failed: unknown result")

  def switcht_api_neighbor_entry_add(self, device, neighbor):
    """
    Parameters:
     - device
     - neighbor
    """
    self.send_switcht_api_neighbor_entry_add(device, neighbor)
    return self.recv_switcht_api_neighbor_entry_add()

  def send_switcht_api_neighbor_entry_add(self, device, neighbor):
    self._oprot.writeMessageBegin('switcht_api_neighbor_entry_add', TMessageType.CALL, self._seqid)
    args = switcht_api_neighbor_entry_add_args()
    args.device = device
    args.neighbor = neighbor
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_neighbor_entry_add(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_neighbor_entry_add_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_neighbor_entry_add failed: unknown result")

  def switcht_api_neighbor_entry_remove(self, device, neighbor_handle):
    """
    Parameters:
     - device
     - neighbor_handle
    """
    self.send_switcht_api_neighbor_entry_remove(device, neighbor_handle)
    return self.recv_switcht_api_neighbor_entry_remove()

  def send_switcht_api_neighbor_entry_remove(self, device, neighbor_handle):
    self._oprot.writeMessageBegin('switcht_api_neighbor_entry_remove', TMessageType.CALL, self._seqid)
    args = switcht_api_neighbor_entry_remove_args()
    args.device = device
    args.neighbor_handle = neighbor_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_neighbor_entry_remove(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_neighbor_entry_remove_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_neighbor_entry_remove failed: unknown result")

  def switcht_api_neighbor_print_all(self):
    self.send_switcht_api_neighbor_print_all()
    return self.recv_switcht_api_neighbor_print_all()

  def send_switcht_api_neighbor_print_all(self):
    self._oprot.writeMessageBegin('switcht_api_neighbor_print_all', TMessageType.CALL, self._seqid)
    args = switcht_api_neighbor_print_all_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_neighbor_print_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_neighbor_print_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_neighbor_print_all failed: unknown result")

  def switcht_api_l3_route_add(self, device, vrf, ip_addr, nhop_handle):
    """
    Parameters:
     - device
     - vrf
     - ip_addr
     - nhop_handle
    """
    self.send_switcht_api_l3_route_add(device, vrf, ip_addr, nhop_handle)
    return self.recv_switcht_api_l3_route_add()

  def send_switcht_api_l3_route_add(self, device, vrf, ip_addr, nhop_handle):
    self._oprot.writeMessageBegin('switcht_api_l3_route_add', TMessageType.CALL, self._seqid)
    args = switcht_api_l3_route_add_args()
    args.device = device
    args.vrf = vrf
    args.ip_addr = ip_addr
    args.nhop_handle = nhop_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_l3_route_add(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_l3_route_add_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_l3_route_add failed: unknown result")

  def switcht_api_l3_route_delete(self, device, vrf, ip_addr, nhop_handle):
    """
    Parameters:
     - device
     - vrf
     - ip_addr
     - nhop_handle
    """
    self.send_switcht_api_l3_route_delete(device, vrf, ip_addr, nhop_handle)
    return self.recv_switcht_api_l3_route_delete()

  def send_switcht_api_l3_route_delete(self, device, vrf, ip_addr, nhop_handle):
    self._oprot.writeMessageBegin('switcht_api_l3_route_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_l3_route_delete_args()
    args.device = device
    args.vrf = vrf
    args.ip_addr = ip_addr
    args.nhop_handle = nhop_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_l3_route_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_l3_route_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_l3_route_delete failed: unknown result")

  def switcht_api_l3_routes_print_all(self):
    self.send_switcht_api_l3_routes_print_all()
    return self.recv_switcht_api_l3_routes_print_all()

  def send_switcht_api_l3_routes_print_all(self):
    self._oprot.writeMessageBegin('switcht_api_l3_routes_print_all', TMessageType.CALL, self._seqid)
    args = switcht_api_l3_routes_print_all_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_l3_routes_print_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_l3_routes_print_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_l3_routes_print_all failed: unknown result")

  def switcht_api_vlan_create(self, device, vlan_id):
    """
    Parameters:
     - device
     - vlan_id
    """
    self.send_switcht_api_vlan_create(device, vlan_id)
    return self.recv_switcht_api_vlan_create()

  def send_switcht_api_vlan_create(self, device, vlan_id):
    self._oprot.writeMessageBegin('switcht_api_vlan_create', TMessageType.CALL, self._seqid)
    args = switcht_api_vlan_create_args()
    args.device = device
    args.vlan_id = vlan_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vlan_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vlan_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vlan_create failed: unknown result")

  def switcht_api_vlan_delete(self, device, vlan_handle):
    """
    Parameters:
     - device
     - vlan_handle
    """
    self.send_switcht_api_vlan_delete(device, vlan_handle)
    return self.recv_switcht_api_vlan_delete()

  def send_switcht_api_vlan_delete(self, device, vlan_handle):
    self._oprot.writeMessageBegin('switcht_api_vlan_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_vlan_delete_args()
    args.device = device
    args.vlan_handle = vlan_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vlan_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vlan_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vlan_delete failed: unknown result")

  def switcht_api_vlan_ports_add(self, device, vlan_handle, port_vlan):
    """
    Parameters:
     - device
     - vlan_handle
     - port_vlan
    """
    self.send_switcht_api_vlan_ports_add(device, vlan_handle, port_vlan)
    return self.recv_switcht_api_vlan_ports_add()

  def send_switcht_api_vlan_ports_add(self, device, vlan_handle, port_vlan):
    self._oprot.writeMessageBegin('switcht_api_vlan_ports_add', TMessageType.CALL, self._seqid)
    args = switcht_api_vlan_ports_add_args()
    args.device = device
    args.vlan_handle = vlan_handle
    args.port_vlan = port_vlan
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vlan_ports_add(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vlan_ports_add_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vlan_ports_add failed: unknown result")

  def switcht_api_vlan_ports_remove(self, device, vlan_handle, port_vlan):
    """
    Parameters:
     - device
     - vlan_handle
     - port_vlan
    """
    self.send_switcht_api_vlan_ports_remove(device, vlan_handle, port_vlan)
    return self.recv_switcht_api_vlan_ports_remove()

  def send_switcht_api_vlan_ports_remove(self, device, vlan_handle, port_vlan):
    self._oprot.writeMessageBegin('switcht_api_vlan_ports_remove', TMessageType.CALL, self._seqid)
    args = switcht_api_vlan_ports_remove_args()
    args.device = device
    args.vlan_handle = vlan_handle
    args.port_vlan = port_vlan
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vlan_ports_remove(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vlan_ports_remove_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vlan_ports_remove failed: unknown result")

  def switcht_api_vlan_print_all(self):
    self.send_switcht_api_vlan_print_all()
    return self.recv_switcht_api_vlan_print_all()

  def send_switcht_api_vlan_print_all(self):
    self._oprot.writeMessageBegin('switcht_api_vlan_print_all', TMessageType.CALL, self._seqid)
    args = switcht_api_vlan_print_all_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vlan_print_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vlan_print_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vlan_print_all failed: unknown result")

  def switcht_api_vlan_learning_enabled_set(self, vlan_handle, value):
    """
    Parameters:
     - vlan_handle
     - value
    """
    self.send_switcht_api_vlan_learning_enabled_set(vlan_handle, value)
    return self.recv_switcht_api_vlan_learning_enabled_set()

  def send_switcht_api_vlan_learning_enabled_set(self, vlan_handle, value):
    self._oprot.writeMessageBegin('switcht_api_vlan_learning_enabled_set', TMessageType.CALL, self._seqid)
    args = switcht_api_vlan_learning_enabled_set_args()
    args.vlan_handle = vlan_handle
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vlan_learning_enabled_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vlan_learning_enabled_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vlan_learning_enabled_set failed: unknown result")

  def switcht_api_vlan_learning_enabled_get(self, vlan_handle, value):
    """
    Parameters:
     - vlan_handle
     - value
    """
    self.send_switcht_api_vlan_learning_enabled_get(vlan_handle, value)
    return self.recv_switcht_api_vlan_learning_enabled_get()

  def send_switcht_api_vlan_learning_enabled_get(self, vlan_handle, value):
    self._oprot.writeMessageBegin('switcht_api_vlan_learning_enabled_get', TMessageType.CALL, self._seqid)
    args = switcht_api_vlan_learning_enabled_get_args()
    args.vlan_handle = vlan_handle
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vlan_learning_enabled_get(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vlan_learning_enabled_get_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vlan_learning_enabled_get failed: unknown result")

  def switcht_api_vlan_aging_interval_set(self, vlan_handle, value):
    """
    Parameters:
     - vlan_handle
     - value
    """
    self.send_switcht_api_vlan_aging_interval_set(vlan_handle, value)
    return self.recv_switcht_api_vlan_aging_interval_set()

  def send_switcht_api_vlan_aging_interval_set(self, vlan_handle, value):
    self._oprot.writeMessageBegin('switcht_api_vlan_aging_interval_set', TMessageType.CALL, self._seqid)
    args = switcht_api_vlan_aging_interval_set_args()
    args.vlan_handle = vlan_handle
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vlan_aging_interval_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vlan_aging_interval_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vlan_aging_interval_set failed: unknown result")

  def switcht_api_vlan_stats_enable(self, device, vlan_handle):
    """
    Parameters:
     - device
     - vlan_handle
    """
    self.send_switcht_api_vlan_stats_enable(device, vlan_handle)
    return self.recv_switcht_api_vlan_stats_enable()

  def send_switcht_api_vlan_stats_enable(self, device, vlan_handle):
    self._oprot.writeMessageBegin('switcht_api_vlan_stats_enable', TMessageType.CALL, self._seqid)
    args = switcht_api_vlan_stats_enable_args()
    args.device = device
    args.vlan_handle = vlan_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vlan_stats_enable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vlan_stats_enable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vlan_stats_enable failed: unknown result")

  def switcht_api_vlan_stats_disable(self, device, vlan_handle):
    """
    Parameters:
     - device
     - vlan_handle
    """
    self.send_switcht_api_vlan_stats_disable(device, vlan_handle)
    return self.recv_switcht_api_vlan_stats_disable()

  def send_switcht_api_vlan_stats_disable(self, device, vlan_handle):
    self._oprot.writeMessageBegin('switcht_api_vlan_stats_disable', TMessageType.CALL, self._seqid)
    args = switcht_api_vlan_stats_disable_args()
    args.device = device
    args.vlan_handle = vlan_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vlan_stats_disable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vlan_stats_disable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vlan_stats_disable failed: unknown result")

  def switcht_api_vlan_stats_get(self, vlan_handle, counter_ids):
    """
    Parameters:
     - vlan_handle
     - counter_ids
    """
    self.send_switcht_api_vlan_stats_get(vlan_handle, counter_ids)
    return self.recv_switcht_api_vlan_stats_get()

  def send_switcht_api_vlan_stats_get(self, vlan_handle, counter_ids):
    self._oprot.writeMessageBegin('switcht_api_vlan_stats_get', TMessageType.CALL, self._seqid)
    args = switcht_api_vlan_stats_get_args()
    args.vlan_handle = vlan_handle
    args.counter_ids = counter_ids
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_vlan_stats_get(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_vlan_stats_get_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_vlan_stats_get failed: unknown result")

  def switcht_api_mac_table_entry_create(self, device, vlan_handle, mac, entry_type, handle):
    """
    Parameters:
     - device
     - vlan_handle
     - mac
     - entry_type
     - handle
    """
    self.send_switcht_api_mac_table_entry_create(device, vlan_handle, mac, entry_type, handle)
    return self.recv_switcht_api_mac_table_entry_create()

  def send_switcht_api_mac_table_entry_create(self, device, vlan_handle, mac, entry_type, handle):
    self._oprot.writeMessageBegin('switcht_api_mac_table_entry_create', TMessageType.CALL, self._seqid)
    args = switcht_api_mac_table_entry_create_args()
    args.device = device
    args.vlan_handle = vlan_handle
    args.mac = mac
    args.entry_type = entry_type
    args.handle = handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mac_table_entry_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mac_table_entry_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mac_table_entry_create failed: unknown result")

  def switcht_api_mac_table_entry_update(self, device, vlan_handle, mac, entry_type, handle):
    """
    Parameters:
     - device
     - vlan_handle
     - mac
     - entry_type
     - handle
    """
    self.send_switcht_api_mac_table_entry_update(device, vlan_handle, mac, entry_type, handle)
    return self.recv_switcht_api_mac_table_entry_update()

  def send_switcht_api_mac_table_entry_update(self, device, vlan_handle, mac, entry_type, handle):
    self._oprot.writeMessageBegin('switcht_api_mac_table_entry_update', TMessageType.CALL, self._seqid)
    args = switcht_api_mac_table_entry_update_args()
    args.device = device
    args.vlan_handle = vlan_handle
    args.mac = mac
    args.entry_type = entry_type
    args.handle = handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mac_table_entry_update(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mac_table_entry_update_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mac_table_entry_update failed: unknown result")

  def switcht_api_mac_table_entry_delete(self, device, vlan_handle, mac):
    """
    Parameters:
     - device
     - vlan_handle
     - mac
    """
    self.send_switcht_api_mac_table_entry_delete(device, vlan_handle, mac)
    return self.recv_switcht_api_mac_table_entry_delete()

  def send_switcht_api_mac_table_entry_delete(self, device, vlan_handle, mac):
    self._oprot.writeMessageBegin('switcht_api_mac_table_entry_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_mac_table_entry_delete_args()
    args.device = device
    args.vlan_handle = vlan_handle
    args.mac = mac
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mac_table_entry_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mac_table_entry_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mac_table_entry_delete failed: unknown result")

  def switcht_api_mac_table_entries_delete_by_vlan(self, device, vlan_handle):
    """
    Parameters:
     - device
     - vlan_handle
    """
    self.send_switcht_api_mac_table_entries_delete_by_vlan(device, vlan_handle)
    return self.recv_switcht_api_mac_table_entries_delete_by_vlan()

  def send_switcht_api_mac_table_entries_delete_by_vlan(self, device, vlan_handle):
    self._oprot.writeMessageBegin('switcht_api_mac_table_entries_delete_by_vlan', TMessageType.CALL, self._seqid)
    args = switcht_api_mac_table_entries_delete_by_vlan_args()
    args.device = device
    args.vlan_handle = vlan_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mac_table_entries_delete_by_vlan(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mac_table_entries_delete_by_vlan_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mac_table_entries_delete_by_vlan failed: unknown result")

  def switcht_api_mac_table_entries_delete_by_interface(self, device, intf_handle):
    """
    Parameters:
     - device
     - intf_handle
    """
    self.send_switcht_api_mac_table_entries_delete_by_interface(device, intf_handle)
    return self.recv_switcht_api_mac_table_entries_delete_by_interface()

  def send_switcht_api_mac_table_entries_delete_by_interface(self, device, intf_handle):
    self._oprot.writeMessageBegin('switcht_api_mac_table_entries_delete_by_interface', TMessageType.CALL, self._seqid)
    args = switcht_api_mac_table_entries_delete_by_interface_args()
    args.device = device
    args.intf_handle = intf_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mac_table_entries_delete_by_interface(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mac_table_entries_delete_by_interface_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mac_table_entries_delete_by_interface failed: unknown result")

  def switcht_api_mac_table_entries_delete_all(self, device):
    """
    Parameters:
     - device
    """
    self.send_switcht_api_mac_table_entries_delete_all(device)
    return self.recv_switcht_api_mac_table_entries_delete_all()

  def send_switcht_api_mac_table_entries_delete_all(self, device):
    self._oprot.writeMessageBegin('switcht_api_mac_table_entries_delete_all', TMessageType.CALL, self._seqid)
    args = switcht_api_mac_table_entries_delete_all_args()
    args.device = device
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mac_table_entries_delete_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mac_table_entries_delete_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mac_table_entries_delete_all failed: unknown result")

  def switcht_api_mac_table_set_learning_timeout(self, device, timeout):
    """
    Parameters:
     - device
     - timeout
    """
    self.send_switcht_api_mac_table_set_learning_timeout(device, timeout)
    return self.recv_switcht_api_mac_table_set_learning_timeout()

  def send_switcht_api_mac_table_set_learning_timeout(self, device, timeout):
    self._oprot.writeMessageBegin('switcht_api_mac_table_set_learning_timeout', TMessageType.CALL, self._seqid)
    args = switcht_api_mac_table_set_learning_timeout_args()
    args.device = device
    args.timeout = timeout
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mac_table_set_learning_timeout(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mac_table_set_learning_timeout_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mac_table_set_learning_timeout failed: unknown result")

  def switcht_api_mac_table_aging_time_set(self, value):
    """
    Parameters:
     - value
    """
    self.send_switcht_api_mac_table_aging_time_set(value)
    return self.recv_switcht_api_mac_table_aging_time_set()

  def send_switcht_api_mac_table_aging_time_set(self, value):
    self._oprot.writeMessageBegin('switcht_api_mac_table_aging_time_set', TMessageType.CALL, self._seqid)
    args = switcht_api_mac_table_aging_time_set_args()
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mac_table_aging_time_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mac_table_aging_time_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mac_table_aging_time_set failed: unknown result")

  def switcht_api_mac_table_print_all(self):
    self.send_switcht_api_mac_table_print_all()
    return self.recv_switcht_api_mac_table_print_all()

  def send_switcht_api_mac_table_print_all(self):
    self._oprot.writeMessageBegin('switcht_api_mac_table_print_all', TMessageType.CALL, self._seqid)
    args = switcht_api_mac_table_print_all_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mac_table_print_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mac_table_print_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mac_table_print_all failed: unknown result")

  def switcht_api_l3_ecmp_create(self, device):
    """
    Parameters:
     - device
    """
    self.send_switcht_api_l3_ecmp_create(device)
    return self.recv_switcht_api_l3_ecmp_create()

  def send_switcht_api_l3_ecmp_create(self, device):
    self._oprot.writeMessageBegin('switcht_api_l3_ecmp_create', TMessageType.CALL, self._seqid)
    args = switcht_api_l3_ecmp_create_args()
    args.device = device
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_l3_ecmp_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_l3_ecmp_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_l3_ecmp_create failed: unknown result")

  def switcht_api_l3_ecmp_delete(self, device, handle):
    """
    Parameters:
     - device
     - handle
    """
    self.send_switcht_api_l3_ecmp_delete(device, handle)
    return self.recv_switcht_api_l3_ecmp_delete()

  def send_switcht_api_l3_ecmp_delete(self, device, handle):
    self._oprot.writeMessageBegin('switcht_api_l3_ecmp_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_l3_ecmp_delete_args()
    args.device = device
    args.handle = handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_l3_ecmp_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_l3_ecmp_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_l3_ecmp_delete failed: unknown result")

  def switcht_api_l3_ecmp_member_add(self, device, handle, nhop_count, nhop_handle):
    """
    Parameters:
     - device
     - handle
     - nhop_count
     - nhop_handle
    """
    self.send_switcht_api_l3_ecmp_member_add(device, handle, nhop_count, nhop_handle)
    return self.recv_switcht_api_l3_ecmp_member_add()

  def send_switcht_api_l3_ecmp_member_add(self, device, handle, nhop_count, nhop_handle):
    self._oprot.writeMessageBegin('switcht_api_l3_ecmp_member_add', TMessageType.CALL, self._seqid)
    args = switcht_api_l3_ecmp_member_add_args()
    args.device = device
    args.handle = handle
    args.nhop_count = nhop_count
    args.nhop_handle = nhop_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_l3_ecmp_member_add(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_l3_ecmp_member_add_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_l3_ecmp_member_add failed: unknown result")

  def switcht_api_l3_ecmp_member_delete(self, device, handle, nhop_count, nhop_handle):
    """
    Parameters:
     - device
     - handle
     - nhop_count
     - nhop_handle
    """
    self.send_switcht_api_l3_ecmp_member_delete(device, handle, nhop_count, nhop_handle)
    return self.recv_switcht_api_l3_ecmp_member_delete()

  def send_switcht_api_l3_ecmp_member_delete(self, device, handle, nhop_count, nhop_handle):
    self._oprot.writeMessageBegin('switcht_api_l3_ecmp_member_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_l3_ecmp_member_delete_args()
    args.device = device
    args.handle = handle
    args.nhop_count = nhop_count
    args.nhop_handle = nhop_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_l3_ecmp_member_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_l3_ecmp_member_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_l3_ecmp_member_delete failed: unknown result")

  def switcht_api_lag_create(self, device):
    """
    Parameters:
     - device
    """
    self.send_switcht_api_lag_create(device)
    return self.recv_switcht_api_lag_create()

  def send_switcht_api_lag_create(self, device):
    self._oprot.writeMessageBegin('switcht_api_lag_create', TMessageType.CALL, self._seqid)
    args = switcht_api_lag_create_args()
    args.device = device
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_lag_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_lag_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_lag_create failed: unknown result")

  def switcht_api_lag_delete(self, device, lag_handle):
    """
    Parameters:
     - device
     - lag_handle
    """
    self.send_switcht_api_lag_delete(device, lag_handle)
    return self.recv_switcht_api_lag_delete()

  def send_switcht_api_lag_delete(self, device, lag_handle):
    self._oprot.writeMessageBegin('switcht_api_lag_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_lag_delete_args()
    args.device = device
    args.lag_handle = lag_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_lag_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_lag_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_lag_delete failed: unknown result")

  def switcht_api_lag_member_add(self, device, lag_handle, side, port):
    """
    Parameters:
     - device
     - lag_handle
     - side
     - port
    """
    self.send_switcht_api_lag_member_add(device, lag_handle, side, port)
    return self.recv_switcht_api_lag_member_add()

  def send_switcht_api_lag_member_add(self, device, lag_handle, side, port):
    self._oprot.writeMessageBegin('switcht_api_lag_member_add', TMessageType.CALL, self._seqid)
    args = switcht_api_lag_member_add_args()
    args.device = device
    args.lag_handle = lag_handle
    args.side = side
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_lag_member_add(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_lag_member_add_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_lag_member_add failed: unknown result")

  def switcht_api_lag_member_delete(self, device, lag_handle, side, port):
    """
    Parameters:
     - device
     - lag_handle
     - side
     - port
    """
    self.send_switcht_api_lag_member_delete(device, lag_handle, side, port)
    return self.recv_switcht_api_lag_member_delete()

  def send_switcht_api_lag_member_delete(self, device, lag_handle, side, port):
    self._oprot.writeMessageBegin('switcht_api_lag_member_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_lag_member_delete_args()
    args.device = device
    args.lag_handle = lag_handle
    args.side = side
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_lag_member_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_lag_member_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_lag_member_delete failed: unknown result")

  def switcht_api_lag_print_all(self):
    self.send_switcht_api_lag_print_all()
    return self.recv_switcht_api_lag_print_all()

  def send_switcht_api_lag_print_all(self):
    self._oprot.writeMessageBegin('switcht_api_lag_print_all', TMessageType.CALL, self._seqid)
    args = switcht_api_lag_print_all_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_lag_print_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_lag_print_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_lag_print_all failed: unknown result")

  def switcht_api_logical_network_create(self, device, info):
    """
    Parameters:
     - device
     - info
    """
    self.send_switcht_api_logical_network_create(device, info)
    return self.recv_switcht_api_logical_network_create()

  def send_switcht_api_logical_network_create(self, device, info):
    self._oprot.writeMessageBegin('switcht_api_logical_network_create', TMessageType.CALL, self._seqid)
    args = switcht_api_logical_network_create_args()
    args.device = device
    args.info = info
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_logical_network_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_logical_network_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_logical_network_create failed: unknown result")

  def switcht_api_logical_network_delete(self, device, network_handle):
    """
    Parameters:
     - device
     - network_handle
    """
    self.send_switcht_api_logical_network_delete(device, network_handle)
    return self.recv_switcht_api_logical_network_delete()

  def send_switcht_api_logical_network_delete(self, device, network_handle):
    self._oprot.writeMessageBegin('switcht_api_logical_network_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_logical_network_delete_args()
    args.device = device
    args.network_handle = network_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_logical_network_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_logical_network_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_logical_network_delete failed: unknown result")

  def switcht_api_tunnel_interface_create(self, device, direction, tun_info):
    """
    Parameters:
     - device
     - direction
     - tun_info
    """
    self.send_switcht_api_tunnel_interface_create(device, direction, tun_info)
    return self.recv_switcht_api_tunnel_interface_create()

  def send_switcht_api_tunnel_interface_create(self, device, direction, tun_info):
    self._oprot.writeMessageBegin('switcht_api_tunnel_interface_create', TMessageType.CALL, self._seqid)
    args = switcht_api_tunnel_interface_create_args()
    args.device = device
    args.direction = direction
    args.tun_info = tun_info
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_tunnel_interface_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_tunnel_interface_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_tunnel_interface_create failed: unknown result")

  def switcht_api_tunnel_interface_delete(self, device, tun_handle):
    """
    Parameters:
     - device
     - tun_handle
    """
    self.send_switcht_api_tunnel_interface_delete(device, tun_handle)
    return self.recv_switcht_api_tunnel_interface_delete()

  def send_switcht_api_tunnel_interface_delete(self, device, tun_handle):
    self._oprot.writeMessageBegin('switcht_api_tunnel_interface_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_tunnel_interface_delete_args()
    args.device = device
    args.tun_handle = tun_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_tunnel_interface_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_tunnel_interface_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_tunnel_interface_delete failed: unknown result")

  def switcht_api_logical_network_member_add(self, device, network_handle, interface_handle):
    """
    Parameters:
     - device
     - network_handle
     - interface_handle
    """
    self.send_switcht_api_logical_network_member_add(device, network_handle, interface_handle)
    return self.recv_switcht_api_logical_network_member_add()

  def send_switcht_api_logical_network_member_add(self, device, network_handle, interface_handle):
    self._oprot.writeMessageBegin('switcht_api_logical_network_member_add', TMessageType.CALL, self._seqid)
    args = switcht_api_logical_network_member_add_args()
    args.device = device
    args.network_handle = network_handle
    args.interface_handle = interface_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_logical_network_member_add(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_logical_network_member_add_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_logical_network_member_add failed: unknown result")

  def switcht_api_logical_network_member_remove(self, device, network_handle, interface_handle):
    """
    Parameters:
     - device
     - network_handle
     - interface_handle
    """
    self.send_switcht_api_logical_network_member_remove(device, network_handle, interface_handle)
    return self.recv_switcht_api_logical_network_member_remove()

  def send_switcht_api_logical_network_member_remove(self, device, network_handle, interface_handle):
    self._oprot.writeMessageBegin('switcht_api_logical_network_member_remove', TMessageType.CALL, self._seqid)
    args = switcht_api_logical_network_member_remove_args()
    args.device = device
    args.network_handle = network_handle
    args.interface_handle = interface_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_logical_network_member_remove(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_logical_network_member_remove_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_logical_network_member_remove failed: unknown result")

  def switcht_api_mpls_tunnel_transit_create(self, device, mpls_encap):
    """
    Parameters:
     - device
     - mpls_encap
    """
    self.send_switcht_api_mpls_tunnel_transit_create(device, mpls_encap)
    return self.recv_switcht_api_mpls_tunnel_transit_create()

  def send_switcht_api_mpls_tunnel_transit_create(self, device, mpls_encap):
    self._oprot.writeMessageBegin('switcht_api_mpls_tunnel_transit_create', TMessageType.CALL, self._seqid)
    args = switcht_api_mpls_tunnel_transit_create_args()
    args.device = device
    args.mpls_encap = mpls_encap
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mpls_tunnel_transit_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mpls_tunnel_transit_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mpls_tunnel_transit_create failed: unknown result")

  def switcht_api_mpls_tunnel_transit_delete(self, device, mpls_encap):
    """
    Parameters:
     - device
     - mpls_encap
    """
    self.send_switcht_api_mpls_tunnel_transit_delete(device, mpls_encap)
    return self.recv_switcht_api_mpls_tunnel_transit_delete()

  def send_switcht_api_mpls_tunnel_transit_delete(self, device, mpls_encap):
    self._oprot.writeMessageBegin('switcht_api_mpls_tunnel_transit_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_mpls_tunnel_transit_delete_args()
    args.device = device
    args.mpls_encap = mpls_encap
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mpls_tunnel_transit_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mpls_tunnel_transit_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mpls_tunnel_transit_delete failed: unknown result")

  def switcht_api_stp_group_create(self, device, stp_mode):
    """
    Parameters:
     - device
     - stp_mode
    """
    self.send_switcht_api_stp_group_create(device, stp_mode)
    return self.recv_switcht_api_stp_group_create()

  def send_switcht_api_stp_group_create(self, device, stp_mode):
    self._oprot.writeMessageBegin('switcht_api_stp_group_create', TMessageType.CALL, self._seqid)
    args = switcht_api_stp_group_create_args()
    args.device = device
    args.stp_mode = stp_mode
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_stp_group_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_stp_group_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_stp_group_create failed: unknown result")

  def switcht_api_stp_group_delete(self, device, stp_handle):
    """
    Parameters:
     - device
     - stp_handle
    """
    self.send_switcht_api_stp_group_delete(device, stp_handle)
    return self.recv_switcht_api_stp_group_delete()

  def send_switcht_api_stp_group_delete(self, device, stp_handle):
    self._oprot.writeMessageBegin('switcht_api_stp_group_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_stp_group_delete_args()
    args.device = device
    args.stp_handle = stp_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_stp_group_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_stp_group_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_stp_group_delete failed: unknown result")

  def switcht_api_stp_group_vlans_add(self, device, stp_handle, vlan_count, vlan_handle):
    """
    Parameters:
     - device
     - stp_handle
     - vlan_count
     - vlan_handle
    """
    self.send_switcht_api_stp_group_vlans_add(device, stp_handle, vlan_count, vlan_handle)
    return self.recv_switcht_api_stp_group_vlans_add()

  def send_switcht_api_stp_group_vlans_add(self, device, stp_handle, vlan_count, vlan_handle):
    self._oprot.writeMessageBegin('switcht_api_stp_group_vlans_add', TMessageType.CALL, self._seqid)
    args = switcht_api_stp_group_vlans_add_args()
    args.device = device
    args.stp_handle = stp_handle
    args.vlan_count = vlan_count
    args.vlan_handle = vlan_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_stp_group_vlans_add(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_stp_group_vlans_add_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_stp_group_vlans_add failed: unknown result")

  def switcht_api_stp_group_vlans_remove(self, device, stp_handle, vlan_count, vlan_handle):
    """
    Parameters:
     - device
     - stp_handle
     - vlan_count
     - vlan_handle
    """
    self.send_switcht_api_stp_group_vlans_remove(device, stp_handle, vlan_count, vlan_handle)
    return self.recv_switcht_api_stp_group_vlans_remove()

  def send_switcht_api_stp_group_vlans_remove(self, device, stp_handle, vlan_count, vlan_handle):
    self._oprot.writeMessageBegin('switcht_api_stp_group_vlans_remove', TMessageType.CALL, self._seqid)
    args = switcht_api_stp_group_vlans_remove_args()
    args.device = device
    args.stp_handle = stp_handle
    args.vlan_count = vlan_count
    args.vlan_handle = vlan_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_stp_group_vlans_remove(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_stp_group_vlans_remove_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_stp_group_vlans_remove failed: unknown result")

  def switcht_api_stp_port_state_set(self, device, stp_handle, intf_handle, stp_state):
    """
    Parameters:
     - device
     - stp_handle
     - intf_handle
     - stp_state
    """
    self.send_switcht_api_stp_port_state_set(device, stp_handle, intf_handle, stp_state)
    return self.recv_switcht_api_stp_port_state_set()

  def send_switcht_api_stp_port_state_set(self, device, stp_handle, intf_handle, stp_state):
    self._oprot.writeMessageBegin('switcht_api_stp_port_state_set', TMessageType.CALL, self._seqid)
    args = switcht_api_stp_port_state_set_args()
    args.device = device
    args.stp_handle = stp_handle
    args.intf_handle = intf_handle
    args.stp_state = stp_state
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_stp_port_state_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_stp_port_state_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_stp_port_state_set failed: unknown result")

  def switcht_api_stp_port_state_clear(self, device, stp_handle, intf_handle):
    """
    Parameters:
     - device
     - stp_handle
     - intf_handle
    """
    self.send_switcht_api_stp_port_state_clear(device, stp_handle, intf_handle)
    return self.recv_switcht_api_stp_port_state_clear()

  def send_switcht_api_stp_port_state_clear(self, device, stp_handle, intf_handle):
    self._oprot.writeMessageBegin('switcht_api_stp_port_state_clear', TMessageType.CALL, self._seqid)
    args = switcht_api_stp_port_state_clear_args()
    args.device = device
    args.stp_handle = stp_handle
    args.intf_handle = intf_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_stp_port_state_clear(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_stp_port_state_clear_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_stp_port_state_clear failed: unknown result")

  def switcht_api_stp_group_print_all(self):
    self.send_switcht_api_stp_group_print_all()
    return self.recv_switcht_api_stp_group_print_all()

  def send_switcht_api_stp_group_print_all(self):
    self._oprot.writeMessageBegin('switcht_api_stp_group_print_all', TMessageType.CALL, self._seqid)
    args = switcht_api_stp_group_print_all_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_stp_group_print_all(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_stp_group_print_all_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_stp_group_print_all failed: unknown result")

  def switcht_api_acl_list_create(self, device, type):
    """
    Parameters:
     - device
     - type
    """
    self.send_switcht_api_acl_list_create(device, type)
    return self.recv_switcht_api_acl_list_create()

  def send_switcht_api_acl_list_create(self, device, type):
    self._oprot.writeMessageBegin('switcht_api_acl_list_create', TMessageType.CALL, self._seqid)
    args = switcht_api_acl_list_create_args()
    args.device = device
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_acl_list_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_acl_list_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_acl_list_create failed: unknown result")

  def switcht_api_acl_list_delete(self, device, handle):
    """
    Parameters:
     - device
     - handle
    """
    self.send_switcht_api_acl_list_delete(device, handle)
    return self.recv_switcht_api_acl_list_delete()

  def send_switcht_api_acl_list_delete(self, device, handle):
    self._oprot.writeMessageBegin('switcht_api_acl_list_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_acl_list_delete_args()
    args.device = device
    args.handle = handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_acl_list_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_acl_list_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_acl_list_delete failed: unknown result")

  def switcht_api_acl_ip_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    """
    Parameters:
     - device
     - acl_handle
     - priority
     - key_value_count
     - acl_kvp
     - action
     - action_params
    """
    self.send_switcht_api_acl_ip_rule_create(device, acl_handle, priority, key_value_count, acl_kvp, action, action_params)
    return self.recv_switcht_api_acl_ip_rule_create()

  def send_switcht_api_acl_ip_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    self._oprot.writeMessageBegin('switcht_api_acl_ip_rule_create', TMessageType.CALL, self._seqid)
    args = switcht_api_acl_ip_rule_create_args()
    args.device = device
    args.acl_handle = acl_handle
    args.priority = priority
    args.key_value_count = key_value_count
    args.acl_kvp = acl_kvp
    args.action = action
    args.action_params = action_params
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_acl_ip_rule_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_acl_ip_rule_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_acl_ip_rule_create failed: unknown result")

  def switcht_api_acl_mirror_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    """
    Parameters:
     - device
     - acl_handle
     - priority
     - key_value_count
     - acl_kvp
     - action
     - action_params
    """
    self.send_switcht_api_acl_mirror_rule_create(device, acl_handle, priority, key_value_count, acl_kvp, action, action_params)
    return self.recv_switcht_api_acl_mirror_rule_create()

  def send_switcht_api_acl_mirror_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    self._oprot.writeMessageBegin('switcht_api_acl_mirror_rule_create', TMessageType.CALL, self._seqid)
    args = switcht_api_acl_mirror_rule_create_args()
    args.device = device
    args.acl_handle = acl_handle
    args.priority = priority
    args.key_value_count = key_value_count
    args.acl_kvp = acl_kvp
    args.action = action
    args.action_params = action_params
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_acl_mirror_rule_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_acl_mirror_rule_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_acl_mirror_rule_create failed: unknown result")

  def switcht_api_acl_system_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    """
    Parameters:
     - device
     - acl_handle
     - priority
     - key_value_count
     - acl_kvp
     - action
     - action_params
    """
    self.send_switcht_api_acl_system_rule_create(device, acl_handle, priority, key_value_count, acl_kvp, action, action_params)
    return self.recv_switcht_api_acl_system_rule_create()

  def send_switcht_api_acl_system_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    self._oprot.writeMessageBegin('switcht_api_acl_system_rule_create', TMessageType.CALL, self._seqid)
    args = switcht_api_acl_system_rule_create_args()
    args.device = device
    args.acl_handle = acl_handle
    args.priority = priority
    args.key_value_count = key_value_count
    args.acl_kvp = acl_kvp
    args.action = action
    args.action_params = action_params
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_acl_system_rule_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_acl_system_rule_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_acl_system_rule_create failed: unknown result")

  def switcht_api_acl_egr_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    """
    Parameters:
     - device
     - acl_handle
     - priority
     - key_value_count
     - acl_kvp
     - action
     - action_params
    """
    self.send_switcht_api_acl_egr_rule_create(device, acl_handle, priority, key_value_count, acl_kvp, action, action_params)
    return self.recv_switcht_api_acl_egr_rule_create()

  def send_switcht_api_acl_egr_rule_create(self, device, acl_handle, priority, key_value_count, acl_kvp, action, action_params):
    self._oprot.writeMessageBegin('switcht_api_acl_egr_rule_create', TMessageType.CALL, self._seqid)
    args = switcht_api_acl_egr_rule_create_args()
    args.device = device
    args.acl_handle = acl_handle
    args.priority = priority
    args.key_value_count = key_value_count
    args.acl_kvp = acl_kvp
    args.action = action
    args.action_params = action_params
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_acl_egr_rule_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_acl_egr_rule_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_acl_egr_rule_create failed: unknown result")

  def switcht_api_acl_rule_delete(self, device, acl_handle, handle):
    """
    Parameters:
     - device
     - acl_handle
     - handle
    """
    self.send_switcht_api_acl_rule_delete(device, acl_handle, handle)
    return self.recv_switcht_api_acl_rule_delete()

  def send_switcht_api_acl_rule_delete(self, device, acl_handle, handle):
    self._oprot.writeMessageBegin('switcht_api_acl_rule_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_acl_rule_delete_args()
    args.device = device
    args.acl_handle = acl_handle
    args.handle = handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_acl_rule_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_acl_rule_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_acl_rule_delete failed: unknown result")

  def switcht_api_acl_reference(self, device, acl_handle, interface_handle):
    """
    Parameters:
     - device
     - acl_handle
     - interface_handle
    """
    self.send_switcht_api_acl_reference(device, acl_handle, interface_handle)
    return self.recv_switcht_api_acl_reference()

  def send_switcht_api_acl_reference(self, device, acl_handle, interface_handle):
    self._oprot.writeMessageBegin('switcht_api_acl_reference', TMessageType.CALL, self._seqid)
    args = switcht_api_acl_reference_args()
    args.device = device
    args.acl_handle = acl_handle
    args.interface_handle = interface_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_acl_reference(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_acl_reference_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_acl_reference failed: unknown result")

  def switcht_api_acl_remove(self, device, acl_handle, interface_handle):
    """
    Parameters:
     - device
     - acl_handle
     - interface_handle
    """
    self.send_switcht_api_acl_remove(device, acl_handle, interface_handle)
    return self.recv_switcht_api_acl_remove()

  def send_switcht_api_acl_remove(self, device, acl_handle, interface_handle):
    self._oprot.writeMessageBegin('switcht_api_acl_remove', TMessageType.CALL, self._seqid)
    args = switcht_api_acl_remove_args()
    args.device = device
    args.acl_handle = acl_handle
    args.interface_handle = interface_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_acl_remove(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_acl_remove_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_acl_remove failed: unknown result")

  def switcht_api_hostif_group_create(self, device, hostif_group):
    """
    Parameters:
     - device
     - hostif_group
    """
    self.send_switcht_api_hostif_group_create(device, hostif_group)
    return self.recv_switcht_api_hostif_group_create()

  def send_switcht_api_hostif_group_create(self, device, hostif_group):
    self._oprot.writeMessageBegin('switcht_api_hostif_group_create', TMessageType.CALL, self._seqid)
    args = switcht_api_hostif_group_create_args()
    args.device = device
    args.hostif_group = hostif_group
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_hostif_group_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_hostif_group_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_hostif_group_create failed: unknown result")

  def switcht_api_hostif_group_delete(self, device, hostif_group_handle):
    """
    Parameters:
     - device
     - hostif_group_handle
    """
    self.send_switcht_api_hostif_group_delete(device, hostif_group_handle)
    return self.recv_switcht_api_hostif_group_delete()

  def send_switcht_api_hostif_group_delete(self, device, hostif_group_handle):
    self._oprot.writeMessageBegin('switcht_api_hostif_group_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_hostif_group_delete_args()
    args.device = device
    args.hostif_group_handle = hostif_group_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_hostif_group_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_hostif_group_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_hostif_group_delete failed: unknown result")

  def switcht_api_hostif_reason_code_create(self, device, rcode_api_info):
    """
    Parameters:
     - device
     - rcode_api_info
    """
    self.send_switcht_api_hostif_reason_code_create(device, rcode_api_info)
    return self.recv_switcht_api_hostif_reason_code_create()

  def send_switcht_api_hostif_reason_code_create(self, device, rcode_api_info):
    self._oprot.writeMessageBegin('switcht_api_hostif_reason_code_create', TMessageType.CALL, self._seqid)
    args = switcht_api_hostif_reason_code_create_args()
    args.device = device
    args.rcode_api_info = rcode_api_info
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_hostif_reason_code_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_hostif_reason_code_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_hostif_reason_code_create failed: unknown result")

  def switcht_api_hostif_reason_code_delete(self, device, reason_code):
    """
    Parameters:
     - device
     - reason_code
    """
    self.send_switcht_api_hostif_reason_code_delete(device, reason_code)
    return self.recv_switcht_api_hostif_reason_code_delete()

  def send_switcht_api_hostif_reason_code_delete(self, device, reason_code):
    self._oprot.writeMessageBegin('switcht_api_hostif_reason_code_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_hostif_reason_code_delete_args()
    args.device = device
    args.reason_code = reason_code
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_hostif_reason_code_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_hostif_reason_code_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_hostif_reason_code_delete failed: unknown result")

  def switcht_api_hostif_create(self, device, hostif):
    """
    Parameters:
     - device
     - hostif
    """
    self.send_switcht_api_hostif_create(device, hostif)
    return self.recv_switcht_api_hostif_create()

  def send_switcht_api_hostif_create(self, device, hostif):
    self._oprot.writeMessageBegin('switcht_api_hostif_create', TMessageType.CALL, self._seqid)
    args = switcht_api_hostif_create_args()
    args.device = device
    args.hostif = hostif
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_hostif_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_hostif_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_hostif_create failed: unknown result")

  def switcht_api_hostif_delete(self, device, hostif_handle):
    """
    Parameters:
     - device
     - hostif_handle
    """
    self.send_switcht_api_hostif_delete(device, hostif_handle)
    return self.recv_switcht_api_hostif_delete()

  def send_switcht_api_hostif_delete(self, device, hostif_handle):
    self._oprot.writeMessageBegin('switcht_api_hostif_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_hostif_delete_args()
    args.device = device
    args.hostif_handle = hostif_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_hostif_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_hostif_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_hostif_delete failed: unknown result")

  def switcht_api_mirror_session_create(self, device, api_mirror_info):
    """
    Parameters:
     - device
     - api_mirror_info
    """
    self.send_switcht_api_mirror_session_create(device, api_mirror_info)
    return self.recv_switcht_api_mirror_session_create()

  def send_switcht_api_mirror_session_create(self, device, api_mirror_info):
    self._oprot.writeMessageBegin('switcht_api_mirror_session_create', TMessageType.CALL, self._seqid)
    args = switcht_api_mirror_session_create_args()
    args.device = device
    args.api_mirror_info = api_mirror_info
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mirror_session_create(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mirror_session_create_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mirror_session_create failed: unknown result")

  def switcht_api_mirror_session_update(self, device, mirror_handle, api_mirror_info):
    """
    Parameters:
     - device
     - mirror_handle
     - api_mirror_info
    """
    self.send_switcht_api_mirror_session_update(device, mirror_handle, api_mirror_info)
    return self.recv_switcht_api_mirror_session_update()

  def send_switcht_api_mirror_session_update(self, device, mirror_handle, api_mirror_info):
    self._oprot.writeMessageBegin('switcht_api_mirror_session_update', TMessageType.CALL, self._seqid)
    args = switcht_api_mirror_session_update_args()
    args.device = device
    args.mirror_handle = mirror_handle
    args.api_mirror_info = api_mirror_info
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mirror_session_update(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mirror_session_update_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mirror_session_update failed: unknown result")

  def switcht_api_mirror_session_delete(self, device, mirror_handle):
    """
    Parameters:
     - device
     - mirror_handle
    """
    self.send_switcht_api_mirror_session_delete(device, mirror_handle)
    return self.recv_switcht_api_mirror_session_delete()

  def send_switcht_api_mirror_session_delete(self, device, mirror_handle):
    self._oprot.writeMessageBegin('switcht_api_mirror_session_delete', TMessageType.CALL, self._seqid)
    args = switcht_api_mirror_session_delete_args()
    args.device = device
    args.mirror_handle = mirror_handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_api_mirror_session_delete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_api_mirror_session_delete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_api_mirror_session_delete failed: unknown result")

  def switcht_int_transit_enable(self, device, switch_id, enable):
    """
    Parameters:
     - device
     - switch_id
     - enable
    """
    self.send_switcht_int_transit_enable(device, switch_id, enable)
    return self.recv_switcht_int_transit_enable()

  def send_switcht_int_transit_enable(self, device, switch_id, enable):
    self._oprot.writeMessageBegin('switcht_int_transit_enable', TMessageType.CALL, self._seqid)
    args = switcht_int_transit_enable_args()
    args.device = device
    args.switch_id = switch_id
    args.enable = enable
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_switcht_int_transit_enable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = switcht_int_transit_enable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "switcht_int_transit_enable failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["switcht_api_init"] = Processor.process_switcht_api_init
    self._processMap["switcht_api_drop_stats_get"] = Processor.process_switcht_api_drop_stats_get
    self._processMap["switcht_api_port_set"] = Processor.process_switcht_api_port_set
    self._processMap["switcht_api_port_print_all"] = Processor.process_switcht_api_port_print_all
    self._processMap["switcht_api_vrf_create"] = Processor.process_switcht_api_vrf_create
    self._processMap["switcht_api_vrf_delete"] = Processor.process_switcht_api_vrf_delete
    self._processMap["switcht_api_router_mac_group_create"] = Processor.process_switcht_api_router_mac_group_create
    self._processMap["switcht_api_router_mac_group_delete"] = Processor.process_switcht_api_router_mac_group_delete
    self._processMap["switcht_api_router_mac_add"] = Processor.process_switcht_api_router_mac_add
    self._processMap["switcht_api_router_mac_delete"] = Processor.process_switcht_api_router_mac_delete
    self._processMap["switcht_api_router_mac_group_print_all"] = Processor.process_switcht_api_router_mac_group_print_all
    self._processMap["switcht_api_interface_create"] = Processor.process_switcht_api_interface_create
    self._processMap["switcht_api_interface_delete"] = Processor.process_switcht_api_interface_delete
    self._processMap["switcht_api_interface_print_all"] = Processor.process_switcht_api_interface_print_all
    self._processMap["switcht_api_interface_attribute_set"] = Processor.process_switcht_api_interface_attribute_set
    self._processMap["switcht_api_interface_ipv4_unicast_enabled_set"] = Processor.process_switcht_api_interface_ipv4_unicast_enabled_set
    self._processMap["switcht_api_interface_ipv6_unicast_enabled_set"] = Processor.process_switcht_api_interface_ipv6_unicast_enabled_set
    self._processMap["switcht_api_interface_ipv4_urpf_mode_set"] = Processor.process_switcht_api_interface_ipv4_urpf_mode_set
    self._processMap["switcht_api_interface_ipv6_urpf_mode_set"] = Processor.process_switcht_api_interface_ipv6_urpf_mode_set
    self._processMap["switcht_api_l3_interface_address_add"] = Processor.process_switcht_api_l3_interface_address_add
    self._processMap["switcht_api_l3_interface_address_delete"] = Processor.process_switcht_api_l3_interface_address_delete
    self._processMap["switcht_api_nhop_create"] = Processor.process_switcht_api_nhop_create
    self._processMap["switcht_api_nhop_delete"] = Processor.process_switcht_api_nhop_delete
    self._processMap["switcht_api_nhop_print_all"] = Processor.process_switcht_api_nhop_print_all
    self._processMap["switcht_api_neighbor_entry_add"] = Processor.process_switcht_api_neighbor_entry_add
    self._processMap["switcht_api_neighbor_entry_remove"] = Processor.process_switcht_api_neighbor_entry_remove
    self._processMap["switcht_api_neighbor_print_all"] = Processor.process_switcht_api_neighbor_print_all
    self._processMap["switcht_api_l3_route_add"] = Processor.process_switcht_api_l3_route_add
    self._processMap["switcht_api_l3_route_delete"] = Processor.process_switcht_api_l3_route_delete
    self._processMap["switcht_api_l3_routes_print_all"] = Processor.process_switcht_api_l3_routes_print_all
    self._processMap["switcht_api_vlan_create"] = Processor.process_switcht_api_vlan_create
    self._processMap["switcht_api_vlan_delete"] = Processor.process_switcht_api_vlan_delete
    self._processMap["switcht_api_vlan_ports_add"] = Processor.process_switcht_api_vlan_ports_add
    self._processMap["switcht_api_vlan_ports_remove"] = Processor.process_switcht_api_vlan_ports_remove
    self._processMap["switcht_api_vlan_print_all"] = Processor.process_switcht_api_vlan_print_all
    self._processMap["switcht_api_vlan_learning_enabled_set"] = Processor.process_switcht_api_vlan_learning_enabled_set
    self._processMap["switcht_api_vlan_learning_enabled_get"] = Processor.process_switcht_api_vlan_learning_enabled_get
    self._processMap["switcht_api_vlan_aging_interval_set"] = Processor.process_switcht_api_vlan_aging_interval_set
    self._processMap["switcht_api_vlan_stats_enable"] = Processor.process_switcht_api_vlan_stats_enable
    self._processMap["switcht_api_vlan_stats_disable"] = Processor.process_switcht_api_vlan_stats_disable
    self._processMap["switcht_api_vlan_stats_get"] = Processor.process_switcht_api_vlan_stats_get
    self._processMap["switcht_api_mac_table_entry_create"] = Processor.process_switcht_api_mac_table_entry_create
    self._processMap["switcht_api_mac_table_entry_update"] = Processor.process_switcht_api_mac_table_entry_update
    self._processMap["switcht_api_mac_table_entry_delete"] = Processor.process_switcht_api_mac_table_entry_delete
    self._processMap["switcht_api_mac_table_entries_delete_by_vlan"] = Processor.process_switcht_api_mac_table_entries_delete_by_vlan
    self._processMap["switcht_api_mac_table_entries_delete_by_interface"] = Processor.process_switcht_api_mac_table_entries_delete_by_interface
    self._processMap["switcht_api_mac_table_entries_delete_all"] = Processor.process_switcht_api_mac_table_entries_delete_all
    self._processMap["switcht_api_mac_table_set_learning_timeout"] = Processor.process_switcht_api_mac_table_set_learning_timeout
    self._processMap["switcht_api_mac_table_aging_time_set"] = Processor.process_switcht_api_mac_table_aging_time_set
    self._processMap["switcht_api_mac_table_print_all"] = Processor.process_switcht_api_mac_table_print_all
    self._processMap["switcht_api_l3_ecmp_create"] = Processor.process_switcht_api_l3_ecmp_create
    self._processMap["switcht_api_l3_ecmp_delete"] = Processor.process_switcht_api_l3_ecmp_delete
    self._processMap["switcht_api_l3_ecmp_member_add"] = Processor.process_switcht_api_l3_ecmp_member_add
    self._processMap["switcht_api_l3_ecmp_member_delete"] = Processor.process_switcht_api_l3_ecmp_member_delete
    self._processMap["switcht_api_lag_create"] = Processor.process_switcht_api_lag_create
    self._processMap["switcht_api_lag_delete"] = Processor.process_switcht_api_lag_delete
    self._processMap["switcht_api_lag_member_add"] = Processor.process_switcht_api_lag_member_add
    self._processMap["switcht_api_lag_member_delete"] = Processor.process_switcht_api_lag_member_delete
    self._processMap["switcht_api_lag_print_all"] = Processor.process_switcht_api_lag_print_all
    self._processMap["switcht_api_logical_network_create"] = Processor.process_switcht_api_logical_network_create
    self._processMap["switcht_api_logical_network_delete"] = Processor.process_switcht_api_logical_network_delete
    self._processMap["switcht_api_tunnel_interface_create"] = Processor.process_switcht_api_tunnel_interface_create
    self._processMap["switcht_api_tunnel_interface_delete"] = Processor.process_switcht_api_tunnel_interface_delete
    self._processMap["switcht_api_logical_network_member_add"] = Processor.process_switcht_api_logical_network_member_add
    self._processMap["switcht_api_logical_network_member_remove"] = Processor.process_switcht_api_logical_network_member_remove
    self._processMap["switcht_api_mpls_tunnel_transit_create"] = Processor.process_switcht_api_mpls_tunnel_transit_create
    self._processMap["switcht_api_mpls_tunnel_transit_delete"] = Processor.process_switcht_api_mpls_tunnel_transit_delete
    self._processMap["switcht_api_stp_group_create"] = Processor.process_switcht_api_stp_group_create
    self._processMap["switcht_api_stp_group_delete"] = Processor.process_switcht_api_stp_group_delete
    self._processMap["switcht_api_stp_group_vlans_add"] = Processor.process_switcht_api_stp_group_vlans_add
    self._processMap["switcht_api_stp_group_vlans_remove"] = Processor.process_switcht_api_stp_group_vlans_remove
    self._processMap["switcht_api_stp_port_state_set"] = Processor.process_switcht_api_stp_port_state_set
    self._processMap["switcht_api_stp_port_state_clear"] = Processor.process_switcht_api_stp_port_state_clear
    self._processMap["switcht_api_stp_group_print_all"] = Processor.process_switcht_api_stp_group_print_all
    self._processMap["switcht_api_acl_list_create"] = Processor.process_switcht_api_acl_list_create
    self._processMap["switcht_api_acl_list_delete"] = Processor.process_switcht_api_acl_list_delete
    self._processMap["switcht_api_acl_ip_rule_create"] = Processor.process_switcht_api_acl_ip_rule_create
    self._processMap["switcht_api_acl_mirror_rule_create"] = Processor.process_switcht_api_acl_mirror_rule_create
    self._processMap["switcht_api_acl_system_rule_create"] = Processor.process_switcht_api_acl_system_rule_create
    self._processMap["switcht_api_acl_egr_rule_create"] = Processor.process_switcht_api_acl_egr_rule_create
    self._processMap["switcht_api_acl_rule_delete"] = Processor.process_switcht_api_acl_rule_delete
    self._processMap["switcht_api_acl_reference"] = Processor.process_switcht_api_acl_reference
    self._processMap["switcht_api_acl_remove"] = Processor.process_switcht_api_acl_remove
    self._processMap["switcht_api_hostif_group_create"] = Processor.process_switcht_api_hostif_group_create
    self._processMap["switcht_api_hostif_group_delete"] = Processor.process_switcht_api_hostif_group_delete
    self._processMap["switcht_api_hostif_reason_code_create"] = Processor.process_switcht_api_hostif_reason_code_create
    self._processMap["switcht_api_hostif_reason_code_delete"] = Processor.process_switcht_api_hostif_reason_code_delete
    self._processMap["switcht_api_hostif_create"] = Processor.process_switcht_api_hostif_create
    self._processMap["switcht_api_hostif_delete"] = Processor.process_switcht_api_hostif_delete
    self._processMap["switcht_api_mirror_session_create"] = Processor.process_switcht_api_mirror_session_create
    self._processMap["switcht_api_mirror_session_update"] = Processor.process_switcht_api_mirror_session_update
    self._processMap["switcht_api_mirror_session_delete"] = Processor.process_switcht_api_mirror_session_delete
    self._processMap["switcht_int_transit_enable"] = Processor.process_switcht_int_transit_enable

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_switcht_api_init(self, seqid, iprot, oprot):
    args = switcht_api_init_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_init_result()
    result.success = self._handler.switcht_api_init(args.device)
    oprot.writeMessageBegin("switcht_api_init", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_drop_stats_get(self, seqid, iprot, oprot):
    args = switcht_api_drop_stats_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_drop_stats_get_result()
    result.success = self._handler.switcht_api_drop_stats_get(args.device)
    oprot.writeMessageBegin("switcht_api_drop_stats_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_port_set(self, seqid, iprot, oprot):
    args = switcht_api_port_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_port_set_result()
    result.success = self._handler.switcht_api_port_set(args.device, args.port_info)
    oprot.writeMessageBegin("switcht_api_port_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_port_print_all(self, seqid, iprot, oprot):
    args = switcht_api_port_print_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_port_print_all_result()
    result.success = self._handler.switcht_api_port_print_all()
    oprot.writeMessageBegin("switcht_api_port_print_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vrf_create(self, seqid, iprot, oprot):
    args = switcht_api_vrf_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vrf_create_result()
    result.success = self._handler.switcht_api_vrf_create(args.device, args.vrf)
    oprot.writeMessageBegin("switcht_api_vrf_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vrf_delete(self, seqid, iprot, oprot):
    args = switcht_api_vrf_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vrf_delete_result()
    result.success = self._handler.switcht_api_vrf_delete(args.device, args.vrf_handle)
    oprot.writeMessageBegin("switcht_api_vrf_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_router_mac_group_create(self, seqid, iprot, oprot):
    args = switcht_api_router_mac_group_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_router_mac_group_create_result()
    result.success = self._handler.switcht_api_router_mac_group_create(args.device)
    oprot.writeMessageBegin("switcht_api_router_mac_group_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_router_mac_group_delete(self, seqid, iprot, oprot):
    args = switcht_api_router_mac_group_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_router_mac_group_delete_result()
    result.success = self._handler.switcht_api_router_mac_group_delete(args.device, args.rmac_handle)
    oprot.writeMessageBegin("switcht_api_router_mac_group_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_router_mac_add(self, seqid, iprot, oprot):
    args = switcht_api_router_mac_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_router_mac_add_result()
    result.success = self._handler.switcht_api_router_mac_add(args.device, args.rmac_handle, args.mac)
    oprot.writeMessageBegin("switcht_api_router_mac_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_router_mac_delete(self, seqid, iprot, oprot):
    args = switcht_api_router_mac_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_router_mac_delete_result()
    result.success = self._handler.switcht_api_router_mac_delete(args.device, args.rmac_handle, args.mac)
    oprot.writeMessageBegin("switcht_api_router_mac_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_router_mac_group_print_all(self, seqid, iprot, oprot):
    args = switcht_api_router_mac_group_print_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_router_mac_group_print_all_result()
    result.success = self._handler.switcht_api_router_mac_group_print_all()
    oprot.writeMessageBegin("switcht_api_router_mac_group_print_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_interface_create(self, seqid, iprot, oprot):
    args = switcht_api_interface_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_interface_create_result()
    result.success = self._handler.switcht_api_interface_create(args.device, args.interface_info)
    oprot.writeMessageBegin("switcht_api_interface_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_interface_delete(self, seqid, iprot, oprot):
    args = switcht_api_interface_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_interface_delete_result()
    result.success = self._handler.switcht_api_interface_delete(args.device, args.interface_handle)
    oprot.writeMessageBegin("switcht_api_interface_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_interface_print_all(self, seqid, iprot, oprot):
    args = switcht_api_interface_print_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_interface_print_all_result()
    result.success = self._handler.switcht_api_interface_print_all()
    oprot.writeMessageBegin("switcht_api_interface_print_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_interface_attribute_set(self, seqid, iprot, oprot):
    args = switcht_api_interface_attribute_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_interface_attribute_set_result()
    result.success = self._handler.switcht_api_interface_attribute_set(args.interface_handle, args.attr_type, args.value)
    oprot.writeMessageBegin("switcht_api_interface_attribute_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_interface_ipv4_unicast_enabled_set(self, seqid, iprot, oprot):
    args = switcht_api_interface_ipv4_unicast_enabled_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_interface_ipv4_unicast_enabled_set_result()
    result.success = self._handler.switcht_api_interface_ipv4_unicast_enabled_set(args.intf_handle, args.value)
    oprot.writeMessageBegin("switcht_api_interface_ipv4_unicast_enabled_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_interface_ipv6_unicast_enabled_set(self, seqid, iprot, oprot):
    args = switcht_api_interface_ipv6_unicast_enabled_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_interface_ipv6_unicast_enabled_set_result()
    result.success = self._handler.switcht_api_interface_ipv6_unicast_enabled_set(args.intf_handle, args.value)
    oprot.writeMessageBegin("switcht_api_interface_ipv6_unicast_enabled_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_interface_ipv4_urpf_mode_set(self, seqid, iprot, oprot):
    args = switcht_api_interface_ipv4_urpf_mode_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_interface_ipv4_urpf_mode_set_result()
    result.success = self._handler.switcht_api_interface_ipv4_urpf_mode_set(args.intf_handle, args.value)
    oprot.writeMessageBegin("switcht_api_interface_ipv4_urpf_mode_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_interface_ipv6_urpf_mode_set(self, seqid, iprot, oprot):
    args = switcht_api_interface_ipv6_urpf_mode_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_interface_ipv6_urpf_mode_set_result()
    result.success = self._handler.switcht_api_interface_ipv6_urpf_mode_set(args.intf_handle, args.value)
    oprot.writeMessageBegin("switcht_api_interface_ipv6_urpf_mode_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_l3_interface_address_add(self, seqid, iprot, oprot):
    args = switcht_api_l3_interface_address_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_l3_interface_address_add_result()
    result.success = self._handler.switcht_api_l3_interface_address_add(args.device, args.interface_handle, args.vrf, args.ip_addr)
    oprot.writeMessageBegin("switcht_api_l3_interface_address_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_l3_interface_address_delete(self, seqid, iprot, oprot):
    args = switcht_api_l3_interface_address_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_l3_interface_address_delete_result()
    result.success = self._handler.switcht_api_l3_interface_address_delete(args.device, args.interface_handle, args.vrf, args.ip_addr)
    oprot.writeMessageBegin("switcht_api_l3_interface_address_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_nhop_create(self, seqid, iprot, oprot):
    args = switcht_api_nhop_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_nhop_create_result()
    result.success = self._handler.switcht_api_nhop_create(args.device, args.nhop_key)
    oprot.writeMessageBegin("switcht_api_nhop_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_nhop_delete(self, seqid, iprot, oprot):
    args = switcht_api_nhop_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_nhop_delete_result()
    result.success = self._handler.switcht_api_nhop_delete(args.device, args.handle)
    oprot.writeMessageBegin("switcht_api_nhop_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_nhop_print_all(self, seqid, iprot, oprot):
    args = switcht_api_nhop_print_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_nhop_print_all_result()
    result.success = self._handler.switcht_api_nhop_print_all()
    oprot.writeMessageBegin("switcht_api_nhop_print_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_neighbor_entry_add(self, seqid, iprot, oprot):
    args = switcht_api_neighbor_entry_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_neighbor_entry_add_result()
    result.success = self._handler.switcht_api_neighbor_entry_add(args.device, args.neighbor)
    oprot.writeMessageBegin("switcht_api_neighbor_entry_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_neighbor_entry_remove(self, seqid, iprot, oprot):
    args = switcht_api_neighbor_entry_remove_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_neighbor_entry_remove_result()
    result.success = self._handler.switcht_api_neighbor_entry_remove(args.device, args.neighbor_handle)
    oprot.writeMessageBegin("switcht_api_neighbor_entry_remove", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_neighbor_print_all(self, seqid, iprot, oprot):
    args = switcht_api_neighbor_print_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_neighbor_print_all_result()
    result.success = self._handler.switcht_api_neighbor_print_all()
    oprot.writeMessageBegin("switcht_api_neighbor_print_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_l3_route_add(self, seqid, iprot, oprot):
    args = switcht_api_l3_route_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_l3_route_add_result()
    result.success = self._handler.switcht_api_l3_route_add(args.device, args.vrf, args.ip_addr, args.nhop_handle)
    oprot.writeMessageBegin("switcht_api_l3_route_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_l3_route_delete(self, seqid, iprot, oprot):
    args = switcht_api_l3_route_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_l3_route_delete_result()
    result.success = self._handler.switcht_api_l3_route_delete(args.device, args.vrf, args.ip_addr, args.nhop_handle)
    oprot.writeMessageBegin("switcht_api_l3_route_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_l3_routes_print_all(self, seqid, iprot, oprot):
    args = switcht_api_l3_routes_print_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_l3_routes_print_all_result()
    result.success = self._handler.switcht_api_l3_routes_print_all()
    oprot.writeMessageBegin("switcht_api_l3_routes_print_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vlan_create(self, seqid, iprot, oprot):
    args = switcht_api_vlan_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vlan_create_result()
    result.success = self._handler.switcht_api_vlan_create(args.device, args.vlan_id)
    oprot.writeMessageBegin("switcht_api_vlan_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vlan_delete(self, seqid, iprot, oprot):
    args = switcht_api_vlan_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vlan_delete_result()
    result.success = self._handler.switcht_api_vlan_delete(args.device, args.vlan_handle)
    oprot.writeMessageBegin("switcht_api_vlan_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vlan_ports_add(self, seqid, iprot, oprot):
    args = switcht_api_vlan_ports_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vlan_ports_add_result()
    result.success = self._handler.switcht_api_vlan_ports_add(args.device, args.vlan_handle, args.port_vlan)
    oprot.writeMessageBegin("switcht_api_vlan_ports_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vlan_ports_remove(self, seqid, iprot, oprot):
    args = switcht_api_vlan_ports_remove_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vlan_ports_remove_result()
    result.success = self._handler.switcht_api_vlan_ports_remove(args.device, args.vlan_handle, args.port_vlan)
    oprot.writeMessageBegin("switcht_api_vlan_ports_remove", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vlan_print_all(self, seqid, iprot, oprot):
    args = switcht_api_vlan_print_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vlan_print_all_result()
    result.success = self._handler.switcht_api_vlan_print_all()
    oprot.writeMessageBegin("switcht_api_vlan_print_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vlan_learning_enabled_set(self, seqid, iprot, oprot):
    args = switcht_api_vlan_learning_enabled_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vlan_learning_enabled_set_result()
    result.success = self._handler.switcht_api_vlan_learning_enabled_set(args.vlan_handle, args.value)
    oprot.writeMessageBegin("switcht_api_vlan_learning_enabled_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vlan_learning_enabled_get(self, seqid, iprot, oprot):
    args = switcht_api_vlan_learning_enabled_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vlan_learning_enabled_get_result()
    result.success = self._handler.switcht_api_vlan_learning_enabled_get(args.vlan_handle, args.value)
    oprot.writeMessageBegin("switcht_api_vlan_learning_enabled_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vlan_aging_interval_set(self, seqid, iprot, oprot):
    args = switcht_api_vlan_aging_interval_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vlan_aging_interval_set_result()
    result.success = self._handler.switcht_api_vlan_aging_interval_set(args.vlan_handle, args.value)
    oprot.writeMessageBegin("switcht_api_vlan_aging_interval_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vlan_stats_enable(self, seqid, iprot, oprot):
    args = switcht_api_vlan_stats_enable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vlan_stats_enable_result()
    result.success = self._handler.switcht_api_vlan_stats_enable(args.device, args.vlan_handle)
    oprot.writeMessageBegin("switcht_api_vlan_stats_enable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vlan_stats_disable(self, seqid, iprot, oprot):
    args = switcht_api_vlan_stats_disable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vlan_stats_disable_result()
    result.success = self._handler.switcht_api_vlan_stats_disable(args.device, args.vlan_handle)
    oprot.writeMessageBegin("switcht_api_vlan_stats_disable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_vlan_stats_get(self, seqid, iprot, oprot):
    args = switcht_api_vlan_stats_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_vlan_stats_get_result()
    result.success = self._handler.switcht_api_vlan_stats_get(args.vlan_handle, args.counter_ids)
    oprot.writeMessageBegin("switcht_api_vlan_stats_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mac_table_entry_create(self, seqid, iprot, oprot):
    args = switcht_api_mac_table_entry_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mac_table_entry_create_result()
    result.success = self._handler.switcht_api_mac_table_entry_create(args.device, args.vlan_handle, args.mac, args.entry_type, args.handle)
    oprot.writeMessageBegin("switcht_api_mac_table_entry_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mac_table_entry_update(self, seqid, iprot, oprot):
    args = switcht_api_mac_table_entry_update_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mac_table_entry_update_result()
    result.success = self._handler.switcht_api_mac_table_entry_update(args.device, args.vlan_handle, args.mac, args.entry_type, args.handle)
    oprot.writeMessageBegin("switcht_api_mac_table_entry_update", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mac_table_entry_delete(self, seqid, iprot, oprot):
    args = switcht_api_mac_table_entry_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mac_table_entry_delete_result()
    result.success = self._handler.switcht_api_mac_table_entry_delete(args.device, args.vlan_handle, args.mac)
    oprot.writeMessageBegin("switcht_api_mac_table_entry_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mac_table_entries_delete_by_vlan(self, seqid, iprot, oprot):
    args = switcht_api_mac_table_entries_delete_by_vlan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mac_table_entries_delete_by_vlan_result()
    result.success = self._handler.switcht_api_mac_table_entries_delete_by_vlan(args.device, args.vlan_handle)
    oprot.writeMessageBegin("switcht_api_mac_table_entries_delete_by_vlan", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mac_table_entries_delete_by_interface(self, seqid, iprot, oprot):
    args = switcht_api_mac_table_entries_delete_by_interface_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mac_table_entries_delete_by_interface_result()
    result.success = self._handler.switcht_api_mac_table_entries_delete_by_interface(args.device, args.intf_handle)
    oprot.writeMessageBegin("switcht_api_mac_table_entries_delete_by_interface", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mac_table_entries_delete_all(self, seqid, iprot, oprot):
    args = switcht_api_mac_table_entries_delete_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mac_table_entries_delete_all_result()
    result.success = self._handler.switcht_api_mac_table_entries_delete_all(args.device)
    oprot.writeMessageBegin("switcht_api_mac_table_entries_delete_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mac_table_set_learning_timeout(self, seqid, iprot, oprot):
    args = switcht_api_mac_table_set_learning_timeout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mac_table_set_learning_timeout_result()
    result.success = self._handler.switcht_api_mac_table_set_learning_timeout(args.device, args.timeout)
    oprot.writeMessageBegin("switcht_api_mac_table_set_learning_timeout", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mac_table_aging_time_set(self, seqid, iprot, oprot):
    args = switcht_api_mac_table_aging_time_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mac_table_aging_time_set_result()
    result.success = self._handler.switcht_api_mac_table_aging_time_set(args.value)
    oprot.writeMessageBegin("switcht_api_mac_table_aging_time_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mac_table_print_all(self, seqid, iprot, oprot):
    args = switcht_api_mac_table_print_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mac_table_print_all_result()
    result.success = self._handler.switcht_api_mac_table_print_all()
    oprot.writeMessageBegin("switcht_api_mac_table_print_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_l3_ecmp_create(self, seqid, iprot, oprot):
    args = switcht_api_l3_ecmp_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_l3_ecmp_create_result()
    result.success = self._handler.switcht_api_l3_ecmp_create(args.device)
    oprot.writeMessageBegin("switcht_api_l3_ecmp_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_l3_ecmp_delete(self, seqid, iprot, oprot):
    args = switcht_api_l3_ecmp_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_l3_ecmp_delete_result()
    result.success = self._handler.switcht_api_l3_ecmp_delete(args.device, args.handle)
    oprot.writeMessageBegin("switcht_api_l3_ecmp_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_l3_ecmp_member_add(self, seqid, iprot, oprot):
    args = switcht_api_l3_ecmp_member_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_l3_ecmp_member_add_result()
    result.success = self._handler.switcht_api_l3_ecmp_member_add(args.device, args.handle, args.nhop_count, args.nhop_handle)
    oprot.writeMessageBegin("switcht_api_l3_ecmp_member_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_l3_ecmp_member_delete(self, seqid, iprot, oprot):
    args = switcht_api_l3_ecmp_member_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_l3_ecmp_member_delete_result()
    result.success = self._handler.switcht_api_l3_ecmp_member_delete(args.device, args.handle, args.nhop_count, args.nhop_handle)
    oprot.writeMessageBegin("switcht_api_l3_ecmp_member_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_lag_create(self, seqid, iprot, oprot):
    args = switcht_api_lag_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_lag_create_result()
    result.success = self._handler.switcht_api_lag_create(args.device)
    oprot.writeMessageBegin("switcht_api_lag_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_lag_delete(self, seqid, iprot, oprot):
    args = switcht_api_lag_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_lag_delete_result()
    result.success = self._handler.switcht_api_lag_delete(args.device, args.lag_handle)
    oprot.writeMessageBegin("switcht_api_lag_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_lag_member_add(self, seqid, iprot, oprot):
    args = switcht_api_lag_member_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_lag_member_add_result()
    result.success = self._handler.switcht_api_lag_member_add(args.device, args.lag_handle, args.side, args.port)
    oprot.writeMessageBegin("switcht_api_lag_member_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_lag_member_delete(self, seqid, iprot, oprot):
    args = switcht_api_lag_member_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_lag_member_delete_result()
    result.success = self._handler.switcht_api_lag_member_delete(args.device, args.lag_handle, args.side, args.port)
    oprot.writeMessageBegin("switcht_api_lag_member_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_lag_print_all(self, seqid, iprot, oprot):
    args = switcht_api_lag_print_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_lag_print_all_result()
    result.success = self._handler.switcht_api_lag_print_all()
    oprot.writeMessageBegin("switcht_api_lag_print_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_logical_network_create(self, seqid, iprot, oprot):
    args = switcht_api_logical_network_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_logical_network_create_result()
    result.success = self._handler.switcht_api_logical_network_create(args.device, args.info)
    oprot.writeMessageBegin("switcht_api_logical_network_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_logical_network_delete(self, seqid, iprot, oprot):
    args = switcht_api_logical_network_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_logical_network_delete_result()
    result.success = self._handler.switcht_api_logical_network_delete(args.device, args.network_handle)
    oprot.writeMessageBegin("switcht_api_logical_network_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_tunnel_interface_create(self, seqid, iprot, oprot):
    args = switcht_api_tunnel_interface_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_tunnel_interface_create_result()
    result.success = self._handler.switcht_api_tunnel_interface_create(args.device, args.direction, args.tun_info)
    oprot.writeMessageBegin("switcht_api_tunnel_interface_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_tunnel_interface_delete(self, seqid, iprot, oprot):
    args = switcht_api_tunnel_interface_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_tunnel_interface_delete_result()
    result.success = self._handler.switcht_api_tunnel_interface_delete(args.device, args.tun_handle)
    oprot.writeMessageBegin("switcht_api_tunnel_interface_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_logical_network_member_add(self, seqid, iprot, oprot):
    args = switcht_api_logical_network_member_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_logical_network_member_add_result()
    result.success = self._handler.switcht_api_logical_network_member_add(args.device, args.network_handle, args.interface_handle)
    oprot.writeMessageBegin("switcht_api_logical_network_member_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_logical_network_member_remove(self, seqid, iprot, oprot):
    args = switcht_api_logical_network_member_remove_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_logical_network_member_remove_result()
    result.success = self._handler.switcht_api_logical_network_member_remove(args.device, args.network_handle, args.interface_handle)
    oprot.writeMessageBegin("switcht_api_logical_network_member_remove", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mpls_tunnel_transit_create(self, seqid, iprot, oprot):
    args = switcht_api_mpls_tunnel_transit_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mpls_tunnel_transit_create_result()
    result.success = self._handler.switcht_api_mpls_tunnel_transit_create(args.device, args.mpls_encap)
    oprot.writeMessageBegin("switcht_api_mpls_tunnel_transit_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mpls_tunnel_transit_delete(self, seqid, iprot, oprot):
    args = switcht_api_mpls_tunnel_transit_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mpls_tunnel_transit_delete_result()
    result.success = self._handler.switcht_api_mpls_tunnel_transit_delete(args.device, args.mpls_encap)
    oprot.writeMessageBegin("switcht_api_mpls_tunnel_transit_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_stp_group_create(self, seqid, iprot, oprot):
    args = switcht_api_stp_group_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_stp_group_create_result()
    result.success = self._handler.switcht_api_stp_group_create(args.device, args.stp_mode)
    oprot.writeMessageBegin("switcht_api_stp_group_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_stp_group_delete(self, seqid, iprot, oprot):
    args = switcht_api_stp_group_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_stp_group_delete_result()
    result.success = self._handler.switcht_api_stp_group_delete(args.device, args.stp_handle)
    oprot.writeMessageBegin("switcht_api_stp_group_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_stp_group_vlans_add(self, seqid, iprot, oprot):
    args = switcht_api_stp_group_vlans_add_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_stp_group_vlans_add_result()
    result.success = self._handler.switcht_api_stp_group_vlans_add(args.device, args.stp_handle, args.vlan_count, args.vlan_handle)
    oprot.writeMessageBegin("switcht_api_stp_group_vlans_add", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_stp_group_vlans_remove(self, seqid, iprot, oprot):
    args = switcht_api_stp_group_vlans_remove_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_stp_group_vlans_remove_result()
    result.success = self._handler.switcht_api_stp_group_vlans_remove(args.device, args.stp_handle, args.vlan_count, args.vlan_handle)
    oprot.writeMessageBegin("switcht_api_stp_group_vlans_remove", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_stp_port_state_set(self, seqid, iprot, oprot):
    args = switcht_api_stp_port_state_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_stp_port_state_set_result()
    result.success = self._handler.switcht_api_stp_port_state_set(args.device, args.stp_handle, args.intf_handle, args.stp_state)
    oprot.writeMessageBegin("switcht_api_stp_port_state_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_stp_port_state_clear(self, seqid, iprot, oprot):
    args = switcht_api_stp_port_state_clear_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_stp_port_state_clear_result()
    result.success = self._handler.switcht_api_stp_port_state_clear(args.device, args.stp_handle, args.intf_handle)
    oprot.writeMessageBegin("switcht_api_stp_port_state_clear", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_stp_group_print_all(self, seqid, iprot, oprot):
    args = switcht_api_stp_group_print_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_stp_group_print_all_result()
    result.success = self._handler.switcht_api_stp_group_print_all()
    oprot.writeMessageBegin("switcht_api_stp_group_print_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_acl_list_create(self, seqid, iprot, oprot):
    args = switcht_api_acl_list_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_acl_list_create_result()
    result.success = self._handler.switcht_api_acl_list_create(args.device, args.type)
    oprot.writeMessageBegin("switcht_api_acl_list_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_acl_list_delete(self, seqid, iprot, oprot):
    args = switcht_api_acl_list_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_acl_list_delete_result()
    result.success = self._handler.switcht_api_acl_list_delete(args.device, args.handle)
    oprot.writeMessageBegin("switcht_api_acl_list_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_acl_ip_rule_create(self, seqid, iprot, oprot):
    args = switcht_api_acl_ip_rule_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_acl_ip_rule_create_result()
    result.success = self._handler.switcht_api_acl_ip_rule_create(args.device, args.acl_handle, args.priority, args.key_value_count, args.acl_kvp, args.action, args.action_params)
    oprot.writeMessageBegin("switcht_api_acl_ip_rule_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_acl_mirror_rule_create(self, seqid, iprot, oprot):
    args = switcht_api_acl_mirror_rule_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_acl_mirror_rule_create_result()
    result.success = self._handler.switcht_api_acl_mirror_rule_create(args.device, args.acl_handle, args.priority, args.key_value_count, args.acl_kvp, args.action, args.action_params)
    oprot.writeMessageBegin("switcht_api_acl_mirror_rule_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_acl_system_rule_create(self, seqid, iprot, oprot):
    args = switcht_api_acl_system_rule_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_acl_system_rule_create_result()
    result.success = self._handler.switcht_api_acl_system_rule_create(args.device, args.acl_handle, args.priority, args.key_value_count, args.acl_kvp, args.action, args.action_params)
    oprot.writeMessageBegin("switcht_api_acl_system_rule_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_acl_egr_rule_create(self, seqid, iprot, oprot):
    args = switcht_api_acl_egr_rule_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_acl_egr_rule_create_result()
    result.success = self._handler.switcht_api_acl_egr_rule_create(args.device, args.acl_handle, args.priority, args.key_value_count, args.acl_kvp, args.action, args.action_params)
    oprot.writeMessageBegin("switcht_api_acl_egr_rule_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_acl_rule_delete(self, seqid, iprot, oprot):
    args = switcht_api_acl_rule_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_acl_rule_delete_result()
    result.success = self._handler.switcht_api_acl_rule_delete(args.device, args.acl_handle, args.handle)
    oprot.writeMessageBegin("switcht_api_acl_rule_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_acl_reference(self, seqid, iprot, oprot):
    args = switcht_api_acl_reference_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_acl_reference_result()
    result.success = self._handler.switcht_api_acl_reference(args.device, args.acl_handle, args.interface_handle)
    oprot.writeMessageBegin("switcht_api_acl_reference", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_acl_remove(self, seqid, iprot, oprot):
    args = switcht_api_acl_remove_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_acl_remove_result()
    result.success = self._handler.switcht_api_acl_remove(args.device, args.acl_handle, args.interface_handle)
    oprot.writeMessageBegin("switcht_api_acl_remove", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_hostif_group_create(self, seqid, iprot, oprot):
    args = switcht_api_hostif_group_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_hostif_group_create_result()
    result.success = self._handler.switcht_api_hostif_group_create(args.device, args.hostif_group)
    oprot.writeMessageBegin("switcht_api_hostif_group_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_hostif_group_delete(self, seqid, iprot, oprot):
    args = switcht_api_hostif_group_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_hostif_group_delete_result()
    result.success = self._handler.switcht_api_hostif_group_delete(args.device, args.hostif_group_handle)
    oprot.writeMessageBegin("switcht_api_hostif_group_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_hostif_reason_code_create(self, seqid, iprot, oprot):
    args = switcht_api_hostif_reason_code_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_hostif_reason_code_create_result()
    result.success = self._handler.switcht_api_hostif_reason_code_create(args.device, args.rcode_api_info)
    oprot.writeMessageBegin("switcht_api_hostif_reason_code_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_hostif_reason_code_delete(self, seqid, iprot, oprot):
    args = switcht_api_hostif_reason_code_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_hostif_reason_code_delete_result()
    result.success = self._handler.switcht_api_hostif_reason_code_delete(args.device, args.reason_code)
    oprot.writeMessageBegin("switcht_api_hostif_reason_code_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_hostif_create(self, seqid, iprot, oprot):
    args = switcht_api_hostif_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_hostif_create_result()
    result.success = self._handler.switcht_api_hostif_create(args.device, args.hostif)
    oprot.writeMessageBegin("switcht_api_hostif_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_hostif_delete(self, seqid, iprot, oprot):
    args = switcht_api_hostif_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_hostif_delete_result()
    result.success = self._handler.switcht_api_hostif_delete(args.device, args.hostif_handle)
    oprot.writeMessageBegin("switcht_api_hostif_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mirror_session_create(self, seqid, iprot, oprot):
    args = switcht_api_mirror_session_create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mirror_session_create_result()
    result.success = self._handler.switcht_api_mirror_session_create(args.device, args.api_mirror_info)
    oprot.writeMessageBegin("switcht_api_mirror_session_create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mirror_session_update(self, seqid, iprot, oprot):
    args = switcht_api_mirror_session_update_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mirror_session_update_result()
    result.success = self._handler.switcht_api_mirror_session_update(args.device, args.mirror_handle, args.api_mirror_info)
    oprot.writeMessageBegin("switcht_api_mirror_session_update", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_api_mirror_session_delete(self, seqid, iprot, oprot):
    args = switcht_api_mirror_session_delete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_api_mirror_session_delete_result()
    result.success = self._handler.switcht_api_mirror_session_delete(args.device, args.mirror_handle)
    oprot.writeMessageBegin("switcht_api_mirror_session_delete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_switcht_int_transit_enable(self, seqid, iprot, oprot):
    args = switcht_int_transit_enable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = switcht_int_transit_enable_result()
    result.success = self._handler.switcht_int_transit_enable(args.device, args.switch_id, args.enable)
    oprot.writeMessageBegin("switcht_int_transit_enable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class switcht_api_init_args:
  """
  Attributes:
   - device
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
  )

  def __init__(self, device=None,):
    self.device = device

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_init_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_init_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_init_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_drop_stats_get_args:
  """
  Attributes:
   - device
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
  )

  def __init__(self, device=None,):
    self.device = device

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_drop_stats_get_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_drop_stats_get_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I64,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readI64()
            self.success.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_drop_stats_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I64, len(self.success))
      for iter27 in self.success:
        oprot.writeI64(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_port_set_args:
  """
  Attributes:
   - device
   - port_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.STRUCT, 'port_info', (switcht_port_info_t, switcht_port_info_t.thrift_spec), None, ), # 2
  )

  def __init__(self, device=None, port_info=None,):
    self.device = device
    self.port_info = port_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.port_info = switcht_port_info_t()
          self.port_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_port_set_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.port_info is not None:
      oprot.writeFieldBegin('port_info', TType.STRUCT, 2)
      self.port_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.port_info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_port_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_port_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_port_print_all_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_port_print_all_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_port_print_all_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_port_print_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vrf_create_args:
  """
  Attributes:
   - device
   - vrf
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vrf', None, None, ), # 2
  )

  def __init__(self, device=None, vrf=None,):
    self.device = device
    self.vrf = vrf

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vrf = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vrf_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vrf is not None:
      oprot.writeFieldBegin('vrf', TType.I32, 2)
      oprot.writeI32(self.vrf)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vrf)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vrf_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vrf_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vrf_delete_args:
  """
  Attributes:
   - device
   - vrf_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vrf_handle', None, None, ), # 2
  )

  def __init__(self, device=None, vrf_handle=None,):
    self.device = device
    self.vrf_handle = vrf_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vrf_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vrf_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vrf_handle is not None:
      oprot.writeFieldBegin('vrf_handle', TType.I32, 2)
      oprot.writeI32(self.vrf_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vrf_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vrf_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vrf_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_router_mac_group_create_args:
  """
  Attributes:
   - device
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
  )

  def __init__(self, device=None,):
    self.device = device

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_router_mac_group_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_router_mac_group_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_router_mac_group_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_router_mac_group_delete_args:
  """
  Attributes:
   - device
   - rmac_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'rmac_handle', None, None, ), # 2
  )

  def __init__(self, device=None, rmac_handle=None,):
    self.device = device
    self.rmac_handle = rmac_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.rmac_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_router_mac_group_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.rmac_handle is not None:
      oprot.writeFieldBegin('rmac_handle', TType.I32, 2)
      oprot.writeI32(self.rmac_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.rmac_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_router_mac_group_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_router_mac_group_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_router_mac_add_args:
  """
  Attributes:
   - device
   - rmac_handle
   - mac
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'rmac_handle', None, None, ), # 2
    (3, TType.STRING, 'mac', None, None, ), # 3
  )

  def __init__(self, device=None, rmac_handle=None, mac=None,):
    self.device = device
    self.rmac_handle = rmac_handle
    self.mac = mac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.rmac_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_router_mac_add_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.rmac_handle is not None:
      oprot.writeFieldBegin('rmac_handle', TType.I32, 2)
      oprot.writeI32(self.rmac_handle)
      oprot.writeFieldEnd()
    if self.mac is not None:
      oprot.writeFieldBegin('mac', TType.STRING, 3)
      oprot.writeString(self.mac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.rmac_handle)
    value = (value * 31) ^ hash(self.mac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_router_mac_add_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_router_mac_add_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_router_mac_delete_args:
  """
  Attributes:
   - device
   - rmac_handle
   - mac
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'rmac_handle', None, None, ), # 2
    (3, TType.STRING, 'mac', None, None, ), # 3
  )

  def __init__(self, device=None, rmac_handle=None, mac=None,):
    self.device = device
    self.rmac_handle = rmac_handle
    self.mac = mac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.rmac_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_router_mac_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.rmac_handle is not None:
      oprot.writeFieldBegin('rmac_handle', TType.I32, 2)
      oprot.writeI32(self.rmac_handle)
      oprot.writeFieldEnd()
    if self.mac is not None:
      oprot.writeFieldBegin('mac', TType.STRING, 3)
      oprot.writeString(self.mac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.rmac_handle)
    value = (value * 31) ^ hash(self.mac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_router_mac_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_router_mac_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_router_mac_group_print_all_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_router_mac_group_print_all_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_router_mac_group_print_all_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_router_mac_group_print_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_create_args:
  """
  Attributes:
   - device
   - interface_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.STRUCT, 'interface_info', (switcht_interface_info_t, switcht_interface_info_t.thrift_spec), None, ), # 2
  )

  def __init__(self, device=None, interface_info=None,):
    self.device = device
    self.interface_info = interface_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.interface_info = switcht_interface_info_t()
          self.interface_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.interface_info is not None:
      oprot.writeFieldBegin('interface_info', TType.STRUCT, 2)
      self.interface_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.interface_info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_delete_args:
  """
  Attributes:
   - device
   - interface_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'interface_handle', None, None, ), # 2
  )

  def __init__(self, device=None, interface_handle=None,):
    self.device = device
    self.interface_handle = interface_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.interface_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.interface_handle is not None:
      oprot.writeFieldBegin('interface_handle', TType.I32, 2)
      oprot.writeI32(self.interface_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.interface_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_print_all_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_print_all_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_print_all_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_print_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_attribute_set_args:
  """
  Attributes:
   - interface_handle
   - attr_type
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'interface_handle', None, None, ), # 1
    (2, TType.I32, 'attr_type', None, None, ), # 2
    (3, TType.I64, 'value', None, None, ), # 3
  )

  def __init__(self, interface_handle=None, attr_type=None, value=None,):
    self.interface_handle = interface_handle
    self.attr_type = attr_type
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.interface_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.attr_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_attribute_set_args')
    if self.interface_handle is not None:
      oprot.writeFieldBegin('interface_handle', TType.I32, 1)
      oprot.writeI32(self.interface_handle)
      oprot.writeFieldEnd()
    if self.attr_type is not None:
      oprot.writeFieldBegin('attr_type', TType.I32, 2)
      oprot.writeI32(self.attr_type)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 3)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.interface_handle)
    value = (value * 31) ^ hash(self.attr_type)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_attribute_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_attribute_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_ipv4_unicast_enabled_set_args:
  """
  Attributes:
   - intf_handle
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'intf_handle', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
  )

  def __init__(self, intf_handle=None, value=None,):
    self.intf_handle = intf_handle
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.intf_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_ipv4_unicast_enabled_set_args')
    if self.intf_handle is not None:
      oprot.writeFieldBegin('intf_handle', TType.I32, 1)
      oprot.writeI32(self.intf_handle)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.intf_handle)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_ipv4_unicast_enabled_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_ipv4_unicast_enabled_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_ipv6_unicast_enabled_set_args:
  """
  Attributes:
   - intf_handle
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'intf_handle', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
  )

  def __init__(self, intf_handle=None, value=None,):
    self.intf_handle = intf_handle
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.intf_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_ipv6_unicast_enabled_set_args')
    if self.intf_handle is not None:
      oprot.writeFieldBegin('intf_handle', TType.I32, 1)
      oprot.writeI32(self.intf_handle)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.intf_handle)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_ipv6_unicast_enabled_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_ipv6_unicast_enabled_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_ipv4_urpf_mode_set_args:
  """
  Attributes:
   - intf_handle
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'intf_handle', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
  )

  def __init__(self, intf_handle=None, value=None,):
    self.intf_handle = intf_handle
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.intf_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_ipv4_urpf_mode_set_args')
    if self.intf_handle is not None:
      oprot.writeFieldBegin('intf_handle', TType.I32, 1)
      oprot.writeI32(self.intf_handle)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.intf_handle)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_ipv4_urpf_mode_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_ipv4_urpf_mode_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_ipv6_urpf_mode_set_args:
  """
  Attributes:
   - intf_handle
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'intf_handle', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
  )

  def __init__(self, intf_handle=None, value=None,):
    self.intf_handle = intf_handle
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.intf_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_ipv6_urpf_mode_set_args')
    if self.intf_handle is not None:
      oprot.writeFieldBegin('intf_handle', TType.I32, 1)
      oprot.writeI32(self.intf_handle)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.intf_handle)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_interface_ipv6_urpf_mode_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_interface_ipv6_urpf_mode_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_interface_address_add_args:
  """
  Attributes:
   - device
   - interface_handle
   - vrf
   - ip_addr
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'interface_handle', None, None, ), # 2
    (3, TType.I32, 'vrf', None, None, ), # 3
    (4, TType.STRUCT, 'ip_addr', (switcht_ip_addr_t, switcht_ip_addr_t.thrift_spec), None, ), # 4
  )

  def __init__(self, device=None, interface_handle=None, vrf=None, ip_addr=None,):
    self.device = device
    self.interface_handle = interface_handle
    self.vrf = vrf
    self.ip_addr = ip_addr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.interface_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.vrf = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ip_addr = switcht_ip_addr_t()
          self.ip_addr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_interface_address_add_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.interface_handle is not None:
      oprot.writeFieldBegin('interface_handle', TType.I32, 2)
      oprot.writeI32(self.interface_handle)
      oprot.writeFieldEnd()
    if self.vrf is not None:
      oprot.writeFieldBegin('vrf', TType.I32, 3)
      oprot.writeI32(self.vrf)
      oprot.writeFieldEnd()
    if self.ip_addr is not None:
      oprot.writeFieldBegin('ip_addr', TType.STRUCT, 4)
      self.ip_addr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.interface_handle)
    value = (value * 31) ^ hash(self.vrf)
    value = (value * 31) ^ hash(self.ip_addr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_interface_address_add_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_interface_address_add_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_interface_address_delete_args:
  """
  Attributes:
   - device
   - interface_handle
   - vrf
   - ip_addr
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'interface_handle', None, None, ), # 2
    (3, TType.I32, 'vrf', None, None, ), # 3
    (4, TType.STRUCT, 'ip_addr', (switcht_ip_addr_t, switcht_ip_addr_t.thrift_spec), None, ), # 4
  )

  def __init__(self, device=None, interface_handle=None, vrf=None, ip_addr=None,):
    self.device = device
    self.interface_handle = interface_handle
    self.vrf = vrf
    self.ip_addr = ip_addr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.interface_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.vrf = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ip_addr = switcht_ip_addr_t()
          self.ip_addr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_interface_address_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.interface_handle is not None:
      oprot.writeFieldBegin('interface_handle', TType.I32, 2)
      oprot.writeI32(self.interface_handle)
      oprot.writeFieldEnd()
    if self.vrf is not None:
      oprot.writeFieldBegin('vrf', TType.I32, 3)
      oprot.writeI32(self.vrf)
      oprot.writeFieldEnd()
    if self.ip_addr is not None:
      oprot.writeFieldBegin('ip_addr', TType.STRUCT, 4)
      self.ip_addr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.interface_handle)
    value = (value * 31) ^ hash(self.vrf)
    value = (value * 31) ^ hash(self.ip_addr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_interface_address_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_interface_address_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_nhop_create_args:
  """
  Attributes:
   - device
   - nhop_key
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.STRUCT, 'nhop_key', (switcht_nhop_key_t, switcht_nhop_key_t.thrift_spec), None, ), # 2
  )

  def __init__(self, device=None, nhop_key=None,):
    self.device = device
    self.nhop_key = nhop_key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nhop_key = switcht_nhop_key_t()
          self.nhop_key.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_nhop_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.nhop_key is not None:
      oprot.writeFieldBegin('nhop_key', TType.STRUCT, 2)
      self.nhop_key.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.nhop_key)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_nhop_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_nhop_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_nhop_delete_args:
  """
  Attributes:
   - device
   - handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'handle', None, None, ), # 2
  )

  def __init__(self, device=None, handle=None,):
    self.device = device
    self.handle = handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_nhop_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 2)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_nhop_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_nhop_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_nhop_print_all_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_nhop_print_all_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_nhop_print_all_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_nhop_print_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_neighbor_entry_add_args:
  """
  Attributes:
   - device
   - neighbor
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.STRUCT, 'neighbor', (switcht_neighbor_info_t, switcht_neighbor_info_t.thrift_spec), None, ), # 2
  )

  def __init__(self, device=None, neighbor=None,):
    self.device = device
    self.neighbor = neighbor

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.neighbor = switcht_neighbor_info_t()
          self.neighbor.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_neighbor_entry_add_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.neighbor is not None:
      oprot.writeFieldBegin('neighbor', TType.STRUCT, 2)
      self.neighbor.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.neighbor)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_neighbor_entry_add_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_neighbor_entry_add_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_neighbor_entry_remove_args:
  """
  Attributes:
   - device
   - neighbor_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'neighbor_handle', None, None, ), # 2
  )

  def __init__(self, device=None, neighbor_handle=None,):
    self.device = device
    self.neighbor_handle = neighbor_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.neighbor_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_neighbor_entry_remove_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.neighbor_handle is not None:
      oprot.writeFieldBegin('neighbor_handle', TType.I32, 2)
      oprot.writeI32(self.neighbor_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.neighbor_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_neighbor_entry_remove_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_neighbor_entry_remove_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_neighbor_print_all_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_neighbor_print_all_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_neighbor_print_all_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_neighbor_print_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_route_add_args:
  """
  Attributes:
   - device
   - vrf
   - ip_addr
   - nhop_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vrf', None, None, ), # 2
    (3, TType.STRUCT, 'ip_addr', (switcht_ip_addr_t, switcht_ip_addr_t.thrift_spec), None, ), # 3
    (4, TType.I32, 'nhop_handle', None, None, ), # 4
  )

  def __init__(self, device=None, vrf=None, ip_addr=None, nhop_handle=None,):
    self.device = device
    self.vrf = vrf
    self.ip_addr = ip_addr
    self.nhop_handle = nhop_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vrf = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ip_addr = switcht_ip_addr_t()
          self.ip_addr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.nhop_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_route_add_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vrf is not None:
      oprot.writeFieldBegin('vrf', TType.I32, 2)
      oprot.writeI32(self.vrf)
      oprot.writeFieldEnd()
    if self.ip_addr is not None:
      oprot.writeFieldBegin('ip_addr', TType.STRUCT, 3)
      self.ip_addr.write(oprot)
      oprot.writeFieldEnd()
    if self.nhop_handle is not None:
      oprot.writeFieldBegin('nhop_handle', TType.I32, 4)
      oprot.writeI32(self.nhop_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vrf)
    value = (value * 31) ^ hash(self.ip_addr)
    value = (value * 31) ^ hash(self.nhop_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_route_add_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_route_add_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_route_delete_args:
  """
  Attributes:
   - device
   - vrf
   - ip_addr
   - nhop_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vrf', None, None, ), # 2
    (3, TType.STRUCT, 'ip_addr', (switcht_ip_addr_t, switcht_ip_addr_t.thrift_spec), None, ), # 3
    (4, TType.I32, 'nhop_handle', None, None, ), # 4
  )

  def __init__(self, device=None, vrf=None, ip_addr=None, nhop_handle=None,):
    self.device = device
    self.vrf = vrf
    self.ip_addr = ip_addr
    self.nhop_handle = nhop_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vrf = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ip_addr = switcht_ip_addr_t()
          self.ip_addr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.nhop_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_route_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vrf is not None:
      oprot.writeFieldBegin('vrf', TType.I32, 2)
      oprot.writeI32(self.vrf)
      oprot.writeFieldEnd()
    if self.ip_addr is not None:
      oprot.writeFieldBegin('ip_addr', TType.STRUCT, 3)
      self.ip_addr.write(oprot)
      oprot.writeFieldEnd()
    if self.nhop_handle is not None:
      oprot.writeFieldBegin('nhop_handle', TType.I32, 4)
      oprot.writeI32(self.nhop_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vrf)
    value = (value * 31) ^ hash(self.ip_addr)
    value = (value * 31) ^ hash(self.nhop_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_route_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_route_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_routes_print_all_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_routes_print_all_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_routes_print_all_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_routes_print_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_create_args:
  """
  Attributes:
   - device
   - vlan_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I16, 'vlan_id', None, None, ), # 2
  )

  def __init__(self, device=None, vlan_id=None,):
    self.device = device
    self.vlan_id = vlan_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.vlan_id = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vlan_id is not None:
      oprot.writeFieldBegin('vlan_id', TType.I16, 2)
      oprot.writeI16(self.vlan_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vlan_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_delete_args:
  """
  Attributes:
   - device
   - vlan_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vlan_handle', None, None, ), # 2
  )

  def __init__(self, device=None, vlan_handle=None,):
    self.device = device
    self.vlan_handle = vlan_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 2)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vlan_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_ports_add_args:
  """
  Attributes:
   - device
   - vlan_handle
   - port_vlan
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vlan_handle', None, None, ), # 2
    (3, TType.STRUCT, 'port_vlan', (switcht_vlan_port_t, switcht_vlan_port_t.thrift_spec), None, ), # 3
  )

  def __init__(self, device=None, vlan_handle=None, port_vlan=None,):
    self.device = device
    self.vlan_handle = vlan_handle
    self.port_vlan = port_vlan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.port_vlan = switcht_vlan_port_t()
          self.port_vlan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_ports_add_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 2)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    if self.port_vlan is not None:
      oprot.writeFieldBegin('port_vlan', TType.STRUCT, 3)
      self.port_vlan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vlan_handle)
    value = (value * 31) ^ hash(self.port_vlan)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_ports_add_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_ports_add_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_ports_remove_args:
  """
  Attributes:
   - device
   - vlan_handle
   - port_vlan
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vlan_handle', None, None, ), # 2
    (3, TType.STRUCT, 'port_vlan', (switcht_vlan_port_t, switcht_vlan_port_t.thrift_spec), None, ), # 3
  )

  def __init__(self, device=None, vlan_handle=None, port_vlan=None,):
    self.device = device
    self.vlan_handle = vlan_handle
    self.port_vlan = port_vlan

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.port_vlan = switcht_vlan_port_t()
          self.port_vlan.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_ports_remove_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 2)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    if self.port_vlan is not None:
      oprot.writeFieldBegin('port_vlan', TType.STRUCT, 3)
      self.port_vlan.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vlan_handle)
    value = (value * 31) ^ hash(self.port_vlan)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_ports_remove_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_ports_remove_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_print_all_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_print_all_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_print_all_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_print_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_learning_enabled_set_args:
  """
  Attributes:
   - vlan_handle
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'vlan_handle', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
  )

  def __init__(self, vlan_handle=None, value=None,):
    self.vlan_handle = vlan_handle
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_learning_enabled_set_args')
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 1)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vlan_handle)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_learning_enabled_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_learning_enabled_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_learning_enabled_get_args:
  """
  Attributes:
   - vlan_handle
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'vlan_handle', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
  )

  def __init__(self, vlan_handle=None, value=None,):
    self.vlan_handle = vlan_handle
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_learning_enabled_get_args')
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 1)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vlan_handle)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_learning_enabled_get_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_learning_enabled_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_aging_interval_set_args:
  """
  Attributes:
   - vlan_handle
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'vlan_handle', None, None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
  )

  def __init__(self, vlan_handle=None, value=None,):
    self.vlan_handle = vlan_handle
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_aging_interval_set_args')
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 1)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vlan_handle)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_aging_interval_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_aging_interval_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_stats_enable_args:
  """
  Attributes:
   - device
   - vlan_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vlan_handle', None, None, ), # 2
  )

  def __init__(self, device=None, vlan_handle=None,):
    self.device = device
    self.vlan_handle = vlan_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_stats_enable_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 2)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vlan_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_stats_enable_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_stats_enable_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_stats_disable_args:
  """
  Attributes:
   - device
   - vlan_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vlan_handle', None, None, ), # 2
  )

  def __init__(self, device=None, vlan_handle=None,):
    self.device = device
    self.vlan_handle = vlan_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_stats_disable_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 2)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vlan_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_stats_disable_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_stats_disable_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_stats_get_args:
  """
  Attributes:
   - vlan_handle
   - counter_ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'vlan_handle', None, None, ), # 1
    (2, TType.LIST, 'counter_ids', (TType.I16,None), None, ), # 2
  )

  def __init__(self, vlan_handle=None, counter_ids=None,):
    self.vlan_handle = vlan_handle
    self.counter_ids = counter_ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.counter_ids = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readI16()
            self.counter_ids.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_stats_get_args')
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 1)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    if self.counter_ids is not None:
      oprot.writeFieldBegin('counter_ids', TType.LIST, 2)
      oprot.writeListBegin(TType.I16, len(self.counter_ids))
      for iter34 in self.counter_ids:
        oprot.writeI16(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vlan_handle)
    value = (value * 31) ^ hash(self.counter_ids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_vlan_stats_get_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(switcht_counter_t, switcht_counter_t.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = switcht_counter_t()
            _elem40.read(iprot)
            self.success.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_vlan_stats_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter41 in self.success:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entry_create_args:
  """
  Attributes:
   - device
   - vlan_handle
   - mac
   - entry_type
   - handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vlan_handle', None, None, ), # 2
    (3, TType.STRING, 'mac', None, None, ), # 3
    (4, TType.BYTE, 'entry_type', None, None, ), # 4
    (5, TType.I32, 'handle', None, None, ), # 5
  )

  def __init__(self, device=None, vlan_handle=None, mac=None, entry_type=None, handle=None,):
    self.device = device
    self.vlan_handle = vlan_handle
    self.mac = mac
    self.entry_type = entry_type
    self.handle = handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mac = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.entry_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entry_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 2)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    if self.mac is not None:
      oprot.writeFieldBegin('mac', TType.STRING, 3)
      oprot.writeString(self.mac)
      oprot.writeFieldEnd()
    if self.entry_type is not None:
      oprot.writeFieldBegin('entry_type', TType.BYTE, 4)
      oprot.writeByte(self.entry_type)
      oprot.writeFieldEnd()
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 5)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vlan_handle)
    value = (value * 31) ^ hash(self.mac)
    value = (value * 31) ^ hash(self.entry_type)
    value = (value * 31) ^ hash(self.handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entry_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entry_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entry_update_args:
  """
  Attributes:
   - device
   - vlan_handle
   - mac
   - entry_type
   - handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vlan_handle', None, None, ), # 2
    (3, TType.STRING, 'mac', None, None, ), # 3
    (4, TType.BYTE, 'entry_type', None, None, ), # 4
    (5, TType.I32, 'handle', None, None, ), # 5
  )

  def __init__(self, device=None, vlan_handle=None, mac=None, entry_type=None, handle=None,):
    self.device = device
    self.vlan_handle = vlan_handle
    self.mac = mac
    self.entry_type = entry_type
    self.handle = handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mac = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.entry_type = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entry_update_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 2)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    if self.mac is not None:
      oprot.writeFieldBegin('mac', TType.STRING, 3)
      oprot.writeString(self.mac)
      oprot.writeFieldEnd()
    if self.entry_type is not None:
      oprot.writeFieldBegin('entry_type', TType.BYTE, 4)
      oprot.writeByte(self.entry_type)
      oprot.writeFieldEnd()
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 5)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vlan_handle)
    value = (value * 31) ^ hash(self.mac)
    value = (value * 31) ^ hash(self.entry_type)
    value = (value * 31) ^ hash(self.handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entry_update_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entry_update_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entry_delete_args:
  """
  Attributes:
   - device
   - vlan_handle
   - mac
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vlan_handle', None, None, ), # 2
    (3, TType.STRING, 'mac', None, None, ), # 3
  )

  def __init__(self, device=None, vlan_handle=None, mac=None,):
    self.device = device
    self.vlan_handle = vlan_handle
    self.mac = mac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entry_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 2)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    if self.mac is not None:
      oprot.writeFieldBegin('mac', TType.STRING, 3)
      oprot.writeString(self.mac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vlan_handle)
    value = (value * 31) ^ hash(self.mac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entry_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entry_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entries_delete_by_vlan_args:
  """
  Attributes:
   - device
   - vlan_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'vlan_handle', None, None, ), # 2
  )

  def __init__(self, device=None, vlan_handle=None,):
    self.device = device
    self.vlan_handle = vlan_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vlan_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entries_delete_by_vlan_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.I32, 2)
      oprot.writeI32(self.vlan_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.vlan_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entries_delete_by_vlan_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entries_delete_by_vlan_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entries_delete_by_interface_args:
  """
  Attributes:
   - device
   - intf_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'intf_handle', None, None, ), # 2
  )

  def __init__(self, device=None, intf_handle=None,):
    self.device = device
    self.intf_handle = intf_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.intf_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entries_delete_by_interface_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.intf_handle is not None:
      oprot.writeFieldBegin('intf_handle', TType.I32, 2)
      oprot.writeI32(self.intf_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.intf_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entries_delete_by_interface_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entries_delete_by_interface_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entries_delete_all_args:
  """
  Attributes:
   - device
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
  )

  def __init__(self, device=None,):
    self.device = device

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entries_delete_all_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_entries_delete_all_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_entries_delete_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_set_learning_timeout_args:
  """
  Attributes:
   - device
   - timeout
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'timeout', None, None, ), # 2
  )

  def __init__(self, device=None, timeout=None,):
    self.device = device
    self.timeout = timeout

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_set_learning_timeout_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.timeout is not None:
      oprot.writeFieldBegin('timeout', TType.I32, 2)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.timeout)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_set_learning_timeout_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_set_learning_timeout_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_aging_time_set_args:
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.value = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_aging_time_set_args')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 1)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_aging_time_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_aging_time_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_print_all_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_print_all_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mac_table_print_all_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mac_table_print_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_ecmp_create_args:
  """
  Attributes:
   - device
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
  )

  def __init__(self, device=None,):
    self.device = device

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_ecmp_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_ecmp_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_ecmp_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_ecmp_delete_args:
  """
  Attributes:
   - device
   - handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'handle', None, None, ), # 2
  )

  def __init__(self, device=None, handle=None,):
    self.device = device
    self.handle = handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_ecmp_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 2)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_ecmp_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_ecmp_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_ecmp_member_add_args:
  """
  Attributes:
   - device
   - handle
   - nhop_count
   - nhop_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'handle', None, None, ), # 2
    (3, TType.I16, 'nhop_count', None, None, ), # 3
    (4, TType.LIST, 'nhop_handle', (TType.I32,None), None, ), # 4
  )

  def __init__(self, device=None, handle=None, nhop_count=None, nhop_handle=None,):
    self.device = device
    self.handle = handle
    self.nhop_count = nhop_count
    self.nhop_handle = nhop_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.nhop_count = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.nhop_handle = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readI32()
            self.nhop_handle.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_ecmp_member_add_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 2)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.nhop_count is not None:
      oprot.writeFieldBegin('nhop_count', TType.I16, 3)
      oprot.writeI16(self.nhop_count)
      oprot.writeFieldEnd()
    if self.nhop_handle is not None:
      oprot.writeFieldBegin('nhop_handle', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.nhop_handle))
      for iter48 in self.nhop_handle:
        oprot.writeI32(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.nhop_count)
    value = (value * 31) ^ hash(self.nhop_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_ecmp_member_add_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_ecmp_member_add_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_ecmp_member_delete_args:
  """
  Attributes:
   - device
   - handle
   - nhop_count
   - nhop_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'handle', None, None, ), # 2
    (3, TType.I16, 'nhop_count', None, None, ), # 3
    (4, TType.LIST, 'nhop_handle', (TType.I32,None), None, ), # 4
  )

  def __init__(self, device=None, handle=None, nhop_count=None, nhop_handle=None,):
    self.device = device
    self.handle = handle
    self.nhop_count = nhop_count
    self.nhop_handle = nhop_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.nhop_count = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.nhop_handle = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = iprot.readI32()
            self.nhop_handle.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_ecmp_member_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 2)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    if self.nhop_count is not None:
      oprot.writeFieldBegin('nhop_count', TType.I16, 3)
      oprot.writeI16(self.nhop_count)
      oprot.writeFieldEnd()
    if self.nhop_handle is not None:
      oprot.writeFieldBegin('nhop_handle', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.nhop_handle))
      for iter55 in self.nhop_handle:
        oprot.writeI32(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.nhop_count)
    value = (value * 31) ^ hash(self.nhop_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_l3_ecmp_member_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_l3_ecmp_member_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_lag_create_args:
  """
  Attributes:
   - device
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
  )

  def __init__(self, device=None,):
    self.device = device

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_lag_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_lag_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_lag_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_lag_delete_args:
  """
  Attributes:
   - device
   - lag_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'lag_handle', None, None, ), # 2
  )

  def __init__(self, device=None, lag_handle=None,):
    self.device = device
    self.lag_handle = lag_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.lag_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_lag_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.lag_handle is not None:
      oprot.writeFieldBegin('lag_handle', TType.I32, 2)
      oprot.writeI32(self.lag_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.lag_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_lag_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_lag_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_lag_member_add_args:
  """
  Attributes:
   - device
   - lag_handle
   - side
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'lag_handle', None, None, ), # 2
    (3, TType.I32, 'side', None, None, ), # 3
    (4, TType.I32, 'port', None, None, ), # 4
  )

  def __init__(self, device=None, lag_handle=None, side=None, port=None,):
    self.device = device
    self.lag_handle = lag_handle
    self.side = side
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.lag_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.side = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_lag_member_add_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.lag_handle is not None:
      oprot.writeFieldBegin('lag_handle', TType.I32, 2)
      oprot.writeI32(self.lag_handle)
      oprot.writeFieldEnd()
    if self.side is not None:
      oprot.writeFieldBegin('side', TType.I32, 3)
      oprot.writeI32(self.side)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 4)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.lag_handle)
    value = (value * 31) ^ hash(self.side)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_lag_member_add_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_lag_member_add_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_lag_member_delete_args:
  """
  Attributes:
   - device
   - lag_handle
   - side
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'lag_handle', None, None, ), # 2
    (3, TType.I32, 'side', None, None, ), # 3
    (4, TType.I32, 'port', None, None, ), # 4
  )

  def __init__(self, device=None, lag_handle=None, side=None, port=None,):
    self.device = device
    self.lag_handle = lag_handle
    self.side = side
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.lag_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.side = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_lag_member_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.lag_handle is not None:
      oprot.writeFieldBegin('lag_handle', TType.I32, 2)
      oprot.writeI32(self.lag_handle)
      oprot.writeFieldEnd()
    if self.side is not None:
      oprot.writeFieldBegin('side', TType.I32, 3)
      oprot.writeI32(self.side)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 4)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.lag_handle)
    value = (value * 31) ^ hash(self.side)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_lag_member_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_lag_member_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_lag_print_all_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_lag_print_all_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_lag_print_all_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_lag_print_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_logical_network_create_args:
  """
  Attributes:
   - device
   - info
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.STRUCT, 'info', (switcht_logical_network_t, switcht_logical_network_t.thrift_spec), None, ), # 2
  )

  def __init__(self, device=None, info=None,):
    self.device = device
    self.info = info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.info = switcht_logical_network_t()
          self.info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_logical_network_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.info is not None:
      oprot.writeFieldBegin('info', TType.STRUCT, 2)
      self.info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_logical_network_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_logical_network_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_logical_network_delete_args:
  """
  Attributes:
   - device
   - network_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'network_handle', None, None, ), # 2
  )

  def __init__(self, device=None, network_handle=None,):
    self.device = device
    self.network_handle = network_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.network_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_logical_network_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.network_handle is not None:
      oprot.writeFieldBegin('network_handle', TType.I32, 2)
      oprot.writeI32(self.network_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.network_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_logical_network_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_logical_network_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_tunnel_interface_create_args:
  """
  Attributes:
   - device
   - direction
   - tun_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'direction', None, None, ), # 2
    (3, TType.STRUCT, 'tun_info', (switcht_tunnel_info_t, switcht_tunnel_info_t.thrift_spec), None, ), # 3
  )

  def __init__(self, device=None, direction=None, tun_info=None,):
    self.device = device
    self.direction = direction
    self.tun_info = tun_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.direction = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.tun_info = switcht_tunnel_info_t()
          self.tun_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_tunnel_interface_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.direction is not None:
      oprot.writeFieldBegin('direction', TType.I32, 2)
      oprot.writeI32(self.direction)
      oprot.writeFieldEnd()
    if self.tun_info is not None:
      oprot.writeFieldBegin('tun_info', TType.STRUCT, 3)
      self.tun_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.direction)
    value = (value * 31) ^ hash(self.tun_info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_tunnel_interface_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_tunnel_interface_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_tunnel_interface_delete_args:
  """
  Attributes:
   - device
   - tun_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'tun_handle', None, None, ), # 2
  )

  def __init__(self, device=None, tun_handle=None,):
    self.device = device
    self.tun_handle = tun_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.tun_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_tunnel_interface_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.tun_handle is not None:
      oprot.writeFieldBegin('tun_handle', TType.I32, 2)
      oprot.writeI32(self.tun_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.tun_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_tunnel_interface_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_tunnel_interface_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_logical_network_member_add_args:
  """
  Attributes:
   - device
   - network_handle
   - interface_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'network_handle', None, None, ), # 2
    (3, TType.I32, 'interface_handle', None, None, ), # 3
  )

  def __init__(self, device=None, network_handle=None, interface_handle=None,):
    self.device = device
    self.network_handle = network_handle
    self.interface_handle = interface_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.network_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.interface_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_logical_network_member_add_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.network_handle is not None:
      oprot.writeFieldBegin('network_handle', TType.I32, 2)
      oprot.writeI32(self.network_handle)
      oprot.writeFieldEnd()
    if self.interface_handle is not None:
      oprot.writeFieldBegin('interface_handle', TType.I32, 3)
      oprot.writeI32(self.interface_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.network_handle)
    value = (value * 31) ^ hash(self.interface_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_logical_network_member_add_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_logical_network_member_add_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_logical_network_member_remove_args:
  """
  Attributes:
   - device
   - network_handle
   - interface_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'network_handle', None, None, ), # 2
    (3, TType.I32, 'interface_handle', None, None, ), # 3
  )

  def __init__(self, device=None, network_handle=None, interface_handle=None,):
    self.device = device
    self.network_handle = network_handle
    self.interface_handle = interface_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.network_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.interface_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_logical_network_member_remove_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.network_handle is not None:
      oprot.writeFieldBegin('network_handle', TType.I32, 2)
      oprot.writeI32(self.network_handle)
      oprot.writeFieldEnd()
    if self.interface_handle is not None:
      oprot.writeFieldBegin('interface_handle', TType.I32, 3)
      oprot.writeI32(self.interface_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.network_handle)
    value = (value * 31) ^ hash(self.interface_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_logical_network_member_remove_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_logical_network_member_remove_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mpls_tunnel_transit_create_args:
  """
  Attributes:
   - device
   - mpls_encap
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.STRUCT, 'mpls_encap', (switcht_mpls_encap_t, switcht_mpls_encap_t.thrift_spec), None, ), # 2
  )

  def __init__(self, device=None, mpls_encap=None,):
    self.device = device
    self.mpls_encap = mpls_encap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.mpls_encap = switcht_mpls_encap_t()
          self.mpls_encap.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mpls_tunnel_transit_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.mpls_encap is not None:
      oprot.writeFieldBegin('mpls_encap', TType.STRUCT, 2)
      self.mpls_encap.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.mpls_encap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mpls_tunnel_transit_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mpls_tunnel_transit_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mpls_tunnel_transit_delete_args:
  """
  Attributes:
   - device
   - mpls_encap
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.STRUCT, 'mpls_encap', (switcht_mpls_encap_t, switcht_mpls_encap_t.thrift_spec), None, ), # 2
  )

  def __init__(self, device=None, mpls_encap=None,):
    self.device = device
    self.mpls_encap = mpls_encap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.mpls_encap = switcht_mpls_encap_t()
          self.mpls_encap.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mpls_tunnel_transit_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.mpls_encap is not None:
      oprot.writeFieldBegin('mpls_encap', TType.STRUCT, 2)
      self.mpls_encap.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.mpls_encap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mpls_tunnel_transit_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mpls_tunnel_transit_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_group_create_args:
  """
  Attributes:
   - device
   - stp_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'stp_mode', None, None, ), # 2
  )

  def __init__(self, device=None, stp_mode=None,):
    self.device = device
    self.stp_mode = stp_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.stp_mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_group_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.stp_mode is not None:
      oprot.writeFieldBegin('stp_mode', TType.I32, 2)
      oprot.writeI32(self.stp_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.stp_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_group_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_group_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_group_delete_args:
  """
  Attributes:
   - device
   - stp_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'stp_handle', None, None, ), # 2
  )

  def __init__(self, device=None, stp_handle=None,):
    self.device = device
    self.stp_handle = stp_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.stp_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_group_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.stp_handle is not None:
      oprot.writeFieldBegin('stp_handle', TType.I32, 2)
      oprot.writeI32(self.stp_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.stp_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_group_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_group_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_group_vlans_add_args:
  """
  Attributes:
   - device
   - stp_handle
   - vlan_count
   - vlan_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'stp_handle', None, None, ), # 2
    (3, TType.I16, 'vlan_count', None, None, ), # 3
    (4, TType.LIST, 'vlan_handle', (TType.I32,None), None, ), # 4
  )

  def __init__(self, device=None, stp_handle=None, vlan_count=None, vlan_handle=None,):
    self.device = device
    self.stp_handle = stp_handle
    self.vlan_count = vlan_count
    self.vlan_handle = vlan_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.stp_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.vlan_count = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.vlan_handle = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = iprot.readI32()
            self.vlan_handle.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_group_vlans_add_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.stp_handle is not None:
      oprot.writeFieldBegin('stp_handle', TType.I32, 2)
      oprot.writeI32(self.stp_handle)
      oprot.writeFieldEnd()
    if self.vlan_count is not None:
      oprot.writeFieldBegin('vlan_count', TType.I16, 3)
      oprot.writeI16(self.vlan_count)
      oprot.writeFieldEnd()
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.vlan_handle))
      for iter62 in self.vlan_handle:
        oprot.writeI32(iter62)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.stp_handle)
    value = (value * 31) ^ hash(self.vlan_count)
    value = (value * 31) ^ hash(self.vlan_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_group_vlans_add_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_group_vlans_add_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_group_vlans_remove_args:
  """
  Attributes:
   - device
   - stp_handle
   - vlan_count
   - vlan_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'stp_handle', None, None, ), # 2
    (3, TType.I16, 'vlan_count', None, None, ), # 3
    (4, TType.LIST, 'vlan_handle', (TType.I32,None), None, ), # 4
  )

  def __init__(self, device=None, stp_handle=None, vlan_count=None, vlan_handle=None,):
    self.device = device
    self.stp_handle = stp_handle
    self.vlan_count = vlan_count
    self.vlan_handle = vlan_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.stp_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.vlan_count = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.vlan_handle = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = iprot.readI32()
            self.vlan_handle.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_group_vlans_remove_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.stp_handle is not None:
      oprot.writeFieldBegin('stp_handle', TType.I32, 2)
      oprot.writeI32(self.stp_handle)
      oprot.writeFieldEnd()
    if self.vlan_count is not None:
      oprot.writeFieldBegin('vlan_count', TType.I16, 3)
      oprot.writeI16(self.vlan_count)
      oprot.writeFieldEnd()
    if self.vlan_handle is not None:
      oprot.writeFieldBegin('vlan_handle', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.vlan_handle))
      for iter69 in self.vlan_handle:
        oprot.writeI32(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.stp_handle)
    value = (value * 31) ^ hash(self.vlan_count)
    value = (value * 31) ^ hash(self.vlan_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_group_vlans_remove_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_group_vlans_remove_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_port_state_set_args:
  """
  Attributes:
   - device
   - stp_handle
   - intf_handle
   - stp_state
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'stp_handle', None, None, ), # 2
    (3, TType.I32, 'intf_handle', None, None, ), # 3
    (4, TType.I32, 'stp_state', None, None, ), # 4
  )

  def __init__(self, device=None, stp_handle=None, intf_handle=None, stp_state=None,):
    self.device = device
    self.stp_handle = stp_handle
    self.intf_handle = intf_handle
    self.stp_state = stp_state

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.stp_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.intf_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.stp_state = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_port_state_set_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.stp_handle is not None:
      oprot.writeFieldBegin('stp_handle', TType.I32, 2)
      oprot.writeI32(self.stp_handle)
      oprot.writeFieldEnd()
    if self.intf_handle is not None:
      oprot.writeFieldBegin('intf_handle', TType.I32, 3)
      oprot.writeI32(self.intf_handle)
      oprot.writeFieldEnd()
    if self.stp_state is not None:
      oprot.writeFieldBegin('stp_state', TType.I32, 4)
      oprot.writeI32(self.stp_state)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.stp_handle)
    value = (value * 31) ^ hash(self.intf_handle)
    value = (value * 31) ^ hash(self.stp_state)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_port_state_set_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_port_state_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_port_state_clear_args:
  """
  Attributes:
   - device
   - stp_handle
   - intf_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'stp_handle', None, None, ), # 2
    (3, TType.I32, 'intf_handle', None, None, ), # 3
  )

  def __init__(self, device=None, stp_handle=None, intf_handle=None,):
    self.device = device
    self.stp_handle = stp_handle
    self.intf_handle = intf_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.stp_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.intf_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_port_state_clear_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.stp_handle is not None:
      oprot.writeFieldBegin('stp_handle', TType.I32, 2)
      oprot.writeI32(self.stp_handle)
      oprot.writeFieldEnd()
    if self.intf_handle is not None:
      oprot.writeFieldBegin('intf_handle', TType.I32, 3)
      oprot.writeI32(self.intf_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.stp_handle)
    value = (value * 31) ^ hash(self.intf_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_port_state_clear_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_port_state_clear_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_group_print_all_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_group_print_all_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_stp_group_print_all_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_stp_group_print_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_list_create_args:
  """
  Attributes:
   - device
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
  )

  def __init__(self, device=None, type=None,):
    self.device = device
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_list_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_list_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_list_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_list_delete_args:
  """
  Attributes:
   - device
   - handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'handle', None, None, ), # 2
  )

  def __init__(self, device=None, handle=None,):
    self.device = device
    self.handle = handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_list_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 2)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_list_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_list_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_ip_rule_create_args:
  """
  Attributes:
   - device
   - acl_handle
   - priority
   - key_value_count
   - acl_kvp
   - action
   - action_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'acl_handle', None, None, ), # 2
    (3, TType.I32, 'priority', None, None, ), # 3
    (4, TType.I32, 'key_value_count', None, None, ), # 4
    (5, TType.LIST, 'acl_kvp', (TType.STRUCT,(switcht_acl_ip_key_value_pair_t, switcht_acl_ip_key_value_pair_t.thrift_spec)), None, ), # 5
    (6, TType.I32, 'action', None, None, ), # 6
    (7, TType.STRUCT, 'action_params', (switcht_acl_action_params_t, switcht_acl_action_params_t.thrift_spec), None, ), # 7
  )

  def __init__(self, device=None, acl_handle=None, priority=None, key_value_count=None, acl_kvp=None, action=None, action_params=None,):
    self.device = device
    self.acl_handle = acl_handle
    self.priority = priority
    self.key_value_count = key_value_count
    self.acl_kvp = acl_kvp
    self.action = action
    self.action_params = action_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.acl_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.priority = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.key_value_count = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.acl_kvp = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = switcht_acl_ip_key_value_pair_t()
            _elem75.read(iprot)
            self.acl_kvp.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.action = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.action_params = switcht_acl_action_params_t()
          self.action_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_ip_rule_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.acl_handle is not None:
      oprot.writeFieldBegin('acl_handle', TType.I32, 2)
      oprot.writeI32(self.acl_handle)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 3)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.key_value_count is not None:
      oprot.writeFieldBegin('key_value_count', TType.I32, 4)
      oprot.writeI32(self.key_value_count)
      oprot.writeFieldEnd()
    if self.acl_kvp is not None:
      oprot.writeFieldBegin('acl_kvp', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.acl_kvp))
      for iter76 in self.acl_kvp:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 6)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.action_params is not None:
      oprot.writeFieldBegin('action_params', TType.STRUCT, 7)
      self.action_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.acl_handle)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.key_value_count)
    value = (value * 31) ^ hash(self.acl_kvp)
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.action_params)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_ip_rule_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_ip_rule_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_mirror_rule_create_args:
  """
  Attributes:
   - device
   - acl_handle
   - priority
   - key_value_count
   - acl_kvp
   - action
   - action_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'acl_handle', None, None, ), # 2
    (3, TType.I32, 'priority', None, None, ), # 3
    (4, TType.I32, 'key_value_count', None, None, ), # 4
    (5, TType.LIST, 'acl_kvp', (TType.STRUCT,(switcht_acl_mirror_key_value_pair_t, switcht_acl_mirror_key_value_pair_t.thrift_spec)), None, ), # 5
    (6, TType.I32, 'action', None, None, ), # 6
    (7, TType.STRUCT, 'action_params', (switcht_acl_action_params_t, switcht_acl_action_params_t.thrift_spec), None, ), # 7
  )

  def __init__(self, device=None, acl_handle=None, priority=None, key_value_count=None, acl_kvp=None, action=None, action_params=None,):
    self.device = device
    self.acl_handle = acl_handle
    self.priority = priority
    self.key_value_count = key_value_count
    self.acl_kvp = acl_kvp
    self.action = action
    self.action_params = action_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.acl_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.priority = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.key_value_count = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.acl_kvp = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = switcht_acl_mirror_key_value_pair_t()
            _elem82.read(iprot)
            self.acl_kvp.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.action = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.action_params = switcht_acl_action_params_t()
          self.action_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_mirror_rule_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.acl_handle is not None:
      oprot.writeFieldBegin('acl_handle', TType.I32, 2)
      oprot.writeI32(self.acl_handle)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 3)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.key_value_count is not None:
      oprot.writeFieldBegin('key_value_count', TType.I32, 4)
      oprot.writeI32(self.key_value_count)
      oprot.writeFieldEnd()
    if self.acl_kvp is not None:
      oprot.writeFieldBegin('acl_kvp', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.acl_kvp))
      for iter83 in self.acl_kvp:
        iter83.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 6)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.action_params is not None:
      oprot.writeFieldBegin('action_params', TType.STRUCT, 7)
      self.action_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.acl_handle)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.key_value_count)
    value = (value * 31) ^ hash(self.acl_kvp)
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.action_params)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_mirror_rule_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_mirror_rule_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_system_rule_create_args:
  """
  Attributes:
   - device
   - acl_handle
   - priority
   - key_value_count
   - acl_kvp
   - action
   - action_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'acl_handle', None, None, ), # 2
    (3, TType.I32, 'priority', None, None, ), # 3
    (4, TType.I32, 'key_value_count', None, None, ), # 4
    (5, TType.LIST, 'acl_kvp', (TType.STRUCT,(switcht_acl_system_key_value_pair_t, switcht_acl_system_key_value_pair_t.thrift_spec)), None, ), # 5
    (6, TType.I32, 'action', None, None, ), # 6
    (7, TType.STRUCT, 'action_params', (switcht_acl_action_params_t, switcht_acl_action_params_t.thrift_spec), None, ), # 7
  )

  def __init__(self, device=None, acl_handle=None, priority=None, key_value_count=None, acl_kvp=None, action=None, action_params=None,):
    self.device = device
    self.acl_handle = acl_handle
    self.priority = priority
    self.key_value_count = key_value_count
    self.acl_kvp = acl_kvp
    self.action = action
    self.action_params = action_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.acl_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.priority = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.key_value_count = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.acl_kvp = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = switcht_acl_system_key_value_pair_t()
            _elem89.read(iprot)
            self.acl_kvp.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.action = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.action_params = switcht_acl_action_params_t()
          self.action_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_system_rule_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.acl_handle is not None:
      oprot.writeFieldBegin('acl_handle', TType.I32, 2)
      oprot.writeI32(self.acl_handle)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 3)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.key_value_count is not None:
      oprot.writeFieldBegin('key_value_count', TType.I32, 4)
      oprot.writeI32(self.key_value_count)
      oprot.writeFieldEnd()
    if self.acl_kvp is not None:
      oprot.writeFieldBegin('acl_kvp', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.acl_kvp))
      for iter90 in self.acl_kvp:
        iter90.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 6)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.action_params is not None:
      oprot.writeFieldBegin('action_params', TType.STRUCT, 7)
      self.action_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.acl_handle)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.key_value_count)
    value = (value * 31) ^ hash(self.acl_kvp)
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.action_params)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_system_rule_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_system_rule_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_egr_rule_create_args:
  """
  Attributes:
   - device
   - acl_handle
   - priority
   - key_value_count
   - acl_kvp
   - action
   - action_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'acl_handle', None, None, ), # 2
    (3, TType.I32, 'priority', None, None, ), # 3
    (4, TType.I32, 'key_value_count', None, None, ), # 4
    (5, TType.LIST, 'acl_kvp', (TType.STRUCT,(switcht_acl_egr_key_value_pair_t, switcht_acl_egr_key_value_pair_t.thrift_spec)), None, ), # 5
    (6, TType.I32, 'action', None, None, ), # 6
    (7, TType.STRUCT, 'action_params', (switcht_acl_action_params_t, switcht_acl_action_params_t.thrift_spec), None, ), # 7
  )

  def __init__(self, device=None, acl_handle=None, priority=None, key_value_count=None, acl_kvp=None, action=None, action_params=None,):
    self.device = device
    self.acl_handle = acl_handle
    self.priority = priority
    self.key_value_count = key_value_count
    self.acl_kvp = acl_kvp
    self.action = action
    self.action_params = action_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.acl_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.priority = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.key_value_count = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.acl_kvp = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in xrange(_size91):
            _elem96 = switcht_acl_egr_key_value_pair_t()
            _elem96.read(iprot)
            self.acl_kvp.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.action = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.action_params = switcht_acl_action_params_t()
          self.action_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_egr_rule_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.acl_handle is not None:
      oprot.writeFieldBegin('acl_handle', TType.I32, 2)
      oprot.writeI32(self.acl_handle)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 3)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.key_value_count is not None:
      oprot.writeFieldBegin('key_value_count', TType.I32, 4)
      oprot.writeI32(self.key_value_count)
      oprot.writeFieldEnd()
    if self.acl_kvp is not None:
      oprot.writeFieldBegin('acl_kvp', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.acl_kvp))
      for iter97 in self.acl_kvp:
        iter97.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 6)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.action_params is not None:
      oprot.writeFieldBegin('action_params', TType.STRUCT, 7)
      self.action_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.acl_handle)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.key_value_count)
    value = (value * 31) ^ hash(self.acl_kvp)
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.action_params)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_egr_rule_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_egr_rule_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_rule_delete_args:
  """
  Attributes:
   - device
   - acl_handle
   - handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'acl_handle', None, None, ), # 2
    (3, TType.I32, 'handle', None, None, ), # 3
  )

  def __init__(self, device=None, acl_handle=None, handle=None,):
    self.device = device
    self.acl_handle = acl_handle
    self.handle = handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.acl_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_rule_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.acl_handle is not None:
      oprot.writeFieldBegin('acl_handle', TType.I32, 2)
      oprot.writeI32(self.acl_handle)
      oprot.writeFieldEnd()
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.I32, 3)
      oprot.writeI32(self.handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.acl_handle)
    value = (value * 31) ^ hash(self.handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_rule_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_rule_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_reference_args:
  """
  Attributes:
   - device
   - acl_handle
   - interface_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'acl_handle', None, None, ), # 2
    (3, TType.I32, 'interface_handle', None, None, ), # 3
  )

  def __init__(self, device=None, acl_handle=None, interface_handle=None,):
    self.device = device
    self.acl_handle = acl_handle
    self.interface_handle = interface_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.acl_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.interface_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_reference_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.acl_handle is not None:
      oprot.writeFieldBegin('acl_handle', TType.I32, 2)
      oprot.writeI32(self.acl_handle)
      oprot.writeFieldEnd()
    if self.interface_handle is not None:
      oprot.writeFieldBegin('interface_handle', TType.I32, 3)
      oprot.writeI32(self.interface_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.acl_handle)
    value = (value * 31) ^ hash(self.interface_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_reference_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_reference_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_remove_args:
  """
  Attributes:
   - device
   - acl_handle
   - interface_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'acl_handle', None, None, ), # 2
    (3, TType.I32, 'interface_handle', None, None, ), # 3
  )

  def __init__(self, device=None, acl_handle=None, interface_handle=None,):
    self.device = device
    self.acl_handle = acl_handle
    self.interface_handle = interface_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.acl_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.interface_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_remove_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.acl_handle is not None:
      oprot.writeFieldBegin('acl_handle', TType.I32, 2)
      oprot.writeI32(self.acl_handle)
      oprot.writeFieldEnd()
    if self.interface_handle is not None:
      oprot.writeFieldBegin('interface_handle', TType.I32, 3)
      oprot.writeI32(self.interface_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.acl_handle)
    value = (value * 31) ^ hash(self.interface_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_acl_remove_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_acl_remove_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_group_create_args:
  """
  Attributes:
   - device
   - hostif_group
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.STRUCT, 'hostif_group', (switcht_hostif_group_t, switcht_hostif_group_t.thrift_spec), None, ), # 2
  )

  def __init__(self, device=None, hostif_group=None,):
    self.device = device
    self.hostif_group = hostif_group

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.hostif_group = switcht_hostif_group_t()
          self.hostif_group.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_group_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.hostif_group is not None:
      oprot.writeFieldBegin('hostif_group', TType.STRUCT, 2)
      self.hostif_group.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.hostif_group)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_group_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_group_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_group_delete_args:
  """
  Attributes:
   - device
   - hostif_group_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'hostif_group_handle', None, None, ), # 2
  )

  def __init__(self, device=None, hostif_group_handle=None,):
    self.device = device
    self.hostif_group_handle = hostif_group_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.hostif_group_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_group_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.hostif_group_handle is not None:
      oprot.writeFieldBegin('hostif_group_handle', TType.I32, 2)
      oprot.writeI32(self.hostif_group_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.hostif_group_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_group_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_group_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_reason_code_create_args:
  """
  Attributes:
   - device
   - rcode_api_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.STRUCT, 'rcode_api_info', (switcht_api_hostif_rcode_info_t, switcht_api_hostif_rcode_info_t.thrift_spec), None, ), # 2
  )

  def __init__(self, device=None, rcode_api_info=None,):
    self.device = device
    self.rcode_api_info = rcode_api_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.rcode_api_info = switcht_api_hostif_rcode_info_t()
          self.rcode_api_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_reason_code_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.rcode_api_info is not None:
      oprot.writeFieldBegin('rcode_api_info', TType.STRUCT, 2)
      self.rcode_api_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.rcode_api_info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_reason_code_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_reason_code_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_reason_code_delete_args:
  """
  Attributes:
   - device
   - reason_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'reason_code', None, None, ), # 2
  )

  def __init__(self, device=None, reason_code=None,):
    self.device = device
    self.reason_code = reason_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.reason_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_reason_code_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.reason_code is not None:
      oprot.writeFieldBegin('reason_code', TType.I32, 2)
      oprot.writeI32(self.reason_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.reason_code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_reason_code_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_reason_code_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_create_args:
  """
  Attributes:
   - device
   - hostif
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.STRUCT, 'hostif', (switcht_hostif_t, switcht_hostif_t.thrift_spec), None, ), # 2
  )

  def __init__(self, device=None, hostif=None,):
    self.device = device
    self.hostif = hostif

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.hostif = switcht_hostif_t()
          self.hostif.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.hostif is not None:
      oprot.writeFieldBegin('hostif', TType.STRUCT, 2)
      self.hostif.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.hostif)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_delete_args:
  """
  Attributes:
   - device
   - hostif_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'hostif_handle', None, None, ), # 2
  )

  def __init__(self, device=None, hostif_handle=None,):
    self.device = device
    self.hostif_handle = hostif_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.hostif_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.hostif_handle is not None:
      oprot.writeFieldBegin('hostif_handle', TType.I32, 2)
      oprot.writeI32(self.hostif_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.hostif_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_hostif_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_hostif_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mirror_session_create_args:
  """
  Attributes:
   - device
   - api_mirror_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.STRUCT, 'api_mirror_info', (switcht_mirror_info_t, switcht_mirror_info_t.thrift_spec), None, ), # 2
  )

  def __init__(self, device=None, api_mirror_info=None,):
    self.device = device
    self.api_mirror_info = api_mirror_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.api_mirror_info = switcht_mirror_info_t()
          self.api_mirror_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mirror_session_create_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.api_mirror_info is not None:
      oprot.writeFieldBegin('api_mirror_info', TType.STRUCT, 2)
      self.api_mirror_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.api_mirror_info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mirror_session_create_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mirror_session_create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mirror_session_update_args:
  """
  Attributes:
   - device
   - mirror_handle
   - api_mirror_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'mirror_handle', None, None, ), # 2
    (3, TType.STRUCT, 'api_mirror_info', (switcht_mirror_info_t, switcht_mirror_info_t.thrift_spec), None, ), # 3
  )

  def __init__(self, device=None, mirror_handle=None, api_mirror_info=None,):
    self.device = device
    self.mirror_handle = mirror_handle
    self.api_mirror_info = api_mirror_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.mirror_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.api_mirror_info = switcht_mirror_info_t()
          self.api_mirror_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mirror_session_update_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.mirror_handle is not None:
      oprot.writeFieldBegin('mirror_handle', TType.I32, 2)
      oprot.writeI32(self.mirror_handle)
      oprot.writeFieldEnd()
    if self.api_mirror_info is not None:
      oprot.writeFieldBegin('api_mirror_info', TType.STRUCT, 3)
      self.api_mirror_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.mirror_handle)
    value = (value * 31) ^ hash(self.api_mirror_info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mirror_session_update_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mirror_session_update_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mirror_session_delete_args:
  """
  Attributes:
   - device
   - mirror_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'mirror_handle', None, None, ), # 2
  )

  def __init__(self, device=None, mirror_handle=None,):
    self.device = device
    self.mirror_handle = mirror_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.mirror_handle = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mirror_session_delete_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.mirror_handle is not None:
      oprot.writeFieldBegin('mirror_handle', TType.I32, 2)
      oprot.writeI32(self.mirror_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.mirror_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_api_mirror_session_delete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_api_mirror_session_delete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_int_transit_enable_args:
  """
  Attributes:
   - device
   - switch_id
   - enable
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'device', None, None, ), # 1
    (2, TType.I32, 'switch_id', None, None, ), # 2
    (3, TType.I32, 'enable', None, None, ), # 3
  )

  def __init__(self, device=None, switch_id=None, enable=None,):
    self.device = device
    self.switch_id = switch_id
    self.enable = enable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.device = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.switch_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.enable = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_int_transit_enable_args')
    if self.device is not None:
      oprot.writeFieldBegin('device', TType.BYTE, 1)
      oprot.writeByte(self.device)
      oprot.writeFieldEnd()
    if self.switch_id is not None:
      oprot.writeFieldBegin('switch_id', TType.I32, 2)
      oprot.writeI32(self.switch_id)
      oprot.writeFieldEnd()
    if self.enable is not None:
      oprot.writeFieldBegin('enable', TType.I32, 3)
      oprot.writeI32(self.enable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device)
    value = (value * 31) ^ hash(self.switch_id)
    value = (value * 31) ^ hash(self.enable)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class switcht_int_transit_enable_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('switcht_int_transit_enable_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
